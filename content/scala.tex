\chapter{Scala}

Šiame skyriuje pristatyta programavimo kalba \plangname{Scala}:
nurodyta kuo ji skiriasi nuo \plangname{Java}, aprašytas
ir išanalizuotas \plangname{Scala} komponentinis modelis,
pateiktas pavyzdys iliustruojantis \plangname{Scala} komponentinio
privalumus lyginant su programavimu \plangname{Java}.

\section{\plangname{Scala} ir \plangname{Java} skirtumai}

\plangname{Scala} kūrėjų \cite[1]{scala-overview} teigimu bent iš
dalies komponentinių technologijų evoliucijai trukdo programavimo
kalbų, kurios yra naudojamos komponentų kūrimui ir jų jungimui,
trūkumai. Dėl šios priežasties jie pabandė sukurti programavimo
kalbą, su kuria naudojant tas pačias priemones galima būtų aprašyti
tiek mažas tiek dideles dalis\footnote{\plangname{Scala} išsišifruoja,
kaip \emph{scalable language}.}. \plangname{Scala} yra multiparadigminė
programavimo kalba, derinanti objektinio ir funkcinio programavimo
savybes:
\begin{itemize}
  \item ji yra objektinė kalba ta prasme, kad kiekviena reikšmė
    \en{value} yra objektas ir kiekviena operacija yra metodo kvietimas
    \cite[3]{scala-overview};
  \item ji yra funkcinė kalba ta prasme, kad kiekviena funkcija yra
    reikšmė \en{value}.
\end{itemize}
Toliau yra pristatoma kuo \plangname{Scala} pakeitė statinį, klasinį
objektinį programavimą, kuriam „atstovauja“ \plangname{Java}.
\plangname{Scala}, kaip funkcinės kalbos savybės šiame darbe nėra
nagrinėjamos.

\plangname{Scala} autoriai \cite{scalable-component-abstractions}
išskyrė tris programavimo kalbos elementus įgalinančius kurti įvairaus
dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai – nariai \en{abstract type members};
  \item savo tipo anotavimas \en{selftype annotations};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}

\plangname{Scala}, be parametrizuojamųjų tipų \en{generics}, kuriuos
turi \plangname{Java}, turi dar vieną abstrakcijos mechanizmą:
\plangname{Scala} klasės gali turėti narius \en{member}, kurie
yra abstraktūs tipai. Abu mechanizmai yra pakeičiami vienas kitu:
\cite[10]{scala-overview} pateiktas pavyzdys, kaip parametrizuojamuosius
tipus galima būtų modeliuoti pasinaudojant abstrakčiais tipais, taip
pat nurodoma, kad yra įmanomas ir atvirkštinis variantas.
\plangname{Scala} kūrėjų \cite[11]{scala-overview} nurodytos
priežastys kalboje realizuoti abu mechanizmus yra skirtingi jų
panaudojimo atvejai: parametrizuojamus tipus yra siūloma naudoti kai
norime tiesiog galimybės klasės naudotojui nurodyti konkretų tipą
(tipinis pavyzdys būtų kolekcijos, \ref{lst:scala:abstract:members:4}
kodo fragmentas), o abstrakčius tipus tada, kai norime kliento kode
pasinaudoti abstrakčiu tipu. Pastaroji galimybė yra dažniausiai
naudojama su kita \plangname{Scala} „naujove“\footnote{
Visi trys programavimo kalbos elementai, kurie \plangname{Scala}
kūrėjų teigimu yra reikalingi komponentų kūrimui, (abstraktūs
tipai – nariai, savo tipo anotavimas ir modulinė maišos kompozicija)
egzistavo dar iki \plangname{Scala} sukūrimo, bet \plangname{Scala}
yra pirmoji programavimo kalba, kurioje realizuoti jie visi
\cite[2]{scalable-component-abstractions}.} – moduline maišos
kompozicija.

\begin{listing}[h]
  \begin{scalacode}
    import scala.collection.mutable.LinkedList
    val list = new LinkedList[String]
  \end{scalacode}
  \caption{Parametrizuotų tipų panaudojimo atvejis.}
  \label{lst:scala:abstract:members:4}
\end{listing}

Modulinė maišos kompozicija, tai klasių kūrimo mechanizmas
pasinaudojant fragmentų \en{trait} komponavimu. Fragmentą galimą
būtų apibrėžti kaip sąsają, kurios metodai gali turėti
realizacijas. Šiuo požiūriu fragmentai primena abstrakčias klases,
tik skirtingai nuo jų, fragmentų konstruktoriai negali turėti
parametrų. Fragmento konstrukcija leidžia pasinaudoti
multipaveldėjimo suteikiamais kodo perpanaudojimo privalumais
(klasę galima sukomponuoti iš kelių fragmentų), bet tuo pačiu, dėl
to, kad kompiliavimo metu paveldėjimo grafas yra ištiesinamas, neturi
taip vadinamos rombo problemos.

Klasių hierarchijos pakeitimas į fragmentų hierarchiją, net ir
nesinaudojant komponentinio galimybėmis, turi privalumą, kad
gauta sistema yra lengviau modifikuojama. Komponuojant klasę iš
fragmentų yra įmanoma „įlįsti“ į fragmentų hierarchijos vidų
ir ten atlikti modifikacija, ko negalima padaryti su klasių hierarchija,
nes pastarosios ištiesinimas turi tenkinti savybę: „klasės hierarchijos
ištiesinimas visada turi tiesioginės tėvinės klasės hierarchijos
ištiesinimą, kaip galūnę“\cite[57p.]{scala-reference}. Galimybė
atlikti pakeitimus vidurį hierarchijos iliustruota programa,
pateikta \ref{lst:scala:mixin:1} kodo fragmente. Jos išvestis pateikta
\ref{lst:scala:mixin:2} fragmente. Šiame pavyzdyje klasė \scala{C2}
yra sukomponuojama iš fragmentų \scala{M3} ir \scala{T4} pritaikant
maišos kompoziciją.

\begin{listing}[H]
  \inputscala{e1/Demo}
  \caption{Fragmentų hierarchijos modifikavimas.}
  \label{lst:scala:mixin:1}
\end{listing}

\begin{listing}[H]
  \begin{textcode}
    List(C1, T4, T3, T2, T1)
    List(C2, T4, T3, M3, T2, T1)
  \end{textcode}
  \caption{\ref{lst:scala:mixin:1} kodo fragmente pateiktos programos
  išvestis.}
  \label{lst:scala:mixin:2}
\end{listing}

Turbūt svarbiausia maišos kompozicijos savybė yra ta, kad konkretus
narys visada užkloja abstraktų
\cite[6]{scalable-component-abstractions}. Ši savybė leidžia
sujungti du fragmentus, kurių nesieja bendra hierarchija. Tai yra
iliustruota programoje, pateiktoje \ref{lst:scala:mixin:3} kodo
fragmente. Jos išvestis yra pateikta \ref{lst:scala:mixin:4}
fragmente. Fragmento \scala{CachedCalculation} nariai
\scala{KeyType}, \scala{ValueType} ir \scala{calculate} yra abstraktūs
ir jie yra užklojami atitinkamų narių apibrėžtų fragmente
\scala{Factorial}. Fragmente \scala{Factorial} taip pat yra
abstraktus metodas \scala{lookup}, kurį užkloja konkretus metodas
\scala{lookup}, apibrėžtas \scala{CachedCalculation}.

\begin{listing}[H]
  \inputscala{e10/Demo}
  \caption{Maišos kompozicijos pavyzdys.}
  \label{lst:scala:mixin:3}
\end{listing}

\begin{listing}[H]
  \begin{textcode}
    Calculating 3
    Calculating 2
    Calculating 1
    3! = 6
    Calculating 5
    Calculating 4
    5! = 120
  \end{textcode}
  \caption{\ref{lst:scala:mixin:3} kodo fragmente pateiktos programos
  išvestis.}
  \label{lst:scala:mixin:4}
\end{listing}

Taikant maišos kompoziciją kartais prireikia, kad
\scala{this}\footnote{this yra specialus kintamasis rodantis į
objektą, kurio metodas dabar vykdomas.} tipas būtų ne tas fragmentas,
kurio metodas šiuo metu yra vykdomas, o kažkoks kitas, išvestinis
iš šio. Tai galima realizuoti vykdymo metu keičiant \scala{this}
tipą į norimą arba pasinaudoti \plangname{Scala} savojo tipo
anotacija. Pastarasis būdas turi privalumą, kad klaidos būtų randamos
kompiliavimo metu. Savojo tipo anotacijos panaudojimo pavyzdys pateiktas
\ref{lst:scala:selftype:1} kodo fragmente, o programos išvestis
– \ref{lst:scala:selftype:2}. Šiame pavyzdyje savojo tipo anotacija
yra \scala{this: Node =>} – su ja nurodoma, kad \scala{BaseNode}
viduje \scala{this} tipas yra \scala{Node}. Todėl kvietimas
\scala{show(this)} tampa galimas.

\begin{listing}[H]
  \inputscala{e11/Demo}
  \caption{Savojo tipo anotacijos panaudojimo pavyzdys.}
  \label{lst:scala:selftype:1}
\end{listing}

\begin{listing}[H]
  \begin{textcode}
    Root
    First child
    Second child
  \end{textcode}
  \caption{\ref{lst:scala:selftype:1} kodo fragmente pateiktos programos
  išvestis.}
  \label{lst:scala:selftype:2}
\end{listing}

Be savojo tipo anotacijos \ref{lst:scala:selftype:1} pavyzdyje buvo
panaudotas dar vienas svarbus programavimo kalbos elementas – vidinė
klasė (ir fragmentas). \cite[12]{scalable-component-abstractions}
nurodo, kad jie šio elemento neįtraukė tarp būtinų komponetiniam
programavimui, vien todėl, kad vidines klases palaiko pagrindinės
\en{mainstream} programavimo kalbos. Turbūt esminis skirtumas tarp
\plangname{Java} ir \plangname{Scala} vidinių klasių yra tai, kad
\plangname{Java} vidinės klasės tipas yra susietas su išorine klase,
o \plangname{Scala} su išoriniu objektu. \ref{lst:scala:selftype:1}
kodo fragmente pateiktame pavyzdyje kintamojo \scala{root} tipas
yra \scala{tree.SimpleNode}, kai \plangname{Java} jis būtų
\scala{Tree.SimpleNode}. Ši savybė yra naudinga, pavyzdžiui, tuo, kad 
leidžia statiniais metodais užtikrinti, kad skirtingų abstrakčios
gamyklos \en{abstract factory} realizacijų objektai nebūtų maišomi
tarpusavyje \cite[36]{scala-design-patterns}. Prireikus šią savybę
galima apeiti pasinaudojant tipų projekcija \en{type projection},
tai yra išreikštinai nurodant, kad vidinės klasės objekto tipas
turi priklausyti nuo išorinės klasės. \ref{lst:scala:selftype:1}
kodo fragmente nurodyta, kad kintamojo \scala{node} tipas yra
bet kokio \scala{Tree} tipo objekto \scala{SimpleNode} tipo objektas.

\section{Scala komponentinis modelis}

\cite[37]{heineman2001component} komponentinį modelį apibrėžė kaip
standartų rinkinį. (Žr.: \ref{section:component:model} skyrelį.)
Remiantis juo aprašytas \plangname{Scala} komponentinis modelis
pateiktas lentelėje (detalius aprašymus ką turėtų apibrėžti
kiekvienas iš standartų galima rasti
\cite[38-44]{heineman2001component}):

\xtable{
  w [ 2 | 5 ]
  a [ p | p ]
  h [ Standartas | Realizacija ]
  %
  e [
    realizacija |
    Komponentas gali būti realizuojamas, kaip @plangname{Scala} klasė
    arba kaip fragmentas.
    ]
  e [
    sąsajos |
    Komponentas servisus, kurių jam reikia, nurodo kaip abstrakčius
    narius, o kuriuos jis realizuoja – kaip konkrečius.
    ]
  e [
    įvardinimas |
    Komponentams globalūs vardai yra priskiriami taip pat, kaip ir
    @plangname{Java} klasėms – pagal hierarchines vardų sritis.
    ]
  e [
    meta duomenys |
    Nėra.
    ]
  e [
    tarpusavio sąveika |
    Kadangi komponentų egzemplioriai @en{component instances} yra
    objektai, tai jie sąveikauja keisdamiesi žinutėmis.
    ]
  e [
    pritaikymas |
    Komponentą pritaikyti konkrečiam atvejui galima jam pateikiant
    kitokias jo abstrakčių narių realizacijas (pavyzdžiui, kitą
    konkretų tipą) arba naudojantis parametrizuojamais tipais
    komponento egzemplioriaus sukūrimo metu.
    ]
  e [
    kompozicija |
    Komponentai yra surišami kompiliavimo metu. Abstraktūs nariai
    su jų realizacijomis yra sujungiami pagal sutampančią
    @FIXME{Veicekausko vertimas: signatūrą}. Kompozicijos rezultatas
    yra naujas komponentas, kuris gali būti toliau komponuojamas.
    ]
  e [
    evoliucijos palaikymas |
    Kadangi komponentai yra surišami kompiliavimo metu, tai norint
    pakeisti vieną komponentą kitu reikia perkompiliuoti sistemą.
    Taip pat nėra galimybės turėti dvi to paties komponento versijas
    vienoje sistemoje.
    ]
  e [
    supakavimas ir įdiegimas |
    Nėra.
    ]
}

Pagal \cite[40]{heineman2001component} meta duomenys, tai yra
informacija apie sąsajas, komponentus ir jų ryšius. Ji leidžia
dinamiškai sujungti komponentus, taip pat ir nutolusius. Kadangi
\plangname{Scala} komponentai yra sujungiami statiškai kompiliavimo
metu, tai ši informacija nėra reikalinga.

Viena iš esminių komponento savybių yra tai, kad jis yra fizinis
diegimo vienetas. Tačiau \plangname{Scala} komponentinis modelis
neapibrėžia kokiu būdu turėtų būti platinami ir įdiegiami
komponentai. Be to komponentų naudotojas tam, kad galėtų juos
sukomponuoti į sistemą, turi turėti jų išeities tekstus. Taigi
galima būtų teigti, kad \plangname{Scala} komponentinis modelis šios
apibrėžimo dalies netenkina.

Tam, kad \plangname{Scala} komponentinis modelis visiškai tenkintų
komponentinio modelio apibrėžimą, reikia apibrėžti komponentų
platinimo būdus. Kadangi programų kodas dažniausiai yra laikomas
versijų kontrolės sistemose, tai kaip vienas iš būdų platinti
\plangname{Scala} komponentus, būtų pasinaudojant jomis. Pavyzdžiui,
\progname{Git}\footnote{\url{http://git-scm.com/}} ir
\progname{Mercurial}\footnote{\url{http://mercurial.selenic.com/}} palaiko
įdėtines saugyklas, taigi komponentų, iš kurių sudaryta sistema,
versijų kontrolės saugyklas galima būtų nurodyti, kaip įdėtines
kuriamos sistemos versijų kontrolės sistemai. Taigi tokiu
būdu papildžius \plangname{Scala} komponentinį modelį gautume
komponentinį modelį atitinkantį \cite[37]{heineman2001component}
pateiktą apibrėžimą.

\section{\plangname{Scala} komponentinio modelio savybės}

Šiame skyrelyje pabandyta palyginti \plangname{Scala} komponentinį
modelį su kitais komponentiniais modeliais, remiantis
\cite{classification-framework-for-scm} klasifikacija. Klasifikacijos
autoriai išskyrė tokias komponentinių modelių klasifikavimo dimensijas:
\begin{description}
  \item[gyvavimo ciklas] – kiek komponentinis modelis paremia kiekvieną
    iš komponento gyvavimo ciklo stadijų;
  \item[konstravimas] – kokiu būdu yra sukonstruojama sistema iš
    komponentų;
  \item[ekstra-funkcinės savybės] – ką komponentinis modelis siūlo
    ekstra-funkcinių savybių specifikavimui, valdymui ir kompozicijai.
\end{description}

\cite{classification-framework-for-scm} gyvavimo ciklą suskirstė į
keturias stadijas. Komentarai, kaip \plangname{Scala} komponentinis
modelis palaiko kiekvieną iš jų, pateikti lentelėje:
\xtable{
  w [ 2 | 5 ]
  a [ p | p ]
  h [ Stadija | Jos palaikymas ]
  %
  e [
    modeliavimas |
    Specialių metodų ar įrankių nėra. Iš dalies (be konstrukcijų
    perimtų iš funkcinių programavimo kalbų) galima modeliuoti
    pasinaudojant @progname{UML} (Unified Modeling Language), ją
    papildžius tokiomis konstrukcijomis kaip fragmentas ir
    modulinė maišos kompozicija. Galima realizacija pateikiama
    @cite&L145&R{rachimow2009scala}.
    ]
  e [
    realizacija |
    Galima teigti, kad @plangname{Scala} komponentinis modelis yra
    labiausiai orientuotas į šią komponento gyvavimo ciklo dalį.
    Komponentų realizavimui jis pateikia ne tik taisykles, bet
    ir kalbos konstrukcijas. (Skirtingai, pavyzdžiui, nuo @progname{EJB} ar
    @progname{OSGi}, kurie tik apriboja programavimo su @plangname{Java}
    būdus.) Taip pat, kitaip nei kai kurių kitų komponentinių modelių,
    @plangname{Scala} komponentinio modelio atveju, šios stadijos
    rezultatas yra komponento išeities tekstai, o ne sukompiliuotas
    komponentas.
    ]
  e [
    pakavimas |
    Šios stadijos @plangname{Scala} komponentinis modelis nepalaiko.
    ]
  e [
    įdiegimas |
    Komponentai yra surišami kompiliavimo metu.
    ]
}

\cite{classification-framework-for-scm} konstravimo dimensiją suskirstė
į tris dalis:
\begin{enumerate}
  \item sąsajų specifikavimas – komponentų sujungimo taškų nurodymas;
  \item surišimas – ryšių tarp komponentų sukūrimas;
  \item sąveika – komponentų tarpusavio komunikacija.
\end{enumerate}

Nagrinėjant \plangname{Scala} komponentinio modelio sąsajų
specifikaciją pagal \cite[600]{classification-framework-for-scm}
pateiktus kriterijus galima būtų išskirti:
\begin{enumerate}
  \item sąsajos yra paremtos operacijomis (o ne prievadais);
  \item yra aiškiai atskiriamos reikalaujamos \en{required interface}
    ir teikiamos sąsajos \en{provided interface};
  \item sąsajos yra aprašomos \plangname{Scala} programavimo kalba;
  \item sąsajų suderinamumas yra tikrinamas tik sintaksiniu
    požiūriu.
\end{enumerate}
Nagrinėjant surišimo mechanizmus galima būtų išskirti:
\begin{enumerate}
  \item komponentus galima sujungti tik tiesiogiai, tai yra sujungimai
    \en{connectors}, kaip atskiri elementai nėra išskiriami;
  \item kadangi kompozicijos rezultatas yra komponentas, tai
    galime teigti, kad \plangname{Scala} palaiko pilną vertikalią
    kompoziciją: delegavimo tipo jungimą (ansamblio prašomos /
    teikiamos sąsajos sujungiamos su vidinių jo komponentų
    prašomomis / teikiamomis sąsajomis), agregavimo jungimą
    (visos vidinių komponentų sąsajos yra pasiekiamos per ansamblio
    sąsajas) ir naujojo komponento ekstra-funkcinės savybės
    tenkina komponentinio modelio reikalavimus\NTODO{Įrodyti remiantis
    \cite{classification-framework-for-scm} pateiktais apibrėžimais.}
\end{enumerate}
Nagrinėjant komponentų sąveiką galima būtų išskirti:
\begin{enumerate}
  \item sąveikos stilius tarp komponentų yra užklausa-atsakymas
    \en{request-response};
  \item kadangi komunikacija tarp komponentų vyksta kviečiant metodus,
    tai ji yra sinchroninio tipo.
\end{enumerate}

Ekstra-funkcinės savybės:
TODO

Apibendrinant galima būtų nurodyti, kad \plangname{Scala} komponentinis
modelis iš kitų modelių, nagrinėtų
\cite{classification-framework-for-scm}, išsiskiria:
TODO

Be to, iš \cite{classification-framework-for-scm} nenagrinėtų savybių
galima būtų paminėti, kad \plangname{Scala} komponentai gali būti
labai maži (iki kelių dešimčių eilučių), tiek labai dideli (visa
sistema, ar posistemė, pavyzdžiui \plangname{Scala} kompiliatorius).

Scala vertical binding tipas yra delegation + aggregation, nes visos
vidinių komponentų sąsajos yra ansamblio sąsajos
\cite[599]{classification-framework-for-scm}. Kadangi ansamblio
ne tik sąsajos bet ir savybės tenkina komponentinio modelį, tai
Scala palaiko vertikalią kompoziciją.

Scala komponentinio modelio privalumai (remiantis
\cite{classification-framework-for-scm}):
\begin{itemize}
  \item vertikalaus sujungimo\cite[599]{classification-framework-for-scm}
    palaikymas leidžia kurti įvairaus dydžio \en{scalable} komponentus;
  \item TODO: paprastesnis komponentų panaudojimas (komponentu
    pasinaudoti (jį inicializuoti) yra paprasčiau nei komponentų
    ansambliu).
\end{itemize}

Scala komponentinio modelio trūkumai:
\begin{itemize}
  \item nėra komponentų, kaip paketų, valdymo mechanizmo (šitai galima
    apeiti pasinaudojant versijų kontrolės sistemų galimybėmis,
    pavyzdžiui, \verb|git submodule|);
  \item komponentų kiekis turi būti žinomas projektavimo metu, todėl
    Scala komponentinis modelis nėra tinkamas, pavyzdžiui,
    grafinės sąsajos elementų bibliotekos \en{GUI widgets toolkit}
    kūrimui. (Kadangi komponentai yra „užregistruojami“
    kompiliavimo metu, tai nėra, kaip pridėti trečiųjų šalių
    komponento realizacijos.)
\end{itemize}

\section{Pavyzdys: Scala komponentinis prieš Java objektinį}

e6 analizė. Cake pattern taikymas: turime ComponentA ir ComponentB,
juos sujungę į System gauname sistemą sudarytą iš dviejų komponentų.
Norėdami realizuoti analogišką sistemą su Java, turime du variantus:
\begin{enumerate}
  \item visą kodą sudėti į System, bet tada bus neįmanomas kodo
    perpanaudojimas, taip pat bus sudėtingesnis sistemos kūrimo
    darbų paskirstymas keliems programuotojams;
  \item \label{scala:exmp:enum:2} paveldėjimą pakeisti į delegavimą,
    tuo pačiu sukuriant Container, kuris pasirūpintų dalių
    sujungimu. Šiuo atveju vėl gauname kažką panašaus į
    komponentinį.
\end{enumerate}

Šis pavyzdys iliustruoja teiginį, kad komponentinis programavimas yra
susijęs ne su realizacine technologija (programavimo kalba), o su
jos naudojimo būdu, kuris užtikrina:
\begin{enumerate}
  \item galimybę dalis kurti atskirai, nepriklausomai viena nuo kitos;
  \item galimybę lengvai dalį pakeisti kita jos realizacija.
\end{enumerate}

\chapter{Scala}

\section{Tikslas}

Išsiaiškinti, kaip galima būtų padidinti verslo palaikymo sistemų, kurtų
naudojant klasikines objektines programavimo kalbas, modifikuojamumą.

Sistemos modifikuojamumas suprantamas, kaip galimybė vystyti sistemą
evoliuciniu būdu: sistemą papildyti naujomis funkcijomis neliečiant
senųjų. Priešprieša evoliuciniam sistemos vystymo būdui būtų
revoliucinis: norint pridėti naują funkciją, reikia keisti jau
esamas.

Šiame darbe laikoma, kad klasikinė objektinė programavimo kalba
yra statinė klasinė objektinė programavimo kalba. Kaip pagrindinis
pavyzdys yra nagrinėjama Java.

\section{Uždaviniai}

\begin{enumerate}
  \item Išsiaiškinti, kuo klasikinį objektinį papildė Scala
    kūrėjai ir kokias papildomas galimybes suteikia pridėtosios
    savybės.
  \item Išskirti kokias savybes pridedant klasikiniam objektiniam
    galima padidinti jo modifikuojamumą.
  \item Išsiaiškinti, kaip reikėtų programuoti tam, kad pasinaudoti
    papildomų savybių suteikiamomis galimybėmis.
\end{enumerate}

\section{Scala išskirtinės savybės}

Straipsnyje \cite{scalable-component-abstractions} Martin Odersky
ir Matthias Zenger išskyrė tris savybes įgalinančias kurti
įvairaus dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai \en{abstract type members};
  \item atviros rekursijos anotacija \en{selftype annotations, open
    recursion};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}

Ką jie turi omeny sakydami įvairaus dydžio komponentus matosi
iš tokio pavyzdžio.
TODO: Pavyzdys, kaip galima perdengti nested klasę.

\subsection{Kodo dubliavimo vengimas}

Programuojant objektinėmis kalbomis, kurios neturi multipaveldėjimo
yra susiduriama su problema, jog kai kuriais atvejais yra sudėtinga
išvengti kodo dubliavimo. Panagrinėsime du pavyzdžius.

\subsubsection{Trečiųjų šalių bibliotekos kodo modifikavimas}

TODO: Pavyzdys, kaip pasinaudojant Scala savybės \en{trait} konstrukcija
galima išvengti kodo dubliavimo taisant trečiųjų šalių biblioteką.

\subsubsection{Kraunamų savybių dizaino šablonas}

\en{Stackable trait design pattern}\cite[267p.]{programming-in-scala}.

TODO: (e1)

\section{Scala komponentinis modelis}

Straipsnyje \cite{scalable-component-abstractions} Martin Odersky
ir Matthias Zenger išskyrė tris programavimo kalbos elementus
įgalinančius kurti įvairaus dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai \en{abstract type members};
  \item atviros rekursijos anotacija \en{selftype annotations, open
    recursion};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}
Visi šie elementai yra realizuoti
Scala\footnote{\url{http://www.scala-lang.org}} programavimo kalboje.

Scala, vietoj klasinėms objektinėms programavimo kalboms įprastos
sąsajos \en{interface} konstrukcijos, turi savybės \en{trait}
konstrukciją. Pagrindinis savybės ir sąsajos skirtumas yra tai, kad
savybė gali turėti konkrečias metodų realizacijas. Taigi Scala
savybė labiau primena abstrakčią klasę, tik skirtingai nuo klasės,
Scala savybių konstruktoriai neturi parametrų. Savybės konstrukcija
leidžia pasinaudoti multi paveldėjimo suteikiamais kodo perpanaudojimo
privalumais (į klasę galima sukomponuoti kelias savybes), bet tuo
pačiu, dėl to, kad kompiliavimo metu paveldėjimo grafas yra
ištiesinamas, neturi taip vadinamos rombo problemos.

Pasinaudojant Scala savybės konstrukcija su Scala galima programuoti
komponentiškai:
\begin{itemize}
  \item komponentas realizuojamas pasinaudojant Scala klasės arba
    savybės konstrukcija;
  \item komponentas savo poreikius nurodo per abstrakčius metodus;
  \item komponentas savo teikiamus servisus nurodo per savo konkrečius
    metodus;
  \item komponentai yra surišami kompiliavimo metu;
  \item komponentų kompozicijos rezultatas yra naujas komponentas
    (Scala klasė).
\end{itemize}
Kadangi komponentų kompozicijos rezultatas yra nauja klasė, tai yra
komponentas, tai ją galima toliau jungti su kitais komponentais.
Kitaip tariant Scala komponentinis modelis palaiko vertikalų
jungimą
\en{vertical binding}\cite[598p.]{classification-framework-for-scm}.
Tiesa, jis nėra visiškai pilnas, nes negalima sukomponuoti dviejų
kompozicijos rezultatų (klasių) į naują komponentą.

FIXME: Ši savybė yra objektinio, o ne komponentinio.
Klasių hierarchijos pakeitimas į savybių hierarchiją turi privalumą,
kad kompozicijos metu galima „įlįsti“ į savybių hierarchijos vidų ir ten
atlikti modifikacijas, ko negalima padaryti su klasių hierarchija,
nes pastarosios ištiesinimas turi tenkinti savybę: „klasės hierarchijos
ištiesinimas visada turi tiesioginės tėvinės klasės hierarchijos
ištiesinimą, kaip galūnę“\cite[57p.]{scala-reference}. Toks sprendimas
priimtas todėl, kad galima būtų naudoti jau sukompiliuotas klases
naujame kode.

\begin{exmp}
  Pakeisdami klasių hierarchiją į savybių hierarchiją padidiname
  sistemos modifikuojamumą, nes iš savybių rinkinio kurdami naują
  klasę skirtingai nei klasių paveldėjimo atveju, galime įterpti
  naują savybę į norimą vietą. Tai iliustruoja toks kodo fragmentas:

  \inputscala{e1/Demo}

  Jį įvykdžius į standartinę išvestį bus atspausdinta:

  \begin{textcode}
    List(C1, T4, T3, T2, T1)
    List(C2, T4, T3, M3, T2, T1)
  \end{textcode}

\end{exmp}

Be trijų aukščiau išvardintų savybių Scala kūrėjai, kaip vieną iš
itin svarbių programavimo kalbos savybių reikalingų komponentų kūrimui
išskiria įdėtines klases. Jie jos neįtraukė tarp tų trijų
savybių vien todėl, kad dauguma pagrindinių programavimo kalbų
šią savybę turi\cite[12p.]{scalable-component-abstractions}.
Galimybė naudoti įdėtines klases yra svarbi tuo, kad jos gali pasiekti
tėvinės klasės atributus be jokio papildomo surišimo tuo pačiu
išvengiant klasės vardų srities užteršimo problemos. (Jei bandytume
apsieiti be įdėtinių klasių, tai greičiausiai būtume priversti
rašyti ilgesnius metodų pavadinimus, pavyzdžiui, „loggerAppend“,
„SyntaxTreeAppend“.) Scala, skirtingai nei Java, vidinės
\en{inner} klasės yra susietos ne su supančia klase, bet su supančiu
objektu, todėl skirtingiems objektams priklausančių vidinių
klasių maišyti negalima.

Trait yra tai, ką galime sukomponuoti į klasę. Klasės komponavimo
metu mes nusprendžiame iš kokių savybių mes norime ją sudaryti.
Po sukomponavimo mes gauname standartinę Java klasę, kurią
toliau galime plėsti per numatytus plėtimo taškus. Trait naudojimas
leidžia pasinaudoti multipaveldėjimo teikiama nauda, bet apsaugo
nuo situacijos, kai bandoma sujungti dvi „nesuderinamas“ klases
(TODO: C++ pavyzdys su dviem nesuderinamomis klasėmis), nes
trait neturi konstruktoriaus ir jei jo nėra bandoma emuliuoti,
tai traitų būsena yra suderinama klasės sukomponavimo metu. Šis
modelis yra lengvai plečiamas, nes jei klasė traitams kitus traitus
perduoda pasinaudodama def konstrukcija, tai tada ją galime perdengti
išvestinėje klasėje.

Sukomponuotos klasės jau nebegalima keisti. (Lįsti į jos vidų. Ją galima
tik „anotuoti“.) Klases visur galima keisti į savybes. Klasės reikalingos
tik tada, kai mums reikia sukonstruoti naują objektą. Šis dizainas
lemia, kad egzistuoja tik viena vieta, kur yra sukonstruojamas objektas.

Taip pat šis komponentinis modelis palaiko vertikalų jungimą
\en{vertical binding}\cite[598p.]{classification-framework-for-scm}.
TODO: Įrodyti formaliai. Neformalus įrodymas: Scala palaiko vertikalų
jungimą, nes savybes sukomponavus į klasę, mes toliau galime tą
klasę komponuoti su naujomis savybėmis ir gauti naujas klases.
Visgi Scala vertikalus jungimas nėra visiškai pilnas, nes negalima
sukomponuoti dviejų ansamblių (klasių) į naują ansamblį.

Clemens Szyperski apibrėždamas
komponentą\cite{cs-beyond-object-oriented-programming} nurodė, kad tai
yra diegimo vienetas \en{unit of deployment}. Taip pat paaiškindamas
savo apibrėžimą, jis nurodė, kad komponentai būtinai turi būti
gaunami jau sukompiliuoti. Kadangi Scala komponentai jungiami
pasinaudojant kompiliatoriumi, tai Scala komponentinis modelis
šio reikalavimo netenkina, bet Szyperski aiškinimas buvo kritikuojamas
(TODO: kieno), kadangi jokio skirtumo ar komponentus gauname
jau sukompiliuotus, ar ne, jei jų įdiegimu sugeba pasirūpinti
automatinė diegimo sistema. Su Scala šioje vietoje galima išsisukti
pasinaudodami versijų kontrolės sistemų teikiamomis galimybėmis.
Pavyzdžiui, \verb|git submodule|.
TODO: Scala kompiliatorius, kaip mano programos dalis pasinaudojant git
submodule galimybėmis. (Idėja: Ar pavyktų realizuoti Scala doctest?)
Įvykdžius komandą scala yra paleidžiamas
src.compiler.scala.tools.nsc.MainGenericRunner:process
metodas. Jei kviečiamas interaktyvus rėžimas, tai jis paleidžia
src.compiler.scala.tools.nsc.interpreter.ILoop:process.
Už duomenų nuskaitymą yra atsakingas
src.compiler.scala.tools.nsc.interpreter.SimpleReader.

Scala naudoja vidines klases tam, kad sumažintų komponentų
sąsajas.\cite[13]{scalable-component-abstractions}
(Visada išreikštinai nurodant ko reikia komponentui, jo sąsajos
deklaracija užgožtų jo realizaciją.) Iš principo, turėtų būti
siekiama pusiausvyros tarp sąsajų dydžio ir išskaidymo į komponentus.

\emph{Pamoka iš e5} Dėl statinės prigimties Scala komponentinis
modelis nėra tinkamas kurti ne iš fiksuoto komponentų skaičiaus
sudarytas sistemas, pavyzdžiui, grafinės sąsajos elementų bibliotekas
\en{GUI widgets toolkit}. (Esmė, kad nėra kaip „įdėti“ trečiųjų šalių
komponento realizacijos, kadangi komponentai yra „užregistruojami“
kompiliavimo metu.) Cake pattern geriausiai veikia, kai
yra palyginti mažas galutinių tipų variantų skaičius, nes norint
pakeisti vieną komponentą kitu, reikia visuose galutiniuose tipuose
atlikti pakeitimus.

\section{Sutvarkyti}

\subsection{Scala prieš Java}

Siekiant gauti multipaveldėjimo teikiamą naudą ir tuo pačiu išvengti
dėl jo atsirandančių problemų, \plangname{Scala} programavimo
kalboje buvo realizuota fragmento \en{trait} konstrukcija.
Fragmentas tai yra…

TODO: Path dependent types? e8. Pasitikrinti iš frederik 25 psl ir
Scala Overview 11 psl. Taip pat svarbu, kad vidinės klasės tipas
priklauso nuo išorinės klasės Objekto. Kartu su abstract type
members, tai leidžia sukurti abstract factory, kurių negalima
maišyti.

TODO: Kuo abstract type members yra naudingesni prieš type parameters
pasireiškia naudojant mixin: jų nereikia nuolat kartoti.
(\url{http://www.artima.com/weblogs/viewpost.jsp?thread=270195})

TODO: Ką Scala pridėjo objektiniam (Java):
\begin{itemize}
  \item Scala tipų sistema;
  \item Scala savybės \en{trait} konstrukcija;
  \item savybių jungimas į klases panaudojant modulių maišos
    kompoziciją \en{modular mixin composition};
  \item atviros rekursijos anotacija \en{selftype annotations} –
    iš principo tik sintaksinis saldainiukas dviem konstrukcijoms
    (TODO: Ar tai, kad tai yra dviejų konstrukcijų junginys nereiškia,
    jog tai jau nėra tik sintaksinis saldainiukas?):
    \begin{enumerate}
      \item \verb|def self: S = this.asInstanceOf[S]|, žr.: Observer
        Pattern realizaciją e7;
      \item \verb|T extends C| – skirtumas tas, kad šis apibrėžia
        tvarką, kokia bus išdėstyti super kvietimai, o self-type
        – ne (TODO: Patikrinti ar tikrai.);
    \end{enumerate}
    (kadangi sujungia abi konstrukcijas į vieną, tai turi privalumą, kad
    e7 Subject pakeitus į ką nors kitą lūš kompiliavimo, o ne vykdymo
    metu; taip pat antruoju atveju C negali būti abstraktus tipas, o
    naudojant anotaciją – gali)
  \item savybių naudojimo vietoj klasių privalumai, pavyzdys e1
    (savybės perdengimas vidury hierarchijos).
\end{itemize}

TODO: Scala vidinių klasių ir Java įdėtinių klasių skirtumai. Taip pat
pavyzdys su Scala tipų sistema ir Abstract factory projektavimo šablonu.

TODO: Scala naudodama fragmentų hierarchiją patobulina esminę objektinio
programavimo savybę – „dalinimasį“ \en{sharing}. Fragmentų ir klasių
hierachija išlaiko „gerąsias“ klasių paveldėjimo mechanizmo teikiamas
savybes, bet tuo pačiu smarkiai padidina lankstumą.

TODO: Scala savybės nuo Java sąsajų skiriasi tuo, kad savybės gali turėti
metodų realizacijas.

TODO: Scala savybės nuo klasių skiriasi tuo, kad savybės negali turėti
konstruktoriaus parametrų. Šis apribojimas leidžia efektyviai
išspręsti su multipaveldėjimu susijusią rombo problemą.

Šio skyrelio tikslas parodyti kuo Scala papildė Java objektinį ir
kokias papildomas galimybes tai suteikia. (Scala, kaip komponentinė
programavimo kalba dar nenagrinėjama)

