\chapter{Scala}

Šiame skyriuje pristatyta programavimo kalba \plangname{Scala}:
nurodyta kuo ji skiriasi nuo \plangname{Java}, aprašytas
ir išanalizuotas \plangname{Scala} komponentinis modelis,
pateiktas pavyzdys iliustruojantis \plangname{Scala} komponentinio
privalumus lyginant su programavimu \plangname{Java}.

\section{\plangname{Scala} ir \plangname{Java} skirtumai}

\plangname{Scala} kūrėjų \cite[1]{scala-overview} teigimu bent iš
dalies komponentinių technologijų evoliucijai trukdo programavimo
kalbų, kurios yra naudojamos komponentų kūrimui ir jų jungimui,
trūkumai. Dėl šios priežasties jie pabandė sukurti programavimo
kalbą, su kuria naudojant tas pačias priemones galima būtų aprašyti
tiek mažas tiek dideles dalis\footnote{\plangname{Scala} išsišifruoja,
kaip \emph{scalable language}.}. \plangname{Scala} yra multiparadigminė
programavimo kalba, derinanti objektinio ir funkcinio programavimo
savybes:
\begin{itemize}
  \item ji yra objektinė kalba ta prasme, kad kiekviena reikšmė
    \en{value} yra objektas ir kiekviena operacija yra metodo kvietimas
    \cite[3]{scala-overview};
  \item ji yra funkcinė kalba ta prasme, kad kiekviena funkcija yra
    reikšmė \en{value}.
\end{itemize}
Toliau yra pristatoma kuo \plangname{Scala} pakeitė statinį, klasinį
objektinį programavimą, kuriam „atstovauja“ \plangname{Java}.
\plangname{Scala}, kaip funkcinės kalbos savybės šiame darbe nėra
nagrinėjamos.

\plangname{Scala} autoriai \cite{scalable-component-abstractions}
išskyrė tris programavimo kalbos elementus įgalinančius kurti įvairaus
dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai – nariai \en{abstract type members};
  \item savo tipo anotavimas \en{selftype annotations};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}

\plangname{Scala}, be parametrizuojamųjų tipų \en{generics}, kuriuos
turi \plangname{Java}, turi dar vieną abstrakcijos mechanizmą.
\plangname{Scala} klasės gali turėti narius \en{member}, kurie
yra abstraktūs tipai. Šiems tipams galima nurodyti, kad jie privalo
realizuoti kokias nors sąsajas arba turi būti kokios nors klasės
išvestinės klasės. Taip pat išvestinės klasės, juos gali patikslinti.
\ref{lst:scala:abstract:members} kodo fragmente nurodyta, kad abstraktus
tipas \scala|Tipas| yra išvestinis iš tipo \scala|Number|. Šis
abstrakčių tipų mechanizmas yra naudingas tuo, kad tipų
suderinamumas yra tikrinamas kompiliavimo metu
(\ref{lst:scala:abstract:members:2} kodo fragmentas), o ne
vykdymo metu, kaip \ref{lst:scala:abstract:members:3} kodo fragmente.
Šio abstrakcijos mechanizmo pranašumas prieš parametrizuojamų tipų
mechanizmą pasireiškia naudojant kitą \plangname{Scala} „naujovę“
– modulinę maišos kompoziciją.

\begin{listing}[H]
  \inputscala{e9/Langelis}
  \caption{Scala abstraktūs tipai – nariai.}
  \label{lst:scala:abstract:members:1}
\end{listing}

\begin{listing}[H]
  \inputscala{e9/Demo}
  \caption{Scala abstraktūs tipai – nariai, tipų tikrinimas
  kompiliavimo metu.}
  \label{lst:scala:abstract:members:2}
\end{listing}

\begin{listing}[H]
  \inputscala{e9/Demo2}
  \caption{Scala abstraktūs tipai – nariai, tipų tikrinimas
  vykdymo metu.}
  \label{lst:scala:abstract:members:3}
\end{listing}

Siekiant gauti multipaveldėjimo teikiamą naudą ir tuo pačiu išvengti
dėl jo atsirandančių problemų, \plangname{Scala} programavimo
kalboje buvo realizuota fragmento \en{trait} konstrukcija.
Fragmentas tai yra…

TODO: Path dependent types? e8. Pasitikrinti iš frederik 25 psl ir
Scala Overview 11 psl. Taip pat svarbu, kad vidinės klasės tipas
priklauso nuo išorinės klasės Objekto. Kartu su abstract type
members, tai leidžia sukurti abstract factory, kurių negalima
maišyti.

TODO: Kuo abstract type members yra naudingesni prieš type parameters
pasireiškia naudojant mixin: jų nereikia nuolat kartoti.
(\url{http://www.artima.com/weblogs/viewpost.jsp?thread=270195})

TODO: Ką Scala pridėjo objektiniam (Java):
\begin{itemize}
  \item Scala tipų sistema;
  \item Scala savybės \en{trait} konstrukcija;
  \item savybių jungimas į klases panaudojant modulių maišos
    kompoziciją \en{modular mixin composition};
  \item atviros rekursijos anotacija \en{selftype annotations} –
    iš principo tik sintaksinis saldainiukas dviem konstrukcijoms
    (TODO: Ar tai, kad tai yra dviejų konstrukcijų junginys nereiškia,
    jog tai jau nėra tik sintaksinis saldainiukas?):
    \begin{enumerate}
      \item \verb|def self: S = this.asInstanceOf[S]|, žr.: Observer
        Pattern realizaciją e7;
      \item \verb|T extends C| – skirtumas tas, kad šis apibrėžia
        tvarką, kokia bus išdėstyti super kvietimai, o self-type
        – ne (TODO: Patikrinti ar tikrai.);
    \end{enumerate}
    (kadangi sujungia abi konstrukcijas į vieną, tai turi privalumą, kad
    e7 Subject pakeitus į ką nors kitą lūš kompiliavimo, o ne vykdymo
    metu; taip pat antruoju atveju C negali būti abstraktus tipas, o
    naudojant anotaciją – gali)
  \item savybių naudojimo vietoj klasių privalumai, pavyzdys e1
    (savybės perdengimas vidury hierarchijos).
\end{itemize}

TODO: Scala vidinių klasių ir Java įdėtinių klasių skirtumai. Taip pat
pavyzdys su Scala tipų sistema ir Abstract factory projektavimo šablonu.

TODO: Scala naudodama fragmentų hierarchiją patobulina esminę objektinio
programavimo savybę – „dalinimasį“ \en{sharing}. Fragmentų ir klasių
hierachija išlaiko „gerąsias“ klasių paveldėjimo mechanizmo teikiamas
savybes, bet tuo pačiu smarkiai padidina lankstumą.

TODO: Scala savybės nuo Java sąsajų skiriasi tuo, kad savybės gali turėti
metodų realizacijas.

TODO: Scala savybės nuo klasių skiriasi tuo, kad savybės negali turėti
konstruktoriaus parametrų. Šis apribojimas leidžia efektyviai
išspręsti su multipaveldėjimu susijusią rombo problemą.

Šio skyrelio tikslas parodyti kuo Scala papildė Java objektinį ir
kokias papildomas galimybes tai suteikia. (Scala, kaip komponentinė
programavimo kalba dar nenagrinėjama)

\section{Scala komponentinis modelis}

TODO: Scala komponentinio modelio apibrėžimas (pagal išrinktas savybes).
Parodymas, kad Scala komponentinis modelis tenkina reikalavimus,
nurodymas kokios būtent Scala programavimo kalbos savybės kuriuos
būtent reikalavimus realizuoja.

Scala komponentinio modelio privalumai (remiantis
\cite{classification-framework-for-scm}):
\begin{itemize}
  \item vertikalaus sujungimo\cite[599]{classification-framework-for-scm}
    palaikymas leidžia kurti įvairaus dydžio \en{scalable} komponentus;
  \item TODO: paprastesnis komponentų panaudojimas (komponentu
    pasinaudoti (jį inicializuoti) yra paprasčiau nei komponentų
    ansambliu).
\end{itemize}

Scala komponentinio modelio trūkumai:
\begin{itemize}
  \item nėra komponentų, kaip paketų, valdymo mechanizmo (šitai galima
    apeiti pasinaudojant versijų kontrolės sistemų galimybėmis,
    pavyzdžiui, \verb|git submodule|);
  \item komponentų kiekis turi būti žinomas projektavimo metu, todėl
    Scala komponentinis modelis nėra tinkamas, pavyzdžiui,
    grafinės sąsajos elementų bibliotekos \en{GUI widgets toolkit}
    kūrimui. (Kadangi komponentai yra „užregistruojami“
    kompiliavimo metu, tai nėra, kaip pridėti trečiųjų šalių
    komponento realizacijos.)
\end{itemize}

\section{Pavyzdys: Scala komponentinis prieš Java objektinį}

e6 analizė. Cake pattern taikymas: turime ComponentA ir ComponentB,
juos sujungę į System gauname sistemą sudarytą iš dviejų komponentų.
Norėdami realizuoti analogišką sistemą su Java, turime du variantus:
\begin{enumerate}
  \item visą kodą sudėti į System, bet tada bus neįmanomas kodo
    perpanaudojimas, taip pat bus sudėtingesnis sistemos kūrimo
    darbų paskirstymas keliems programuotojams;
  \item \label{scala:exmp:enum:2} paveldėjimą pakeisti į delegavimą,
    tuo pačiu sukuriant Container, kuris pasirūpintų dalių
    sujungimu. Šiuo atveju vėl gauname kažką panašaus į
    komponentinį.
\end{enumerate}

Šis pavyzdys iliustruoja teiginį, kad komponentinis programavimas yra
susijęs ne su realizacine technologija (programavimo kalba), o su
jos naudojimo būdu, kuris užtikrina:
\begin{enumerate}
  \item galimybę dalis kurti atskirai, nepriklausomai viena nuo kitos;
  \item galimybę lengvai dalį pakeisti kita jos realizacija.
\end{enumerate}

\chapter{Scala}

\section{Tikslas}

Išsiaiškinti, kaip galima būtų padidinti verslo palaikymo sistemų, kurtų
naudojant klasikines objektines programavimo kalbas, modifikuojamumą.

Sistemos modifikuojamumas suprantamas, kaip galimybė vystyti sistemą
evoliuciniu būdu: sistemą papildyti naujomis funkcijomis neliečiant
senųjų. Priešprieša evoliuciniam sistemos vystymo būdui būtų
revoliucinis: norint pridėti naują funkciją, reikia keisti jau
esamas.

Šiame darbe laikoma, kad klasikinė objektinė programavimo kalba
yra statinė klasinė objektinė programavimo kalba. Kaip pagrindinis
pavyzdys yra nagrinėjama Java.

\section{Uždaviniai}

\begin{enumerate}
  \item Išsiaiškinti, kuo klasikinį objektinį papildė Scala
    kūrėjai ir kokias papildomas galimybes suteikia pridėtosios
    savybės.
  \item Išskirti kokias savybes pridedant klasikiniam objektiniam
    galima padidinti jo modifikuojamumą.
  \item Išsiaiškinti, kaip reikėtų programuoti tam, kad pasinaudoti
    papildomų savybių suteikiamomis galimybėmis.
\end{enumerate}

\section{Scala išskirtinės savybės}

Straipsnyje \cite{scalable-component-abstractions} Martin Odersky
ir Matthias Zenger išskyrė tris savybes įgalinančias kurti
įvairaus dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai \en{abstract type members};
  \item atviros rekursijos anotacija \en{selftype annotations, open
    recursion};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}

Ką jie turi omeny sakydami įvairaus dydžio komponentus matosi
iš tokio pavyzdžio.
TODO: Pavyzdys, kaip galima perdengti nested klasę.

\subsection{Kodo dubliavimo vengimas}

Programuojant objektinėmis kalbomis, kurios neturi multipaveldėjimo
yra susiduriama su problema, jog kai kuriais atvejais yra sudėtinga
išvengti kodo dubliavimo. Panagrinėsime du pavyzdžius.

\subsubsection{Trečiųjų šalių bibliotekos kodo modifikavimas}

TODO: Pavyzdys, kaip pasinaudojant Scala savybės \en{trait} konstrukcija
galima išvengti kodo dubliavimo taisant trečiųjų šalių biblioteką.

\subsubsection{Kraunamų savybių dizaino šablonas}

\en{Stackable trait design pattern}\cite[267p.]{programming-in-scala}.

TODO: (e1)

\section{Scala komponentinis modelis}

Straipsnyje \cite{scalable-component-abstractions} Martin Odersky
ir Matthias Zenger išskyrė tris programavimo kalbos elementus
įgalinančius kurti įvairaus dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai \en{abstract type members};
  \item atviros rekursijos anotacija \en{selftype annotations, open
    recursion};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}
Visi šie elementai yra realizuoti
Scala\footnote{\url{http://www.scala-lang.org}} programavimo kalboje.

Scala, vietoj klasinėms objektinėms programavimo kalboms įprastos
sąsajos \en{interface} konstrukcijos, turi savybės \en{trait}
konstrukciją. Pagrindinis savybės ir sąsajos skirtumas yra tai, kad
savybė gali turėti konkrečias metodų realizacijas. Taigi Scala
savybė labiau primena abstrakčią klasę, tik skirtingai nuo klasės,
Scala savybių konstruktoriai neturi parametrų. Savybės konstrukcija
leidžia pasinaudoti multi paveldėjimo suteikiamais kodo perpanaudojimo
privalumais (į klasę galima sukomponuoti kelias savybes), bet tuo
pačiu, dėl to, kad kompiliavimo metu paveldėjimo grafas yra
ištiesinamas, neturi taip vadinamos rombo problemos.

Pasinaudojant Scala savybės konstrukcija su Scala galima programuoti
komponentiškai:
\begin{itemize}
  \item komponentas realizuojamas pasinaudojant Scala klasės arba
    savybės konstrukcija;
  \item komponentas savo poreikius nurodo per abstrakčius metodus;
  \item komponentas savo teikiamus servisus nurodo per savo konkrečius
    metodus;
  \item komponentai yra surišami kompiliavimo metu;
  \item komponentų kompozicijos rezultatas yra naujas komponentas
    (Scala klasė).
\end{itemize}
Kadangi komponentų kompozicijos rezultatas yra nauja klasė, tai yra
komponentas, tai ją galima toliau jungti su kitais komponentais.
Kitaip tariant Scala komponentinis modelis palaiko vertikalų
jungimą
\en{vertical binding}\cite[598p.]{classification-framework-for-scm}.
Tiesa, jis nėra visiškai pilnas, nes negalima sukomponuoti dviejų
kompozicijos rezultatų (klasių) į naują komponentą.

FIXME: Ši savybė yra objektinio, o ne komponentinio.
Klasių hierarchijos pakeitimas į savybių hierarchiją turi privalumą,
kad kompozicijos metu galima „įlįsti“ į savybių hierarchijos vidų ir ten
atlikti modifikacijas, ko negalima padaryti su klasių hierarchija,
nes pastarosios ištiesinimas turi tenkinti savybę: „klasės hierarchijos
ištiesinimas visada turi tiesioginės tėvinės klasės hierarchijos
ištiesinimą, kaip galūnę“\cite[57p.]{scala-reference}. Toks sprendimas
priimtas todėl, kad galima būtų naudoti jau sukompiliuotas klases
naujame kode.

\begin{exmp}
  Pakeisdami klasių hierarchiją į savybių hierarchiją padidiname
  sistemos modifikuojamumą, nes iš savybių rinkinio kurdami naują
  klasę skirtingai nei klasių paveldėjimo atveju, galime įterpti
  naują savybę į norimą vietą. Tai iliustruoja toks kodo fragmentas:

  \inputscala{e1/Demo}

  Jį įvykdžius į standartinę išvestį bus atspausdinta:

  \begin{textcode}
    List(C1, T4, T3, T2, T1)
    List(C2, T4, T3, M3, T2, T1)
  \end{textcode}

\end{exmp}

Be trijų aukščiau išvardintų savybių Scala kūrėjai, kaip vieną iš
itin svarbių programavimo kalbos savybių reikalingų komponentų kūrimui
išskiria įdėtines klases. Jie jos neįtraukė tarp tų trijų
savybių vien todėl, kad dauguma pagrindinių programavimo kalbų
šią savybę turi\cite[12p.]{scalable-component-abstractions}.
Galimybė naudoti įdėtines klases yra svarbi tuo, kad jos gali pasiekti
tėvinės klasės atributus be jokio papildomo surišimo tuo pačiu
išvengiant klasės vardų srities užteršimo problemos. (Jei bandytume
apsieiti be įdėtinių klasių, tai greičiausiai būtume priversti
rašyti ilgesnius metodų pavadinimus, pavyzdžiui, „loggerAppend“,
„SyntaxTreeAppend“.) Scala, skirtingai nei Java, vidinės
\en{inner} klasės yra susietos ne su supančia klase, bet su supančiu
objektu, todėl skirtingiems objektams priklausančių vidinių
klasių maišyti negalima.

Trait yra tai, ką galime sukomponuoti į klasę. Klasės komponavimo
metu mes nusprendžiame iš kokių savybių mes norime ją sudaryti.
Po sukomponavimo mes gauname standartinę Java klasę, kurią
toliau galime plėsti per numatytus plėtimo taškus. Trait naudojimas
leidžia pasinaudoti multipaveldėjimo teikiama nauda, bet apsaugo
nuo situacijos, kai bandoma sujungti dvi „nesuderinamas“ klases
(TODO: C++ pavyzdys su dviem nesuderinamomis klasėmis), nes
trait neturi konstruktoriaus ir jei jo nėra bandoma emuliuoti,
tai traitų būsena yra suderinama klasės sukomponavimo metu. Šis
modelis yra lengvai plečiamas, nes jei klasė traitams kitus traitus
perduoda pasinaudodama def konstrukcija, tai tada ją galime perdengti
išvestinėje klasėje.

Sukomponuotos klasės jau nebegalima keisti. (Lįsti į jos vidų. Ją galima
tik „anotuoti“.) Klases visur galima keisti į savybes. Klasės reikalingos
tik tada, kai mums reikia sukonstruoti naują objektą. Šis dizainas
lemia, kad egzistuoja tik viena vieta, kur yra sukonstruojamas objektas.

Taip pat šis komponentinis modelis palaiko vertikalų jungimą
\en{vertical binding}\cite[598p.]{classification-framework-for-scm}.
TODO: Įrodyti formaliai. Neformalus įrodymas: Scala palaiko vertikalų
jungimą, nes savybes sukomponavus į klasę, mes toliau galime tą
klasę komponuoti su naujomis savybėmis ir gauti naujas klases.
Visgi Scala vertikalus jungimas nėra visiškai pilnas, nes negalima
sukomponuoti dviejų ansamblių (klasių) į naują ansamblį.

Clemens Szyperski apibrėždamas
komponentą\cite{cs-beyond-object-oriented-programming} nurodė, kad tai
yra diegimo vienetas \en{unit of deployment}. Taip pat paaiškindamas
savo apibrėžimą, jis nurodė, kad komponentai būtinai turi būti
gaunami jau sukompiliuoti. Kadangi Scala komponentai jungiami
pasinaudojant kompiliatoriumi, tai Scala komponentinis modelis
šio reikalavimo netenkina, bet Szyperski aiškinimas buvo kritikuojamas
(TODO: kieno), kadangi jokio skirtumo ar komponentus gauname
jau sukompiliuotus, ar ne, jei jų įdiegimu sugeba pasirūpinti
automatinė diegimo sistema. Su Scala šioje vietoje galima išsisukti
pasinaudodami versijų kontrolės sistemų teikiamomis galimybėmis.
Pavyzdžiui, \verb|git submodule|.
TODO: Scala kompiliatorius, kaip mano programos dalis pasinaudojant git
submodule galimybėmis. (Idėja: Ar pavyktų realizuoti Scala doctest?)

Scala naudoja vidines klases tam, kad sumažintų komponentų
sąsajas.\cite[13]{scalable-component-abstractions}
(Visada išreikštinai nurodant ko reikia komponentui, jo sąsajos
deklaracija užgožtų jo realizaciją.) Iš principo, turėtų būti
siekiama pusiausvyros tarp sąsajų dydžio ir išskaidymo į komponentus.

\emph{Pamoka iš e5} Dėl statinės prigimties Scala komponentinis
modelis nėra tinkamas kurti ne iš fiksuoto komponentų skaičiaus
sudarytas sistemas, pavyzdžiui, grafinės sąsajos elementų bibliotekas
\en{GUI widgets toolkit}. (Esmė, kad nėra kaip „įdėti“ trečiųjų šalių
komponento realizacijos, kadangi komponentai yra „užregistruojami“
kompiliavimo metu.) Cake pattern geriausiai veikia, kai
yra palyginti mažas galutinių tipų variantų skaičius, nes norint
pakeisti vieną komponentą kitu, reikia visuose galutiniuose tipuose
atlikti pakeitimus.
