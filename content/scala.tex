\chapter{Scala}

Šiame skyriuje pristatyta programavimo kalba \plangname{Scala}:
nurodyta kuo ji skiriasi nuo \plangname{Java}, aprašytas
ir išanalizuotas \plangname{Scala} komponentinis modelis,
išanalizuoti \plangname{Scala} privalumai lyginant su \plangname{Java}.

\section{\plangname{Scala} ir \plangname{Java} skirtumai}

\plangname{Scala} kūrėjų \cite[1]{scala-overview} teigimu bent iš
dalies komponentinių technologijų evoliucijai trukdo programavimo
kalbų, kurios yra naudojamos komponentų kūrimui ir jų jungimui,
trūkumai. Dėl šios priežasties jie pabandė sukurti programavimo
kalbą, su kuria naudojant tas pačias priemones galima būtų aprašyti
tiek mažas tiek dideles dalis\footnote{\plangname{Scala} išsišifruoja,
kaip \emph{scalable language}.}. \plangname{Scala} yra multiparadigminė
programavimo kalba, derinanti objektinio ir funkcinio programavimo
savybes:
\begin{itemize}
  \item ji yra objektinė kalba ta prasme, kad kiekviena reikšmė
    \en{value} yra objektas ir kiekviena operacija yra metodo kvietimas
    \cite[3]{scala-overview};
  \item ji yra funkcinė kalba ta prasme, kad kiekviena funkcija yra
    reikšmė \en{value}.
\end{itemize}
Toliau yra pristatoma kuo \plangname{Scala} pakeitė statinį, klasinį
objektinį programavimą, kuriam „atstovauja“ \plangname{Java}.
\plangname{Scala}, kaip funkcinės kalbos savybės šiame darbe nėra
nagrinėjamos.

\plangname{Scala} autoriai \cite{scalable-component-abstractions}
išskyrė tris programavimo kalbos elementus įgalinančius kurti įvairaus
dydžio \en{scalable} komponentus:
\begin{itemize}
  \item abstraktūs tipai – nariai \en{abstract type members};
  \item savo tipo anotavimas \en{selftype annotations};
  \item modulinė maišos kompozicija \en{modular mixin composition}.
\end{itemize}

\plangname{Scala}, be parametrizuojamųjų tipų \en{generics}, kuriuos
turi \plangname{Java}, turi dar vieną abstrakcijos mechanizmą:
\plangname{Scala} klasės gali turėti narius \en{member}, kurie
yra abstraktūs tipai. Abu mechanizmai yra pakeičiami vienas kitu:
\cite[10]{scala-overview} pateiktas pavyzdys, kaip parametrizuojamuosius
tipus galima būtų modeliuoti pasinaudojant abstrakčiais tipais, taip
pat nurodoma, kad yra įmanomas ir atvirkštinis variantas.
\plangname{Scala} kūrėjų \cite[11]{scala-overview} nurodytos
priežastys kalboje realizuoti abu mechanizmus yra skirtingi jų
panaudojimo atvejai: parametrizuojamus tipus yra siūloma naudoti kai
norime tiesiog galimybės klasės naudotojui nurodyti konkretų tipą
(tipinis pavyzdys būtų kolekcijos, \ref{lst:scala:abstract:members:4}
kodo fragmentas), o abstrakčius tipus tada, kai norime kliento kode
pasinaudoti abstrakčiu tipu. Pastaroji galimybė yra dažniausiai
naudojama su kita \plangname{Scala} „naujove“\footnote{
Visi trys programavimo kalbos elementai, kurie \plangname{Scala}
kūrėjų teigimu yra reikalingi komponentų kūrimui, (abstraktūs
tipai – nariai, savo tipo anotavimas ir modulinė maišos kompozicija)
egzistavo dar iki \plangname{Scala} sukūrimo, bet \plangname{Scala}
yra pirmoji programavimo kalba, kurioje realizuoti jie visi
\cite[2]{scalable-component-abstractions}.} – moduline maišos
kompozicija.

\begin{listing}[h]
  \begin{scalacode}
    import scala.collection.mutable.LinkedList
    val list = new LinkedList[String]
  \end{scalacode}
  \caption{Parametrizuotų tipų panaudojimo atvejis.}
  \label{lst:scala:abstract:members:4}
\end{listing}

Modulinė maišos kompozicija, tai klasių kūrimo mechanizmas
pasinaudojant fragmentų \en{trait} komponavimu. Fragmentą galimą
būtų apibrėžti kaip sąsają, kurios metodai gali turėti
realizacijas. Šiuo požiūriu fragmentai primena abstrakčias klases,
tik skirtingai nuo jų, fragmentų konstruktoriai negali turėti
parametrų. Fragmento konstrukcija leidžia pasinaudoti
multipaveldėjimo suteikiamais kodo perpanaudojimo privalumais
(klasę galima sukomponuoti iš kelių fragmentų), bet tuo pačiu, dėl
to, kad kompiliavimo metu paveldėjimo grafas yra ištiesinamas, neturi
taip vadinamos rombo problemos.

Klasių hierarchijos pakeitimas į fragmentų hierarchiją, net ir
nesinaudojant komponentinio galimybėmis, turi privalumą, kad
gauta sistema yra lengviau modifikuojama. Komponuojant klasę iš
fragmentų yra įmanoma „įlįsti“ į fragmentų hierarchijos vidų
ir ten atlikti pakeitimus, ko negalima padaryti su klasių hierarchija,
nes pastarosios ištiesinimas turi tenkinti savybę: „klasės hierarchijos
ištiesinimas visada turi tiesioginės tėvinės klasės hierarchijos
ištiesinimą, kaip galūnę“\cite[57p.]{scala-reference}. Galimybė,
atlikti pakeitimus viduje hierarchijos medžio, iliustruota programa,
pateikta \ref{lst:scala:mixin:1} kodo fragmente. Jos išvestis pateikta
\ref{lst:scala:mixin:2} fragmente. Šiame pavyzdyje klasė \scala{C2}
yra sukomponuojama iš fragmentų \scala{M3} ir \scala{T4} pritaikant
maišos kompoziciją.

\begin{listing}[H]
  \inputscala{e1/Demo}
  \caption{Fragmentų hierarchijos modifikavimas.}
  \label{lst:scala:mixin:1}
\end{listing}

\begin{listing}[H]
  \begin{textcode}
    List(C1, T4, T3, T2, T1)
    List(C2, T4, T3, M3, T2, T1)
  \end{textcode}
  \caption{\ref{lst:scala:mixin:1} kodo fragmente pateiktos programos
  išvestis.}
  \label{lst:scala:mixin:2}
\end{listing}

Turbūt svarbiausia maišos kompozicijos savybė yra ta, kad konkretus
narys visada užkloja abstraktų
\cite[6]{scalable-component-abstractions}. Ši savybė leidžia
sujungti du fragmentus, kurių nesieja bendra hierarchija. Tai yra
iliustruota programoje, pateiktoje \ref{lst:scala:mixin:3} kodo
fragmente. Jos išvestis yra pateikta \ref{lst:scala:mixin:4}
fragmente. Fragmento \scala{CachedCalculation} nariai
\scala{KeyType}, \scala{ValueType} ir \scala{calculate} yra abstraktūs
ir jie yra užklojami atitinkamų narių apibrėžtų fragmente
\scala{Factorial}. Fragmente \scala{Factorial} taip pat yra
abstraktus metodas \scala{lookup}, kurį užkloja konkretus metodas
\scala{lookup}, apibrėžtas \scala{CachedCalculation}.

\begin{listing}[H]
  \inputscala{e10/Demo}
  \caption{Maišos kompozicijos pavyzdys.}
  \label{lst:scala:mixin:3}
\end{listing}

\begin{listing}[H]
  \begin{textcode}
    Calculating 3
    Calculating 2
    Calculating 1
    3! = 6
    Calculating 5
    Calculating 4
    5! = 120
  \end{textcode}
  \caption{\ref{lst:scala:mixin:3} kodo fragmente pateiktos programos
  išvestis.}
  \label{lst:scala:mixin:4}
\end{listing}

Taikant maišos kompoziciją kartais prireikia, kad
\scala{this}\footnote{this yra specialus kintamasis rodantis į
objektą, kurio metodas dabar vykdomas.} tipas būtų ne tas fragmentas,
kurio metodas šiuo metu yra vykdomas, o kažkoks kitas, išvestinis
iš šio. Tai galima realizuoti vykdymo metu keičiant \scala{this}
tipą į norimą arba pasinaudojant \plangname{Scala} savojo tipo
anotacija. Pastarasis būdas turi privalumą, kad klaidos būtų randamos
kompiliavimo metu. Savojo tipo anotacijos panaudojimo pavyzdys pateiktas
\ref{lst:scala:selftype:1} kodo fragmente, o programos išvestis
– \ref{lst:scala:selftype:2}. Šiame pavyzdyje savojo tipo anotacija
yra \scala{this: Node =>} – su ja nurodoma, kad \scala{BaseNode}
viduje \scala{this} tipas yra \scala{Node}. Todėl kvietimas
\scala{show(this)} tampa galimas.

\begin{listing}[H]
  \inputscala{e11/Demo}
  \caption{Savojo tipo anotacijos panaudojimo pavyzdys.}
  \label{lst:scala:selftype:1}
\end{listing}

\begin{listing}[H]
  \begin{textcode}
    Root
    First child
    Second child
  \end{textcode}
  \caption{\ref{lst:scala:selftype:1} kodo fragmente pateiktos programos
  išvestis.}
  \label{lst:scala:selftype:2}
\end{listing}

Be savojo tipo anotacijos \ref{lst:scala:selftype:1} pavyzdyje buvo
panaudotas dar vienas svarbus programavimo kalbos elementas – vidinė
klasė (ir fragmentas). \cite[12]{scalable-component-abstractions}
nurodo, kad jie šio elemento neįtraukė tarp būtinų komponetiniam
programavimui, vien todėl, kad vidines klases palaiko pagrindinės
\en{mainstream} programavimo kalbos. Turbūt esminis skirtumas tarp
\plangname{Java} ir \plangname{Scala} vidinių klasių yra tai, kad
\plangname{Java} vidinės klasės tipas yra susietas su išorine klase,
o \plangname{Scala} su išoriniu objektu. \ref{lst:scala:selftype:1}
kodo fragmente pateiktame pavyzdyje kintamojo \scala{root} tipas
yra \scala{tree.SimpleNode}, kai \plangname{Java} jis būtų
\scala{Tree.SimpleNode}. Ši savybė yra naudinga, pavyzdžiui, tuo, kad 
leidžia statiniais metodais užtikrinti, kad skirtingų abstrakčios
gamyklos \en{abstract factory} realizacijų objektai nebūtų maišomi
tarpusavyje \cite[36]{scala-design-patterns}. Prireikus šią savybę
galima apeiti pasinaudojant tipų projekcija \en{type projection},
tai yra išreikštinai nurodant, kad vidinės klasės objekto tipas
turi priklausyti nuo išorinės klasės. \ref{lst:scala:selftype:1}
kodo fragmente nurodyta, kad kintamojo \scala{node} tipas yra
bet kokio \scala{Tree} tipo objekto \scala{SimpleNode} tipo objektas.

\section{Scala komponentinis modelis}

\cite[37]{heineman2001component} komponentinį modelį apibrėžė kaip
standartų rinkinį. (Žr.: \ref{section:component:model} skyrelį.)
Remiantis juo aprašytas \plangname{Scala} komponentinis modelis
pateiktas lentelėje (detalius aprašymus ką turėtų apibrėžti
kiekvienas iš standartų galima rasti
\cite[38-44]{heineman2001component}):

\xtable{
  w [ 2 | 5 ]
  a [ p | p ]
  h [ Standartas | Realizacija ]
  %
  e [
    realizacija |
    Komponentas gali būti realizuojamas, kaip @plangname{Scala} klasė
    arba kaip fragmentas.
    ]
  e [
    sąsajos |
    Komponentas servisus, kurių jam reikia, nurodo kaip abstrakčius
    narius, o kuriuos jis realizuoja – kaip konkrečius.
    ]
  e [
    įvardinimas |
    Komponentams globalūs vardai yra priskiriami taip pat, kaip ir
    @plangname{Java} klasėms – pagal hierarchines vardų sritis.
    ]
  e [
    meta duomenys |
    Nėra.
    ]
  e [
    tarpusavio sąveika |
    Kadangi komponentų egzemplioriai @en{component instances} yra
    objektai, tai jie sąveikauja keisdamiesi žinutėmis.
    ]
  e [
    pritaikymas |
    Komponentą pritaikyti konkrečiam atvejui galima jam pateikiant
    kitokias jo abstrakčių narių realizacijas (pavyzdžiui, kitą
    konkretų tipą). Taip pat komponento egzemplioriaus sukūrimo
    metu jį galima pritaikyti pasinaudojant konstruktoriaus parametrais
    bei parametrizuojamais tipais.
    ]
  e [
    kompozicija |
    Komponentai yra surišami kompiliavimo metu. Abstraktūs nariai
    su jų realizacijomis yra sujungiami pagal sutampančią
    @FIXME{Veicekausko vertimas: signatūrą}. Kompozicijos rezultatas
    yra naujas komponentas, kuris gali būti toliau komponuojamas.
    ]
  e [
    evoliucijos palaikymas |
    Kadangi komponentai yra surišami kompiliavimo metu, tai norint
    pakeisti vieną komponentą kitu reikia perkompiliuoti sistemą.
    Taip pat nėra galimybės turėti dvi to paties komponento versijas
    vienoje sistemoje.
    ]
  e [
    supakavimas ir įdiegimas |
    Nėra.
    ]
}

Pagal \cite[40]{heineman2001component} meta duomenys, tai yra
informacija apie sąsajas, komponentus ir jų ryšius. Ji leidžia
dinamiškai sujungti komponentus, taip pat ir nutolusius. Kadangi
\plangname{Scala} komponentai yra sujungiami statiškai kompiliavimo
metu, tai ši informacija nėra reikalinga.

Viena iš esminių komponento savybių yra tai, kad jis yra fizinis
diegimo vienetas. Tačiau \plangname{Scala} komponentinis modelis
neapibrėžia kokiu būdu turėtų būti platinami ir įdiegiami
komponentai. Be to komponentų naudotojas tam, kad galėtų juos
sukomponuoti į sistemą, turi turėti jų išeities tekstus. Taigi
galima būtų teigti, kad \plangname{Scala} komponentinis modelis šios
apibrėžimo dalies netenkina.

Tam, kad \plangname{Scala} komponentinis modelis visiškai tenkintų
komponentinio modelio apibrėžimą, reikia apibrėžti komponentų
platinimo būdus. Kadangi programų kodas dažniausiai yra laikomas
versijų kontrolės sistemose, tai kaip vienas iš būdų platinti
\plangname{Scala} komponentus, būtų pasinaudojant jomis. Pavyzdžiui,
\progname{Git}\footnote{\url{http://git-scm.com/}} ir
\progname{Mercurial}\footnote{\url{http://mercurial.selenic.com/}} palaiko
įdėtines saugyklas, taigi komponentų, iš kurių sudaryta sistema,
versijų kontrolės saugyklas galima būtų nurodyti, kaip įdėtines
kuriamos sistemos versijų kontrolės sistemai. Taigi tokiu
būdu papildžius \plangname{Scala} komponentinį modelį gautume
komponentinį modelį atitinkantį \cite[37]{heineman2001component}
pateiktą apibrėžimą.

\section{\plangname{Scala} komponentinio modelio savybės}

Šiame skyrelyje pabandyta palyginti \plangname{Scala} komponentinį
modelį su kitais komponentiniais modeliais, remiantis
\cite{classification-framework-for-scm} klasifikacija. Klasifikacijos
autoriai išskyrė tokias komponentinių modelių klasifikavimo dimensijas:
\begin{description}
  \item[gyvavimo ciklas] – kiek komponentinis modelis paremia kiekvieną
    iš komponento gyvavimo ciklo stadijų;
  \item[konstravimas] – kokiu būdu yra sukonstruojama sistema iš
    komponentų;
  \item[ekstra-funkcinės savybės] – ką komponentinis modelis siūlo
    ekstra-funkcinių savybių specifikavimui, valdymui ir kompozicijai.
\end{description}

\cite[596]{classification-framework-for-scm} gyvavimo ciklą suskirstė į
keturias stadijas. Komentarai, kaip \plangname{Scala} komponentinis
modelis palaiko kiekvieną iš jų, pateikti lentelėje:
\xtable{
  w [ 2 | 5 ]
  a [ p | p ]
  h [ Stadija | Jos palaikymas ]
  %
  e [
    modeliavimas |
    Specialių metodų ar įrankių nėra. Iš dalies (be konstrukcijų
    perimtų iš funkcinių programavimo kalbų) galima modeliuoti
    pasinaudojant @progname{UML} (Unified Modeling Language), ją
    papildžius tokiomis konstrukcijomis kaip fragmentas ir
    modulinė maišos kompozicija. Galima realizacija pateikiama
    @cite&L145&R{rachimow2009scala}.
    ]
  e [
    realizacija |
    Galima teigti, kad @plangname{Scala} komponentinis modelis yra
    labiausiai orientuotas į šią komponento gyvavimo ciklo dalį.
    Komponentų realizavimui jis pateikia ne tik taisykles, bet
    ir kalbos konstrukcijas. (Skirtingai, pavyzdžiui, nuo @progname{EJB} ar
    @progname{OSGi}, kurie tik apriboja programavimo su @plangname{Java}
    būdus.) Taip pat, kitaip nei kai kurių kitų komponentinių modelių,
    @plangname{Scala} komponentinio modelio atveju, šios stadijos
    rezultatas yra komponento išeities tekstai, o ne sukompiliuotas
    komponentas.
    ]
  e [
    pakavimas |
    Šios stadijos @plangname{Scala} komponentinis modelis nepalaiko.
    ]
  e [
    įdiegimas |
    Komponentai yra surišami kompiliavimo metu.
    ]
}

\cite{classification-framework-for-scm} konstravimo dimensiją suskirstė
į tris dalis:
\begin{enumerate}
  \item sąsajų specifikavimas – komponentų sujungimo taškų nurodymas;
  \item surišimas – ryšių tarp komponentų sukūrimas;
  \item sąveika – komponentų tarpusavio komunikacija.
\end{enumerate}

Nagrinėjant \plangname{Scala} komponentinio modelio sąsajų
specifikaciją pagal \cite[599]{classification-framework-for-scm}
pateiktus kriterijus galima būtų išskirti:
\begin{enumerate}
  \item sąsajos yra paremtos operacijomis (o ne prievadais);
  \item yra aiškiai atskiriamos reikalaujamos \en{required interface}
    ir teikiamos sąsajos \en{provided interface};
  \item sąsajos yra aprašomos \plangname{Scala} programavimo kalba;
  \item sąsajų suderinamumas yra tikrinamas tik sintaksiniu
    požiūriu.
\end{enumerate}
Nagrinėjant surišimo mechanizmus galima būtų išskirti:
\begin{enumerate}
  \item komponentus galima sujungti tik tiesiogiai, tai yra sujungimai
    \en{connectors}, kaip atskiri elementai nėra išskiriami;
  \item kadangi kompozicijos rezultatas yra komponentas, tai
    galime teigti, kad \plangname{Scala} palaiko pilną vertikalią
    kompoziciją: delegavimo tipo jungimą (ansamblio prašomos /
    teikiamos sąsajos sujungiamos su vidinių jo komponentų
    prašomomis / teikiamomis sąsajomis), agregavimo jungimą
    (visos vidinių komponentų sąsajos yra pasiekiamos per ansamblio
    sąsajas) ir naujojo komponento ekstra-funkcinės savybės
    tenkina komponentinio modelio reikalavimus, kadangi visi
    \plangname{Scala} fragmentai ir klasės gali būti naudojami,
    kaip komponentai.
\end{enumerate}
Nagrinėjant komponentų sąveiką galima būtų išskirti:
\begin{enumerate}
  \item sąveikos stilius tarp komponentų yra užklausa-atsakymas
    \en{request-response};
  \item kadangi komunikacija tarp komponentų vyksta kviečiant metodus,
    tai ji yra sinchroninio tipo.
\end{enumerate}

\cite[602]{classification-framework-for-scm} išskyrė tokius
aspektus, pagal kuriuos galima nagrinėti kaip komponentinis
modelis palaiko ekstra-funkcines savybes \en{extra-functional
properties}:
\begin{enumerate}
  \item ekstra-funkcinių savybių valdymas;
  \item ekstra-funkcinių savybių specifikavimas;
  \item ekstra-funkcinių savybių komponavimas.
\end{enumerate}
\plangname{Scala} komponentinis modelis nei vieno iš šių aspektų
išreikštinai nepalaiko.

Apibendrinant galima būtų paminėti, kad \plangname{Scala} komponentinis
modelis iš kitų modelių, nagrinėtų
\cite{classification-framework-for-scm}, išsiskiria tuo, kad
pilnai palaiko vertikalią kompoziciją. Iš to atsiranda privalumų
ir trūkumų. Kadangi komponentai, iš kurių yra surinktas ansamblis
yra paslepiami jo viduje, tai toks modelis labiau tinkamas realaus
pasaulio modeliavimui, nei modelis palaikantis tik horizontalų jungimą.
Pavyzdžiui, modeliuojant su \plangname{Scala} komponentas variklis po
kompozicijos būtų paslėptas komponente automobilis ir galima būtų
naudotis automobiliu nieko nežinant apie jo variklį. Tuo tarpu
modeliuojant su komponentiniu modeliu, kuris palaiko tik horizontalų
jungimą, komponentai variklis ir automobilis būtų atskirai, todėl
kiekvieną kartą kažką darant su automobiliu, reikėtų nepamiršti
ir jo variklio. Kitaip tariant \plangname{Scala} komponentais, kurie
yra ansambliai, yra žymiai paprasčiau naudotis, nei kitų modelių
ansambliais, kurie yra tiesiog komponentų rinkiniai. Ši savybė taip
pat turi ir trūkumą: kadangi komponentai yra paslepiami viduje, tai
norint juos pakeisti gali reikėti išardyti ansamblį.

\FIXME{Reikėtų paminėti, kad komponentai gali būti vidiniai
\en{nested}, todėl ir gaunasi, kad jie iš išorės nematomi, kai juos
gaubiantys komponentai, kurie turi metodus jų kūrimui, yra matomi.}

Taigi galima teigti, kad \plangname{Scala} kūrėjams pavyko sukurti
komponentinį modelį, kuris leistų taip pat lengvai dirbti ir
su labai mažais komponentais (iki kelių dešimčių eilučių) ir su
dideliais (visa sistema, ar posistemė, pavyzdžiui \plangname{Scala}
kompiliatorius).

\section{Scala komponentinis prieš Java objektinį}

TODO: Paprastas objektinis, ar objektinis su dizaino šablonais? Jei su
dizaino šablonais, tai pranašumo nebus, nes jie ir yra tam, kad
leistų užtikrinti modifikuojamumą ir perpanaudojamumą užtikrindami
SOLID. Turbūt netgi išeitų parodyti, kad sistemą, kurioje yra
tenkinamas SOLID, galima lengvai išskaidyti į komponentus.
Kitaip tariant vienintelis \plangname{Scala} pranašumas prieš
\plangname{Java} būtų tai, kad ji komponentinio konstrukcijas
palaiko ne programavimo disciplina, o kalbos priemonėmis.
