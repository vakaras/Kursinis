\Chapter{Komponentinis programavimas}

\label{chapter:component}

Šiame skyriuje yra surinkti įvairių autorių pateikiami komponento
apibrėžimai, pateikiamas komponento savybių sąrašas, pristatoma kas
yra komponentinis modelis, nurodomi objektinio ir komponentinio
bei komponentinio ir paketinio skirtumai.

\section{Komponento apibrėžimai}

Nors apie programinės įrangos komponentus yra kalbama jau daugiau
nei dešimt metų, vis dar nėra vieningo apibrėžimo, kas per esybė
yra komponentas \cite{classification-framework-for-scm}. Vienas
iš senesnių ir, turbūt, dažniausiai cituojamų yra \human{Clemens Szyperski}
\cite[41]{cs-beyond-object-oriented-programming}
pateiktas komponento apibrėžimas:
\begin{quote}
  Programinės įrangos komponentas yra kompozicijos elementas su
  sutartinai apibrėžtomis sąsajomis ir tik su išreikštinai
  nurodytomis priklausomybėmis. Programinės įrangos komponentas
  gali būti naudojamas nepriklausomai bei panaudotas
  kompozicijoje trečiųjų šalių.
\end{quote}
Nors apibrėžime to išreikštinai ir nėra, tačiau kaip vieną iš
esminių komponento savybių autorius nurodo, kad komponentas yra
nepriklausomo diegimo vienetas \en{unit of deployment}
\cite[36]{cs-beyond-object-oriented-programming} ir netgi
pareikalauja, kad komponentai klientui būtų pateikiami jau
sukompiliuoti \cite{point-counterpoint}. Kitaip tariant, komponentas
yra laikomas fiziniu paketu\footnote{Fizinis paketas nuo loginio paketo
skiriasi tuo, kad fiziniam paketui turi būti įmanoma įvykdyti
operaciją „perkelti iš vieno kompiuterio į kitą“.}. Ši
komponento savybė yra išreikštinai
nurodyta \cite[385]{objects-components-and-frameworks-with-uml}
apibrėžime:
\begin{quote}
  Komponentas (kode) yra rišlus programinės įrangos realizacijos
  paketas, kuris:
  \begin{enumerate}
    \item gali būti nepriklausomai kuriamas ir pristatytas;
    \item turi išreikštines ir gerai apibrėžtas sąsajas savo teikiamiems
      servisams;
    \item turi išreikštines ir gerai apibrėžtas sąsajas servisams,
      kurių jis tikisi iš kitų;
    \item gali būti sujungtas su kitais komponentais, galbūt pritaikant
      kai kurias savybes \en{properties}, bet be pačių komponentų
      keitimo.
  \end{enumerate}
\end{quote}
bei \cite[1]{Hopkins:2000:CP:352183.352198} apibrėžime:
\begin{quote}
  Programinės įrangos komponentas yra fizinė vykdomosios programinės
  įrangos pakuotė su gerai apibrėžta ir vieša sąsaja.
\end{quote}

Su tuo, kad komponentas yra fizinis diegimo vienetas yra susiję
tai, kad jis yra uždaras
\cite[36]{cs-beyond-object-oriented-programming}. Kitaip tariant,
sistemos naudotojai į komponentą žiūri, kaip į juodą
dėžę \cite[2]{Gill:2003:CMF:966221.966237}.
Kadangi nėra galimybės pasižiūrėti kas yra komponento „viduje“,
tai norint pasinaudoti jo teikiamu funkcionalumu reikia, kad būtų
pateiktos išreikštinės sąsajos, per kurias galima prie jo
prieiti
\cites[387]{objects-components-and-frameworks-with-uml}%
[36]{cs-beyond-object-oriented-programming}. Dėl tos
pačios priežasties tam, kad galėtume komponentui leisti pasinaudoti
jam reikiamais servisais, jie irgi turi būti išreikštinai nurodyti
\cites[387]{objects-components-and-frameworks-with-uml}%
[36]{cs-beyond-object-oriented-programming}. Visos šios
savybės leidžia komponentų kūrėjams kurti komponentus nieko
nežinant apie komponentų naudotojus
\cites[2]{Gill:2003:CMF:966221.966237}%
[139]{meyer1999components}
kas lemia, kad sistema gali būti surinkta iš nepriklausomai sukurtų
komponentų. Taip pat tie patys komponentai be pakeitimų gali būti
panaudoti keliose skirtingose trečiųjų šalių sistemose
\cites[388]{objects-components-and-frameworks-with-uml}%
[36]{cs-beyond-object-oriented-programming}. Taigi
apibendrinant, galima būtų išskirti tokias komponento savybes:
\begin{enumerate}
  \item \label{com:exe:deployment} yra fizinis diegimo vienetas;
  \item \label{com:exe:blackbox} yra juoda dėžė;
  \item \label{com:exe:interfaceprovider} prie jo funkcionalumo galima
    prieiti tik per išreikštinai apibrėžtas sąsajas;
  \item \label{com:exe:interfaceuser} savo poreikius nurodo tik per
    išreikštinai apibrėžtas sąsajas;
  \item \label{com:exe:independent} gali būti kuriamas nepriklausomai;
  \item \label{com:exe:reusable} gali būti perpanaudojamas;
  \item \label{com:exe:composed} gali būti be pakeitimų sujungtas su
    kitais komponentais į vieną sistemą;
  \item \label{com:exe:interchangable} gali būti sistemoje
    pakeičiamas kitu, jei naujasis įgyvendina visą senojo
    funkcionalumą ir nereikalauja nieko daugiau.
\end{enumerate}

\section{Komponentinio modelio apibrėžimas}

\label{section:component:model}

Ankstesniame skyrelyje pateiktais komponento apibrėžimais pasakoma kas
yra komponentas, bet nėra pasakoma kaip yra kuriami komponentai ir kaip
iš jų sukomponuojama sistema. Šitai apibrėžia komponentinis
modelis. \cite[37]{heineman2001component} nurodo, kad
\begin{quote}
  Komponentinis modelis apibrėžia standartus komponentų realizacijai,
  įvardinimui, tarpusavio sąveikai, pritaikymui, kompozicijai,
  evoliucijai ir įdiegimui.
\end{quote}
Pasinaudodami komponentinio modelio apibrėžimu autoriai šiek tiek
kitaip apibrėžia ir patį komponentą \cite[7]{heineman2001component}:
\begin{quote}
  Programinės įrangos komponentas yra programinis elementas kuris
  atitinka komponentinį modelį ir gali būti nepriklausomai įdiegtas
  ir jo nekeičiant įkomponuotas laikantis komponavimo standarto.
\end{quote}

Komponentinio programavimo nagrinėjimas akcentuojant komponentinį modelį
turi privalumą, kad remiantis juo galima nagrinėti skirtingas
komponentinių sistemų kūrimo metodikas bei tuo pačiu išskirti
kiekvienos iš jų privalumus ir trūkumus.

\section{Objektinio ir komponentinio sąryšis}

Siekiant suprasti kokias naujas galimybes suteikia komponentinis
lyginant su objektiniu yra svarbu išskirti jų panašumus ir skirtumus.
Palyginus komponentinį su klasiniu objektiniu\footnote{Lyginama
būtent su klasiniu objektiniu, nes prototipinis objektinis yra
palyginti nepopuliarus, o skirtumai tarp prototipinio objektinio
ir klasinio objektinio yra nemaži. (Pavyzdžiui, prototipiniame
objektiniame nėra tokios sąvokos, kaip „sąsaja“.)}, galima rasti
tokius jų panašumus:
\begin{enumerate}
  \item tiek \gls{component-instance}{komponento egzempliorių}, tiek
    objektą jų klientai traktuoja, kaip juodą dėžę;
  \item tiek \gls{component-instance}{komponento egzempliorius}, tiek
    objektas išreikštinai nurodo teikiamus servisus.
\end{enumerate}

Nagrinėjant kuo komponentinis skiriasi nuo objektinio reikėtų
pastebėti, kad komponentas visu pirma yra fizinis darinys, kai tuo
tarpu klasė yra labiau loginis. Kitaip tariant, kai galima teigti,
kad objektinės statinės klasinės programavimo kalbos klasės ir jų
naudotojai yra realizuojami ta pačia programavimo
kalba (arba suderinamomis programavimo kalbomis, tokiomis kaip
\plangname{Scala} ir \plangname{Java}), tai to apie komponentus ir jų
naudotojus pasakyti nebegalime. Komponentai netgi gali būti realizuoti
skirtingoms paradigmoms priklausančiomis programavimo kalbomis.
Pavyzdžiui, objektine programavimo kalba realizuotas komponentas gali
naudotis funkcine kalba realizuoto komponento
funkcionalumu \cite[36]{heineman2001component}. Nepaisant to,
dėl objektinio ir komponentinio panašumų komponentus realizuoti
pasinaudojant objektine programavimo kalba yra žymiai paprasčiau,
nei, pavyzdžiui, procedūrine programavimo kalba \cite{what-to-compose}.
Be šio skirtumo dar galima būtų išskirti ir tai, kad komponentas
išreikštinai nurodo ne tik teikiamus, bet ir jam reikiamus
servisus.

\section{Komponentinių ir paketinių technologijų skirtumai}

\FIXME{Darbo vadovo komentaras: „nelietuviškai skamba. komponentinio ko?
paketinio ko? Gal tiesiog „komponento ir paketo skirtumai?“}

TODO: \human{Clemens Szyperski}
\cite{cs-beyond-object-oriented-programming} (taip pat ir
\cite[34]{heineman2001component}) teigia, kad Operacinės sitemos
yra tarp pirmųjų sėkmingų komponentinių modelių. Iš to sektų,
kad ir GNU/Linux naudojamas paketų valdymo sistemas, tokias kaip
APT\footnote{\url{http://en.wikipedia.org/wiki/Advanced_Packaging_Tool}}
ir RPM\footnote{\url{http://en.wikipedia.org/wiki/RPM_Package_Manager}}
irgi galima vadinti komponentinėmis. Teoriškai šių paketinių
sistemų paketai netenkina esminės komponento savybės – jie priklauso
nuo konkrečių kitų paketų. TODO: Ar OSGi, EJB, CORBA komponentai
nurodo konkrečius kitus komponentus ar tik abstrakčias sąsajas?
