\Chapter{Komponentinis programavimas}

\label{chapter:component}

Šiame skyriuje yra surinkti įvairių autorių pateikiami komponento
apibrėžimai, pateikiamas komponento savybių sąrašas, pristatoma kas
yra komponentinis modelis, nurodomi objektinio ir komponentinio
bei komponentinio ir paketinio skirtumai.

\section{Komponento apibrėžimai}

\label{section:component:descriptions}

Nors apie programinės įrangos komponentus yra kalbama jau daugiau
nei dešimt metų, vis dar nėra vieningo apibrėžimo, kas per esybė
yra komponentas \cite{classification-framework-for-scm}. Vienas
iš senesnių ir, turbūt, dažniausiai cituojamų yra \human{Clemens Szyperski}
\cite[41]{cs-beyond-object-oriented-programming}
pateiktas komponento apibrėžimas:
\begin{quote}
  Programinės įrangos komponentas yra kompozicijos elementas su
  sutartinai apibrėžtomis sąsajomis ir tik su išreikštinai
  nurodytomis priklausomybėmis. Programinės įrangos komponentas
  gali būti naudojamas nepriklausomai bei panaudotas
  kompozicijoje trečiųjų šalių.
\end{quote}
Nors apibrėžime to išreikštinai ir nėra, tačiau kaip vieną iš
esminių komponento savybių autorius nurodo, kad komponentas yra
nepriklausomo diegimo vienetas \en{unit of deployment}
\cite[36]{cs-beyond-object-oriented-programming} ir netgi
pareikalauja, kad komponentai klientui būtų pateikiami jau
sukompiliuoti \cite{point-counterpoint}. Kitaip tariant, komponentas
yra laikomas fiziniu paketu\footnote{Fizinis paketas nuo loginio paketo
skiriasi tuo, kad fiziniam paketui turi būti įmanoma įvykdyti
operaciją „perkelti iš vieno kompiuterio į kitą“.}. Ši
komponento savybė yra išreikštinai
nurodyta \cite[385]{objects-components-and-frameworks-with-uml}
apibrėžime:
\begin{quote}
  Komponentas (kode) yra rišlus programinės įrangos realizacijos
  paketas, kuris:
  \begin{enumerate}
    \item gali būti nepriklausomai kuriamas ir pristatytas;
    \item turi išreikštines ir gerai apibrėžtas sąsajas savo teikiamiems
      servisams;
    \item turi išreikštines ir gerai apibrėžtas sąsajas servisams,
      kurių jis tikisi iš kitų;
    \item gali būti sujungtas su kitais komponentais, galbūt pritaikant
      kai kurias savybes \en{properties}, bet be pačių komponentų
      keitimo.
  \end{enumerate}
\end{quote}
bei \cite[1]{Hopkins:2000:CP:352183.352198} apibrėžime:
\begin{quote}
  Programinės įrangos komponentas yra fizinė vykdomosios programinės
  įrangos pakuotė su gerai apibrėžta ir vieša sąsaja.
\end{quote}

Su tuo, kad komponentas yra fizinis diegimo vienetas yra susiję
tai, kad jis yra uždaras
\cite[36]{cs-beyond-object-oriented-programming}. Kitaip tariant,
sistemos naudotojai į komponentą žiūri, kaip į juodą
dėžę \cite[2]{Gill:2003:CMF:966221.966237}.
Kadangi nėra galimybės pasižiūrėti kas yra komponento „viduje“,
tai norint pasinaudoti jo teikiamu funkcionalumu reikia, kad būtų
pateiktos išreikštinės sąsajos, per kurias galima prie jo
prieiti
\cites[387]{objects-components-and-frameworks-with-uml}%
[36]{cs-beyond-object-oriented-programming}. Dėl tos
pačios priežasties tam, kad galėtume komponentui leisti pasinaudoti
jam reikiamais servisais, jie irgi turi būti išreikštinai nurodyti
\cites[387]{objects-components-and-frameworks-with-uml}%
[36]{cs-beyond-object-oriented-programming}. Visos šios
savybės leidžia komponentų kūrėjams kurti komponentus nieko
nežinant apie komponentų naudotojus
\cites[2]{Gill:2003:CMF:966221.966237}%
[139]{meyer1999components}
kas lemia, kad sistema gali būti surinkta iš nepriklausomai sukurtų
komponentų. Taip pat tie patys komponentai be pakeitimų gali būti
panaudoti keliose skirtingose trečiųjų šalių sistemose
\cites[388]{objects-components-and-frameworks-with-uml}%
[36]{cs-beyond-object-oriented-programming}. Taigi
apibendrinant, galima būtų išskirti tokias komponento savybes:
\begin{enumerate}
  \item \label{com:exe:deployment} yra fizinis diegimo vienetas;
  \item \label{com:exe:blackbox} yra juoda dėžė;
  \item \label{com:exe:interfaceprovider} prie jo funkcionalumo galima
    prieiti tik per išreikštinai apibrėžtas sąsajas;
  \item \label{com:exe:interfaceuser} savo poreikius nurodo tik per
    išreikštinai apibrėžtas sąsajas;
  \item \label{com:exe:independent} gali būti kuriamas nepriklausomai;
  \item \label{com:exe:reusable} gali būti perpanaudojamas;
  \item \label{com:exe:composed} gali būti be pakeitimų sujungtas su
    kitais komponentais į vieną sistemą;
  \item \label{com:exe:interchangable} gali būti sistemoje
    pakeičiamas kitu, jei naujasis įgyvendina visą senojo
    funkcionalumą ir nereikalauja nieko daugiau.
\end{enumerate}

\section{Objektinio ir komponentinio sąryšis}

\cite[36]{heineman2001component} nurodo, kad sąvoka \emph{komponentas}
kartais yra klaidingai vartojama, kaip sąvokos \emph{objektas}
sinonimas. Kadangi komponentas yra įdiegimo vienetas, o objektas yra
esybė egzistuojanti vykdymo metu, tai šių sąvokų net nelabai galima
lyginti. Taigi teisingiau būtų lyginti \gls{component-instance}{%
komponento egzempliorių} su objektu, bet čia susiduriame su problema,
kad vykdymo metu ne visada įmanoma nurodyti kas yra komponento
egzempliorius (pavyzdžiui, jei komponentas yra realizuotas kaip keletas
klasių). Tuo tarpu komponentas yra panašus į statinio klasinio objektinio
klasę tuo, kad jis yra statinis „planas“ komponento egzemplioriaus, kaip
kad klasė yra objekto „planas“. Be to skirtumo, kad klasė yra
labiau loginis, o komponentas – fizinis darinys, iš
\ref{section:component:descriptions} skyrelyje išvardintų savybių
klasė nepasižymi tuo, kad poreikius nurodo tik per išreikštinai
apibrėžtas sąsajas. \cite[36]{heineman2001component} pamini dar
vieną svarbią ypatybę: nors dėl panašumų komponentines sistemas ir
yra patogu modeliuoti remiantis objektinio sąvokomis, bet patys
komponentai neprivalo būti realizuoti naudojant objektines
technologijas. Apibendrinant, galima būtų teigti, kad objektinė
ir komponentinė yra dviejų skirtingų lygių technologijos: su
objektine galima realizuoti komponentus, o su komponentine – juos
sujungti į vieną sistemą.

\TODO{Taigi turime du galimus surišimo būdus: komponentų surišimas
(jei komponentai realizuoti pasinaudojant klasėmis, tai reikštų, kad
yra surišamos klasės) ir komponentų egzempliorių surišimas (jei
komponentų egzemplioriai yra objektai, tai reikštų, kad yra surišami
objektai).}

\section{Komponentinio modelio apibrėžimas}

\label{section:component:model}

Ankstesniame skyrelyje pateiktais komponento apibrėžimais pasakoma kas
yra komponentas, bet nėra pasakoma kaip yra kuriami komponentai ir kaip
iš jų sukomponuojama sistema. Šitai apibrėžia komponentinis
modelis. \cite[37]{heineman2001component} nurodo, kad
\begin{quote}
  Komponentinis modelis apibrėžia standartus komponentų realizacijai,
  įvardinimui, tarpusavio sąveikai, pritaikymui, kompozicijai,
  evoliucijai ir įdiegimui.
\end{quote}
Pasinaudodami komponentinio modelio apibrėžimu autoriai šiek tiek
kitaip apibrėžia ir patį komponentą \cite[7]{heineman2001component}:
\begin{quote}
  Programinės įrangos komponentas yra programinis elementas kuris
  atitinka komponentinį modelį ir gali būti nepriklausomai įdiegtas
  ir jo nekeičiant įkomponuotas laikantis komponavimo standarto.
\end{quote}

Komponentinio programavimo nagrinėjimas akcentuojant komponentinį modelį
turi privalumą, kad remiantis juo galima nagrinėti skirtingas
komponentinių sistemų kūrimo metodikas bei tuo pačiu išskirti
kiekvienos iš jų privalumus ir trūkumus.

\section{Komponentinių technologijų ir paketų tvarkymo sistemų skirtumai}

\cite[12]{cs-beyond-object-oriented-programming} teigimu operacinės
sistemos yra pirmosios sėkmingos komponentinės technologijos. Šiuo
atveju komponentu yra laikoma programa. Dauguma \progname{GNU/Linux}
operacinės sistemos platinamųjų paketų \en{distribution} programų
platinimui naudoja paketų tvarkymo sistemas \en{package management
system}. Kyla klausimas ar šias sistemas galime vadinti komponentinėmis,
o jų paketus – komponentais?

Viena iš populiariausių paketų tvarkymo sistemų yra
\progname{Debian}\footnote{\url{http://www.debian.org/}} paketų
tvarkymo sistema. Jos paketo savybių palyginimas su
\ref{section:component:descriptions} skyrelyje išvardintomis
komponento savybėmis:
\begin{enumerate}
  \item \emph{yra fizinis diegimo vienetas:} taip;
  \item \emph{yra juoda dėžė:} taip, nes paketo turinys yra jau
    sukompiliuotas;
  \item \emph{prie jo funkcionalumo galima prieiti tik per
    išreikštinai apibrėžtas sąsajas:} taip, kadangi paketo turinys
    yra jau sukompiliuotas, tai juo pasinaudoti galima tik per
    pateiktas sąsajas;
  \item \emph{savo poreikius nurodo tik per išreikštinai apibrėžtas
    sąsajas:} ne visada, nes \progname{Debian} paketai priklauso nuo
    kitų paketų, iš kurių kai kurie gali būti virtualūs\footnote{
    \url{http://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics\#s-virtual}};
  \item \emph{gali būti kuriamas nepriklausomai:} taip;
  \item \emph{gali būti perpanaudojamas:} taip;
  \item \emph{gali būti be pakeitimų sujungtas su kitais paketais
    į vieną sistemą:} taip;
  \item \emph{gali būti sistemoje pakeičiamas kitu, jei naujasis
    įgyvendina visą senojo funkcionalumą ir nereikalauja nieko
    daugiau:} tik tada, kai toks pakeitimas buvo numatytas iš anksto
    (tai yra buvo sukurta priklausomybė nuo virtualaus paketo).
\end{enumerate}
Kadangi \progname{Debian} paketas beveik visiškai atitinka komponento
savybes, tai \progname{Debian} paketų tvarkymo sistemą galima
būtų pavadinti komponentine technologija.

Paketų tvarkymo sistemų esminis privalumas yra tai, kad jos leidžia
pasiekti aukštą perpanaudojamumą \en{reusability}. Perpanaudojamumą,
kaip esminį komponentinio privalumą išskyrė \human{Bertrand Meyer}
\cite{what-to-compose}.
% Let's probe further what components are really about. Szyperski notes
% that components foster not just reusability but also extendibility and
% "evolvability." Quite true, but improvements in reusability improve
% these other two properties anyway.
Tuo tarpu \human{Clemens Szyperski} \cite{point-counterpoint}
teigimu esminiai komponentinio privalumai yra modifikuojamumas
\en{evolvability} ir praplečiamumas \en{extensibility}. Šiomis
savybėmis \progname{Debian} paketų tvarkymo sistema nepasižymi:
\begin{enumerate}
  \item vienus paketus pakeisti kitais galima tik ten, kur tokia galimybė
    buvo numatyta iš anksto – taigi sistema ne visada gali būti
    lengvai modifikuojama;
  \item naujų sistemos funkcijų pridėjimui dažnai trukdo tai,
    kad sistemoje gali būti įdiegta tik viena konkretaus paketo
    versija (pavyzdžiui, jei sisteminių procesų veikimui yra reikalinga
    2.6 \plangname{Python} versija, o norimai įdiegti programai – 2.7,
    tai tokiu atveju tam, kad programą susieti su 2.7 versija gali
    reikėti programą įdiegti nesinaudojant paketų tvarkymo sistema).
\end{enumerate}
Remiantis šiuo pavyzdžiu galima būtų kelti hipotezę, kad norint
pasiekti, jog sistema būtų lengvai plečiama ir modifikuojama reikia,
kad komponentai iš kurių ji yra surenkama savo poreikius nurodytų
tik per abstrakčias sąsajas. Kadangi ši hipotezė reikalauja itin
plačios analizės, tai ji toliau šiame darbe nėra nagrinėjama.

Apibendrinant galima būtų pastebėti, kad be formalaus skirtumo, jog
paketų tvarkymo sistemų paketai ne visada priklauso nuo sąsajos,
paketų tvarkymo sistemos nuo komponentinių sistemų dar skiriasi ir
tuo, kad jos akcentuoja ne paketų sukūrimą ir kompoziciją, o jų
perdavimą ir įdiegimą. Kitaip tariant, nors komponentas ir yra
diegimo vienetas, o komponentinis modelis būtinai turi nurodyti
kokiu būdu komponentai yra sujungiami į sistemą, bet komponentinis
modelis neprivalo nurodyti kokiu būdu komponentai yra perduodami
klientams, o paketų tvarkymo sistemos būtent tai ir nurodo. Kadangi
abi technologijos siekia užtikrinti galimybę surinkti sistemą
iš atskirų dalių, tai todėl ir atsiranda jų supanašėjimas.
