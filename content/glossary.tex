\chapter{Žodynėlis}

\begin{glossary}

  \begin{entry}%
    {evolutionary-software-development-process}%
    {evoliucinis programinės įrangos kūrimo procesas}%
    [evolutionary software development process]

    Procesas, kurio metu programinė įranga papildoma nauju funkcionalumu,
    neliečiant jau egzistuojančio.
    
  \end{entry}

  \begin{entry}%
    {component-oriented-software-development}%
    {komponentinis programinės įrangos kūrimas}%
    [component oriented software development]

    Programinės įrangos kūrimo būdas, kai ji yra surenkama iš atskirų,
    išreikštinai nesusijusių gabalų, kurie yra vadinami komponentais.
    
  \end{entry}

  \begin{entry}%
    {trait}%
    {fragmentas}%
    [trait]

    Programavimo kalbos \gls{scala}{Scala} konstrukcija. Scala
    fragmentai nuo Java sąsajų skiriasi tuo, kad gali turėti metodų
    realizacijas. Taigi tuo jie primena abstrakčias klases, bet nuo
    pastarųjų skiriasi tuo, kad jų konstruktoriai negali turėti
    parametrų.
  
  \end{entry}

  \begin{entry}%
    {scala}%
    {Scala}%
    []%
    [\url{http://www.scala-lang.org}]

    Multiparadigminė programavimo kalba.
    
  \end{entry}

  \begin{entry}%
    {abstract-type-member}%
    {abstraktus tipas-atributas}%
    [abstract type member]

    Abstraktūs tipai, kaip atributai yra objektiškai orientuota
    \gls{scala}{Scala} konstrukcija, kuri leidžia abstrahuotis nuo
    komponento funkcionavimui reikalingų komponentų. Plačiau
    jie aprašyti \cite[8]{scala-overview}.
    
  \end{entry}

  \begin{entry}%
    {selftype-annotation}%
    {savo tipo anotacija}%
    [selftype annotation]

    \gls{scala}{Scala} konstrukcija leidžianti specialiajam kintamajam
    \varname{this} priskirti kitą tipą.

  \end{entry}

  \begin{entry}%
    {modular-mixin-composition}%
    {modulinė maišos kompozicija}%
    [modular mixin composition]

    Komponentų jungimo būdas realizuotas programavimo kalboje
    \gls{scala}{Scala}.
    
  \end{entry}

  \begin{entry}%
    {statically-typed-programming-language}%
    {statiškai tipizuota programavimo kalba}%
    [statically typed programming language]%
    [\url{http://en.wikipedia.org/wiki/Static_typing\#Static_typing}]

    Programavimo kalba, kurioje tipų patikrinimas yra atliekamas
    kompiliavimo metu.\cite[2]{Madsen:1990:STO:97946.97964}
    
  \end{entry}

  \begin{entry}%
    {dynamically-typed-programming-language}%
    {dinamiškai tipizuota programavimo kalba}%
    [dynamically typed programming language]%
    [\url{http://en.wikipedia.org/wiki/Dynamic_typing\#Dynamic_typing}]

    Programavimo kalba, kurioje tipų patikrinimas yra atliekamas vykdymo
    metu \cite[2]{Madsen:1990:STO:97946.97964}. Kalbose, kurios naudoja
    dinaminį tipų tikrinimą, tipus turi turi reikšmės, o ne kintamieji.
    
  \end{entry}

  \begin{entry}%
    {class-based-programming-language}%
    {klasinė programavimo kalba}%
    [class based programming language]%
    [\url{http://en.wikipedia.org/wiki/Class-based_programming}]

    \gls{object-oriented-programming-language}{Objektinė programavimo
    kalba}, kurioje objektai yra apibrėžiami,
    kaip klasių egzemplioriai. \TODO{Pavedimas} yra pasiekiamas
    pasinaudojant klasių paveldėjimo konstrukciją.

  \end{entry}
    
  \begin{entry}%
    {object-oriented-programming-language}%
    {objektiškai orientuota programavimo kalba}%
    [object oriented programming language]%
    [\url{http://en.wikipedia.org/wiki/Object_oriented}]

    Programavimo kalba, su kuria galima programuoti pasinaudojant
    objekto abstrakcija bei kurioje yra realizuotas 
    \gls{object-description-sharing-mechanism}{objektų apibrėžimų
    dalinimosi mechanizmas}.
    
  \end{entry}

  \begin{entry}%
    {object-description-sharing-mechanism}%
    {objekto aprašymo dalinimosi mechanizmas}%
    [object description sharing mechanism]

    Mechanizmas leidžiantis egzistuojančių objektų apibrėžimus panaudoti
    apibrėžiant naujus objektus.
    
  \end{entry}

  \begin{entry}%
    {delegation}%
    {delegavimas}%
    [delegation]

    \gls{object-description-sharing-mechanism}{Objektų apibrėžimų
    dalinimosi mechanizmas}, kai naujas objektas yra apibrėžiamas
    pasinaudojant jau egzistuojančio objekto apibrėžimu. Šis
    mechanizmas vadinamas delegavimu, nes neradus žinutę atitinkančio
    metodo ji yra persiunčiama (deleguojama) tėviniam objektui.
    
  \end{entry}

  \begin{entry}%
    {class-inheritance}%
    {klasių paveldėjimas}%
    [class inheritance]

    \gls{object-description-sharing-mechanism}{Objektų apibrėžimų
    dalinimosi mechanizmas}, kai kiekvienas objektas yra laikomas
    kokios nors klasės egzemplioriumi (tai yra, jis apibrėžiamas
    pasinaudojant klase), o klasės gali paveldėti savybes vienos
    iš kitų.
    
  \end{entry}

  \begin{entry}%
    {strongly-typed-programming-language}%
    {stipriai tipizuota programavimo kalba}%
    [strongly typed programming language]%
    [\url{http://en.wikipedia.org/wiki/Strong_typing}]

    Tipizacijos stiprumas yra tai, kokį kiekį informacijos turi
    konkrečios išraiškos tipas. Idealiu atveju stipriai tipizuotoje
    kalboje iš nuorodos į objektą tipo visada galima pasakyti kokias
    žinutes galima siųsti tam
    objektui.\cite[1]{Madsen:1990:STO:97946.97964}
    
  \end{entry}

  \begin{entry}%
    {weakly-typed-programming-language}%
    {silpnai tipizuota programavimo kalba}%
    [weakly typed programming language]%
    [\url{http://en.wikipedia.org/wiki/Strong_typing}]

    Tipizacijos stiprumas yra tai, kokį kiekį informacijos turi
    konkrečios išraiškos tipas. Silpnai tipizuotoje kalboje neįmanoma
    nustatyti kokias žinutes galima siųsti objektui iš nuorodos į jį
    tipo.\cite[1]{Madsen:1990:STO:97946.97964}
    
  \end{entry}

  % Nesutvarkyti.

  \begin{entry}%
    {dynamic-dispatch}%
    {dinaminis susiejimas}%
    [dynamic dispatch]%
    [\url{http://en.wikipedia.org/wiki/Dynamic_dispatch}]

    Nusprendimo, kokį kodą vykdyti gavus žinutę, procesas,
    atliekamas programos vykdymo metu.

  \end{entry}

  \begin{entry}%
    {polymorphism}%
    {polimorfismas}%
    [polymorphism]%
    [%
    \url{http://en.wikipedia.org/wiki/Polymorphism_(computer_science)}, %
    \url{http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming}%
    ]%

    Programavimo kalbos savybė, kuri leidžia su skirtingų tipų duomenimis
    dirbti naudojantis ta pačia sąsaja. Išskiriami trys polimorfizmo tipai:
    \begin{itemize}
      \item \emph{Ad-hoc} polimorfizmas \en{Ad-hoc polymorphism} –
        iš esmės, tai yra funkcijų perdengimas;
      \item parametrinis polimorfizmas \en{parametric polymorphism} –
        programuojama taip, kad kodas nepriklausytų nuo duomenų tipo
        (pavyzdys būtų C++ šablonai ir Java generics);
      \item potipio polimorfizmas \en{subtype polymorphism} – 
        jei $T$ yra $S$ potipis, tai $T$ galima naudoti vietoje $S$.
    \end{itemize}
    
  \end{entry}
\end{glossary}

\begin{description}

  \item[metodo užklotis \en{method overriding}]
    Objektinės programavimo kalbos savybė, kuri leidžia paveldinčiai klasei
    realizuoti metodą, kurį jau yra realizavusi kažkuri iš jos tėvinių
    klasių. Paveldinčios klasės metodo realizacija užkloja (paslepia)
    tėvinės klasės metodą.

  \item[funkcijos perdengimas \en{function overloading}]
    Programavimo kalbos savybė, kuri leidžia aprašyti kelias funkcijas
    turinčias tą patį vardą, kurios yra atskiriamos pagal jų argumentų
    tipus.

  \item[įdėtinė klasė \en{nested class, static inner class}]
    Java kalboje, tai klasė apibrėžta kitos klasės viduje, bet
    kurios objekto sukūrimui nėra būtinas gaubiančiosios
    klasės objektas. Ji apibrėžiama su \verb|static| konstrukcija.
    Scala neturi įdėtinių klasių.

  \item[vidinė klasė \en{inner class}]
    Java kalboje, tai klasė apibrėžta kitos klasės viduje. Jos
    objekto sukūrimui yra būtinas gaubiančiosios klasės objektas.
    Scala kalboje visos klasės apibrėžtos kitų klasių viduje
    yra vidinės klasės.

\end{description}
