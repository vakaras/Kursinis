\chapter{Žodynėlis}

\begin{glossary}

  \begin{entry}%
    {evolutionary-software-development-process}%
    {evoliucinis programinės įrangos kūrimo procesas}%
    [evolutionary software development process]

    Procesas, kurio metu programinė įranga papildoma nauju funkcionalumu,
    neliečiant jau egzistuojančio.
    
  \end{entry}

  \begin{entry}%
    {component-oriented-software-development}%
    {komponentinis programinės įrangos kūrimas}%
    [component oriented software development]

    Programinės įrangos kūrimo būdas, kai ji yra surenkama iš atskirų,
    išreikštinai nesusijusių gabalų, kurie yra vadinami komponentais.
    
  \end{entry}

  \begin{entry}%
    {trait}%
    {fragmentas}%
    [trait]

    Programavimo kalbos \gls{scala}{Scala} konstrukcija. Scala
    fragmentai nuo Java sąsajų skiriasi tuo, kad gali turėti metodų
    realizacijas. Taigi tuo jie primena abstrakčias klases, bet nuo
    pastarųjų skiriasi tuo, kad jų konstruktoriai negali turėti
    parametrų.
  
  \end{entry}

  \begin{entry}%
    {scala}%
    {Scala}%
    []%
    [\url{http://www.scala-lang.org}]

    Multiparadigminė programavimo kalba.
    
  \end{entry}

  \begin{entry}%
    {abstract-type-member}%
    {abstraktus tipas-atributas}%
    [abstract type member]

    Abstraktūs tipai, kaip atributai yra objektiškai orientuota
    \gls{scala}{Scala} konstrukcija, kuri leidžia abstrahuotis nuo
    komponento funkcionavimui reikalingų komponentų. Plačiau
    jie aprašyti \cite[8]{scala-overview}.
    
  \end{entry}

  \begin{entry}%
    {selftype-annotation}%
    {savo tipo anotacija}%
    [selftype annotation]

    \gls{scala}{Scala} konstrukcija leidžianti specialiajam kintamajam
    \varname{this} priskirti kitą tipą.

  \end{entry}

  \begin{entry}%
    {modular-mixin-composition}%
    {modulinė maišos kompozicija}%
    [modular mixin composition]

    Komponentų jungimo būdas realizuotas programavimo kalboje
    \gls{scala}{Scala}.
    
  \end{entry}

  % Nesutvarkyti.

  \begin{entry}%
    {dynamic-dispatch}%
    {dinaminis susiejimas}%
    [dynamic dispatch]%
    [\url{http://en.wikipedia.org/wiki/Dynamic_dispatch}]

    Nusprendimo, kokį kodą vykdyti gavus žinutę, procesas,
    atliekamas programos vykdymo metu.

  \end{entry}

  \begin{entry}%
    {statically-typed-programming-language}%
    {statiškai tipizuota programavimo kalba}%
    [statically typed programming language]%
    [\url{http://en.wikipedia.org/wiki/Static_typing\#Static_typing}]

    Programavimo kalba, kurioje tipų patikrinimas yra atliekamas
    kompiliavimo metu.
    
  \end{entry}

  \begin{entry}%
    {dynamically-typed-programming-language}%
    {dinamiškai tipizuota programavimo kalba}%
    [dynamically typed programming language]%
    [\url{http://en.wikipedia.org/wiki/Dynamic_typing\#Dynamic_typing}]

    Programavimo kalba, kurioje tipų patikrinimas yra atliekamas vykdymo
    metu. Dinamiškai tipizuotose kalbose tipus turi reikšmės, o ne
    kintamieji.
    
  \end{entry}

  \begin{entry}%
    {polymorphism}%
    {polimorfismas}%
    [polymorphism]%
    [%
    \url{http://en.wikipedia.org/wiki/Polymorphism_(computer_science)}, %
    \url{http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming}%
    ]%

    Programavimo kalbos savybė, kuri leidžia su skirtingų tipų duomenimis
    dirbti naudojantis ta pačia sąsaja. Išskiriami trys polimorfizmo tipai:
    \begin{itemize}
      \item \emph{Ad-hoc} polimorfizmas \en{Ad-hoc polymorphism} –
        iš esmės, tai yra funkcijų perdengimas;
      \item parametrinis polimorfizmas \en{parametric polymorphism} –
        programuojama taip, kad kodas nepriklausytų nuo duomenų tipo
        (pavyzdys būtų C++ šablonai ir Java generics);
      \item potipio polimorfizmas \en{subtype polymorphism} – 
        jei $T$ yra $S$ potipis, tai $T$ galima naudoti vietoje $S$.
    \end{itemize}
    
  \end{entry}
\end{glossary}

\begin{description}

  \item[metodo užklotis \en{method overriding}]
    Objektinės programavimo kalbos savybė, kuri leidžia paveldinčiai klasei
    realizuoti metodą, kurį jau yra realizavusi kažkuri iš jos tėvinių
    klasių. Paveldinčios klasės metodo realizacija užkloja (paslepia)
    tėvinės klasės metodą.

  \item[funkcijos perdengimas \en{function overloading}]
    Programavimo kalbos savybė, kuri leidžia aprašyti kelias funkcijas
    turinčias tą patį vardą, kurios yra atskiriamos pagal jų argumentų
    tipus.

  \item[įdėtinė klasė \en{nested class, static inner class}]
    Java kalboje, tai klasė apibrėžta kitos klasės viduje, bet
    kurios objekto sukūrimui nėra būtinas gaubiančiosios
    klasės objektas. Ji apibrėžiama su \verb|static| konstrukcija.
    Scala neturi įdėtinių klasių.

  \item[vidinė klasė \en{inner class}]
    Java kalboje, tai klasė apibrėžta kitos klasės viduje. Jos
    objekto sukūrimui yra būtinas gaubiančiosios klasės objektas.
    Scala kalboje visos klasės apibrėžtos kitų klasių viduje
    yra vidinės klasės.

\end{description}
