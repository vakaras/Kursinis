\chapter{Objektinės paradigmos apibrėžimas}

\section{Įvairūs objektinės programavimo kalbos apibrėžimai}

\subsection{„The Treaty of Orlando“}

1987 metais ACM OOPSLA paskelbė dokumentą, pavadintą „The Treaty of
Orlando“ \cite{Lieberman:1987:TO:62139.62144}, kuriame nurodoma, kad
objektinių programavimo kalbų pagrindinis bruožas yra galimybė objektui
pačiam spręsti ką jis daro, gavęs žinutę. (Tai iš esmės skiriasi nuo
modulinio programavimo, kur visada yra įvykdoma ta pati procedūra.)
Dokumente yra minimi du būdai, kaip tai galima pasiekti:
\begin{itemize}
  \item žinučių persiuntimas \en{messages forwarding} ir
  \item dinaminis paveldėjimas \en{dynamic inheritance} (pavyzdžiui,
    \cite[272]{cpp-design-evolution} aprašomas bandymas C++
    kalboje realizuoti galimybę konstruktoriui perduoti rodyklę, kuri
    turėtų būti naudojama, kaip bazinė klasė).
\end{itemize}

\subsection{Benjamin C. Pierce}

2002 metais Benjamin C. Pierce savo knygoje „Types and programming
languages“\cite[225-227]{types-and-programming-languages} išvardino
esmines savybes, kurias turi dauguma objektinių programavimo kalbų: 
\begin{description}
  \item[dinaminis susiejimas] \en{dynamic dispatch, dynamic binding} –
    objekto reakcija į gautą žinutę nustatoma vykdymo metu;
  \item[uždarumas, inkapsuliacija] \en{encapsulation} – vidinė objekto
    struktūra yra slepiama;
  \item[potipiai] \en{subtyping} – kai norime pasinaudoti objektu, 
    tai mums rūpi tik jo sąsaja ir mes galime naudoti objektą $I$ vietoj
    objekto $J$, jei objekto $J$ sąsaja yra objekto $I$ sąsajos poaibis;
  \item[paveldėjimas, pavedimas] \en{inheritance, delegation} – galimybė
    perpanaudoti jau egzistuojantį kodą: tai gali būti pasiekiama
    objektų kūrimui naudojant klases, kurios gali paveldėti kai kurias
    savybes iš tėvinių klasių, arba naudojant žinučių persiuntimą;
  \item[atvira rekursija] \en{open recursion} – specialaus kintamojo
    (dažniausiai jis vadinamas „this“, arba „self“) egzistavimas, kuriuo
    pasinaudojant galima kreiptis į kitus to paties objekto metodus.
    Svarbi savybė yra \en{late-bound}.
\end{description}

\subsection{John Mitchell}

Pagal John Mitchell \cite[277]{concepts-in-programming-languages}
objektinė programavimo kalba \en{object-oriented language} privalo
turėti:
\begin{description}
  \item[objektus] – „paslėpti“ duomenys ir operacijos, kurias galima
    atlikti su jais;
  \item[dinaminis susiejimas] \en{dynamic lookup} – objektas pats
    sprendžia, kaip sureaguoti į žinutę ir skirtingi objektai gali
    į tą pačią žinutę sureaguoti skirtingai;
  \item[abstrakcija] \en{abstraction} – realizacijos detalės yra
    paslėptos ir veiksmus galima atlikti tik per sąsają (paprastai
    objektų sąsaja yra aibė viešų metodų, kurie atlieka veiksmus
    su paslėptais duomenimis);
  \item[potipiai] \en{subtyping} – jei objektas a turi visą funkcionalumą,
    kurį turi objektas b, tai objektą a galima naudoti visur vietoj
    objekto b;
  \item[paveldėjimas] \en{inheritance} – galimybė perpanaudoti vieno
    objekto apibrėžimą, apibrėžiant kitą objektą.
\end{description}

\subsection{Grady Booch}

Knygoje \cite[41-42]{Booch:2007:OAD:1407387} teigiama, kad objektiškai
orientuotas programavimas yra programų kūrimo metodika, kai programos
yra sudarytos iš tarpusavyje komunikuojančių objektų grupių; kiekvienas
objektas yra priskirtas kuriai nors klasei ir visos klasės yra
tarpusavyje susietos paveldėjimo ryšiu. (Nurodomas senesnis
apibrėžimas (1985 metų) iš esmės atmetant „The Treaty of
Orlando“.)

\subsection{Michael L. Scott}

Michael L. Scott \cite[529-530]{programming-language-pragmatics}
išskyrė tik šias savybes:
\begin{itemize}
  \item uždarumas, inkapsuliacija;
  \item paveldėjimas;
  \item dinaminis susiejimas.
\end{itemize}

\subsection{Peter Wegner}

Peter Wegner manymu objektinis programavimas \en{object-based} yra nusakomas
šiais terminais \cite[168]{Wegner:1987:DOL:38807.38823}:
\begin{itemize}
  \item objektai \en{objects} – savarankiškos esybės, kurios reaguoja į
    žinutes ir turi būseną;
  \item klasės \en{classes} – objektų klasifikavimo būdas pagal jų bendras
    operacijas;
  \item paveldėjimas \en{inheritance} padeda klasifikuoti klases pagal
    jų bendrą elgseną;
  \item duomenų abstrakcija \en{data abstraction} paslepia duomenų
    vaizdavimo (saugojimo) būdą ir operacijų realizacijos detales;
  \item stipri tipizacija \en{strong typing} primeta statinius apribojimus
    operacijų pritaikymui tiek viduje tiek tarp objektų;
  \item multiprogramiškumas \en{concurrency};
  \item pastovumas \en{persistence} leidžia objektams išlaikyti tapatybę
    tarp aplikacijų ir būti nepriklausomam nuo reikšmių ir raktų naudotų
    renkantis objektus.
\end{itemize}

\begin{defn}[Objektiškai paremta \en{object-based} kalba]
  Kalba, kurioje yra galimybė naudoti objektus.
  \cite[169]{Wegner:1987:DOL:38807.38823}:
\end{defn}

\begin{defn}[Objektiškai orientuota \en{object-oriented} kalba]
  Objektiškai paremta kalba, kurioje objektai priklauso klasėms ir kuriose
  klasių hierarchija gali būti pažingsniui apibrėžta panaudojant paveldėjimo
  mechanizmą.
  \cite[169]{Wegner:1987:DOL:38807.38823}:
\end{defn}

\begin{comment}
  Šis autorius objektinę paradigmą nagrinėja labai plačiai:
  išskiria beklases programavimo kalbas (aktorių ir prototipinę)
  bei klasines programavimo kalbas, bet pastarąsias yra linkęs laikyti
  svarbesnėmis (jas vadina objektiškai orientuotomis). Jo nuomone
  beklasės objektinės kalbos tinka eksperimentavimui, nes jos yra
  lanksčios, o klasinės (ir tuo labiau stipriai tipizuotos bei kuriose
  yra realizuota duomenų abstrakcija) – „produkcijai“, nes jose
  daug problemų gali pagauti kompiliatorius. Autorius išreiškė
  mintį, kad visiškai naujos dalykinės srities modeliavimas turėtų
  būti pradedamas naudojant beklasę programavimo kalbą ir tada, kai
  jau pasidaro aiškios bendros objektų savybės išskirti klases ir
  „pernešti“ visą modelį į klasinę programavimo kalbą.

  Taip pat verta pastebėti, kad Peter Wegner paveldėjimą
  \en{inheritance} laiko ne alternatyva pavedimui \en{delegation},
  bet jo specializacija.
\end{comment}

\subsection{Mark Stefik ir Daniel G. Bobrow}

Savo darbe\cite[41]{OOP-themes-and-variations} Mark Stefik ir Daniel G.
Bobrow objektą apibrėžia, kaip \emph{esybę, kuri apjungia duomenų ir
procedūrų savybes tam, kad galėtų atlikti veiksmus ir turėti būseną}.

\subsection{Clemens Szyperski}

Clemens Szyperski savo knygoje \emph{Component Software, Beyond
Object-Oriented Programming} apibrėžia, kad objektas
yra\cite[37]{cs-beyond-object-oriented-programming}:
\begin{itemize}
  \item egzistavimo vienetas \en{unit of instantiation}, kuris turi
    unikalią tapatybę – objektas negali būti inicializuotas dalinai
    \en{partially instantiated}
    (FIXME: Kaip išversti \en{instance}, gal „egzempliorius“?);
  \item gali turėti būseną, kurią galima stebėti iš išorės;
  \item enkapsuliuoja savo būseną ir elgseną.
\end{itemize}

\section{Klasinis objektiškai orientuotas programavimas}

Kadangi objektinio programavimo kalbos, kuriose objektų kūrimas yra
paremtas klasėmis, yra žymiai populiaresnės (FIXME: Pagrįsti.), tai
toliau objektiniu programavimu bus vadinamas būtent objektinis
programavimas panaudojant klases \en{class-based programming}. Jo
pagrindinės savybės būtų:
\begin{description}
  \item[dinaminis susiejimas] – objektas pats sprendžia, kaip sureaguoti
    į žinutę ir skirtingi objektai gali į tą pačią žinutę sureaguoti
    skirtingai;
  \item[uždarumas, inkapsuliacija] – vidinė objekto struktūra yra
    slepiama;
  \item[potipiai] – kai norima pasinaudoti objektu, tai mums rūpi tik
    jo sąsaja ir mes galime naudoti objektą $a$ vietoj objekto $b$,
    jei objekto $b$ sąsaja yra objekto $a$ sąsajos poaibis;
  \item[paveldėjimas] – galimybė perpanaudoti vieno objekto apibrėžimą,
    apibrėžiant kitą objektą.
\end{description}

\section{Sutvarkyti}

TODO: Pridėti paaiškinimą, kodėl man rūpi tik pirmas:
\begin{itemize}
  \item \url{http://en.wikipedia.org/wiki/Class-based_programming},
  \item \url{http://en.wikipedia.org/wiki/Prototype-based_programming}.
\end{itemize}

TODO: Nurodyti, kodėl miniu būtent šituos šaltinius. (Kodėl būtent jie
yra svarbūs.)

TODO: Užmesti akį į: basicoo.pdf, mcr.pdf

TODO: Penki gero objektinio programavimo stiliaus principai:
\url{http://en.wikipedia.org/wiki/Solid_(object-oriented_design)}

\subsection{Robert C. Martin}

Autorius teigia (\cite[4]{design-principles-and-design-patterns}), kad
pagrindinė problema dėl ko programinė įranga pradeda pūti yra
priklausomybių tarp sistemos elementų problemos.

Jis taip pat teigia, kad
(\cite[12]{design-principles-and-design-patterns}) „atvirumo-uždarumo“
principas yra OO architektūros tikslas, o priklausomybių
„apvertimas“ \en{dependency inversion} yra pagrindinis įrankis jam
pasiekti, kuris lemia komponentinės paradigmos privalumus.

\subsubsection{Sutvarkyti}

Jei sistemos dalys yra sujungtos tiesiogiai, tai, dėl pakeitimų vienoje
dalyje, gali reikėti taisyti visas nuo tos dalies priklausomas. Sprendimas
būtų dalis daryti priklausomas tik nuo abstrakčių sąsajų, ką komponentinis
būtent ir verčia daryti.

\subsection{Privalomos savybės}
\subsection{Papildomos savybės}

\begin{description}
  \item[objektų klasės] \en{classes of objects};
  \item[FIXME: klasių objektai] \en{instances of classes};
  \item[metodai susieti su objektais] \en{methods which act on the
    attached objects};
  \item[žinučių siuntimas (kitiems procesams)] \en{message passing}
    TODO: \url{http://en.wikipedia.org/wiki/Message_passing};
  \item[abstrakcija] \en{abstraction}
    TODO: \url{http://en.wikipedia.org/wiki/Abstraction_(computer_science)}
\end{description}
