\chapter{Objektinės paradigmos apibrėžimas}

\section{Įvairūs objektinės programavimo kalbos apibrėžimai}

\subsection{„The Treaty of Orlando“}

1987 metais ACM OOPSLA paskelbė dokumentą, pavadintą „The Treaty of
Orlando“ \cite{Lieberman:1987:TO:62139.62144}, kuriame nurodoma, kad
objektinių programavimo kalbų pagrindinis bruožas yra galimybė objektui
pačiam spręsti ką jis daro, gavęs žinutę. (Tai iš esmės skiriasi nuo
modulinio programavimo, kur visada yra įvykdoma ta pati procedūra.)
Dokumente yra minimi du būdai, kaip tai galima pasiekti:
\begin{itemize}
  \item žinučių persiuntimas \en{messages forwarding} ir
  \item dinaminis paveldėjimas \en{dynamic inheritance} (pavyzdžiui,
    \cite[272]{cpp-design-evolution} aprašomas bandymas C++
    kalboje realizuoti galimybę konstruktoriui perduoti rodyklę, kuri
    turėtų būti naudojama, kaip bazinė klasė).
\end{itemize}

\subsection{Benjamin C. Pierce}

2002 metais Benjamin C. Pierce savo knygoje „Types and programming
languages“\cite[225-227]{types-and-programming-languages} išvardino
esmines savybes, kurias turi dauguma objektinių programavimo kalbų: 
\begin{description}
  \item[dinaminis susiejimas] \en{dynamic dispatch, dynamic binding} –
    objekto reakcija į gautą žinutę nustatoma vykdymo metu;
  \item[uždarumas, inkapsuliacija] \en{encapsulation} – vidinė objekto
    struktūra yra slepiama;
  \item[potipiai] \en{subtyping} – kai norime pasinaudoti objektu, 
    tai mums rūpi tik jo sąsaja ir mes galime naudoti objektą $I$ vietoj
    objekto $J$, jei objekto $J$ sąsaja yra objekto $I$ sąsajos poaibis;
  \item[paveldėjimas, pavedimas] \en{inheritance, delegation} – galimybė
    perpanaudoti jau egzistuojantį kodą: tai gali būti pasiekiama
    objektų kūrimui naudojant klases, kurios gali paveldėti kai kurias
    savybes iš tėvinių klasių, arba naudojant žinučių persiuntimą;
  \item[atvira rekursija] \en{open recursion} – specialaus kintamojo
    (dažniausiai jis vadinamas „this“, arba „self“) egzistavimas, kuriuo
    pasinaudojant galima kreiptis į kitus to paties objekto metodus.
    Svarbi savybė yra \en{late-bound}.
\end{description}

\subsection{John Mitchell}

Pagal John Mitchell \cite[277]{concepts-in-programming-languages}
objektinė programavimo kalba \en{object-oriented language} privalo
turėti:
\begin{description}
  \item[objektus] – „paslėpti“ duomenys ir operacijos, kurias galima
    atlikti su jais;
  \item[dinaminis susiejimas] \en{dynamic lookup} – objektas pats
    sprendžia, kaip sureaguoti į žinutę ir skirtingi objektai gali
    į tą pačią žinutę sureaguoti skirtingai;
  \item[abstrakcija] \en{abstraction} – realizacijos detalės yra
    paslėptos ir veiksmus galima atlikti tik per sąsają (paprastai
    objektų sąsaja yra aibė viešų metodų, kurie atlieka veiksmus
    su paslėptais duomenimis);
  \item[potipiai] \en{subtyping} – jei objektas a turi visą funkcionalumą,
    kurį turi objektas b, tai objektą a galima naudoti visur vietoj
    objekto b;
  \item[paveldėjimas] \en{inheritance} – galimybė perpanaudoti vieno
    objekto apibrėžimą, apibrėžiant kitą objektą.
\end{description}

\subsection{Grady Booch}

Knygoje \cite[41-42]{Booch:2007:OAD:1407387} teigiama, kad objektiškai
orientuotas programavimas yra programų kūrimo metodika, kai programos
yra sudarytos iš tarpusavyje komunikuojančių objektų grupių; kiekvienas
objektas yra priskirtas kuriai nors klasei ir visos klasės yra
tarpusavyje susietos paveldėjimo ryšiu. (Nurodomas senesnis
apibrėžimas (1985 metų) iš esmės atmetant „The Treaty of
Orlando“.)

\subsection{Michael L. Scott}

Michael L. Scott \cite[529-530]{programming-language-pragmatics}
išskyrė tik šias savybes:
\begin{itemize}
  \item uždarumas, inkapsuliacija;
  \item paveldėjimas;
  \item dinaminis susiejimas.
\end{itemize}

\subsection{Peter Wegner}

Peter Wegner manymu objektinis programavimas \en{object-based} yra nusakomas
šiais terminais \cite[168]{Wegner:1987:DOL:38807.38823}:
\begin{itemize}
  \item objektai \en{objects} – savarankiškos esybės, kurios reaguoja į
    žinutes ir turi būseną;
  \item klasės \en{classes} – objektų klasifikavimo būdas pagal jų bendras
    operacijas;
  \item paveldėjimas \en{inheritance} padeda klasifikuoti klases pagal
    jų bendrą elgseną;
  \item duomenų abstrakcija \en{data abstraction} paslepia duomenų
    vaizdavimo (saugojimo) būdą ir operacijų realizacijos detales;
  \item stipri tipizacija \en{strong typing} primeta statinius apribojimus
    operacijų pritaikymui tiek viduje tiek tarp objektų;
  \item multiprogramiškumas \en{concurrency};
  \item pastovumas \en{persistence} leidžia objektams išlaikyti tapatybę
    tarp aplikacijų ir būti nepriklausomam nuo reikšmių ir raktų naudotų
    renkantis objektus.
\end{itemize}

\begin{defn}[Objektiškai paremta \en{object-based} kalba]
  Kalba, kurioje yra galimybė naudoti objektus.
  \cite[169]{Wegner:1987:DOL:38807.38823}:
\end{defn}

\begin{defn}[Objektiškai orientuota \en{object-oriented} kalba]
  Objektiškai paremta kalba, kurioje objektai priklauso klasėms ir kuriose
  klasių hierarchija gali būti pažingsniui apibrėžta panaudojant paveldėjimo
  mechanizmą.
  \cite[169]{Wegner:1987:DOL:38807.38823}:
\end{defn}

\begin{comment}
  Šis autorius objektinę paradigmą nagrinėja labai plačiai:
  išskiria beklases programavimo kalbas (aktorių ir prototipinę)
  bei klasines programavimo kalbas, bet pastarąsias yra linkęs laikyti
  svarbesnėmis (jas vadina objektiškai orientuotomis). Jo nuomone
  beklasės objektinės kalbos tinka eksperimentavimui, nes jos yra
  lanksčios, o klasinės (ir tuo labiau stipriai tipizuotos bei kuriose
  yra realizuota duomenų abstrakcija) – „produkcijai“, nes jose
  daug problemų gali pagauti kompiliatorius. Autorius išreiškė
  mintį, kad visiškai naujos dalykinės srities modeliavimas turėtų
  būti pradedamas naudojant beklasę programavimo kalbą ir tada, kai
  jau pasidaro aiškios bendros objektų savybės išskirti klases ir
  „pernešti“ visą modelį į klasinę programavimo kalbą.

  Taip pat verta pastebėti, kad Peter Wegner paveldėjimą
  \en{inheritance} laiko ne alternatyva pavedimui \en{delegation},
  bet jo specializacija.
\end{comment}

\subsection{Mark Stefik ir Daniel G. Bobrow}

Savo darbe\cite[41]{OOP-themes-and-variations} Mark Stefik ir Daniel G.
Bobrow objektą apibrėžia, kaip \emph{esybę, kuri apjungia duomenų ir
procedūrų savybes tam, kad galėtų atlikti veiksmus ir turėti būseną}.

\subsection{Clemens Szyperski}

Clemens Szyperski savo knygoje \emph{Component Software, Beyond
Object-Oriented Programming} apibrėžia, kad objektas
yra\cite[37]{cs-beyond-object-oriented-programming}:
\begin{itemize}
  \item egzistavimo vienetas \en{unit of instantiation}, kuris turi
    unikalią tapatybę – objektas negali būti inicializuotas dalinai
    \en{partially instantiated}
    (FIXME: Kaip išversti \en{instance}, gal „egzempliorius“?);
  \item gali turėti būseną, kurią galima stebėti iš išorės;
  \item enkapsuliuoja savo būseną ir elgseną.
\end{itemize}

\section{Klasinis objektiškai orientuotas programavimas}

Kadangi objektinio programavimo kalbos, kuriose objektų kūrimas yra
paremtas klasėmis, yra žymiai populiaresnės (FIXME: Pagrįsti.), tai
toliau objektiniu programavimu bus vadinamas būtent objektinis
programavimas panaudojant klases \en{class-based programming}. Jo
pagrindinės savybės būtų:
\begin{description}
  \item[dinaminis susiejimas] – objektas pats sprendžia, kaip sureaguoti
    į žinutę ir skirtingi objektai gali į tą pačią žinutę sureaguoti
    skirtingai;
  \item[uždarumas, inkapsuliacija] – vidinė objekto struktūra yra
    slepiama;
  \item[potipiai] – kai norima pasinaudoti objektu, tai mums rūpi tik
    jo sąsaja ir mes galime naudoti objektą $a$ vietoj objekto $b$,
    jei objekto $b$ sąsaja yra objekto $a$ sąsajos poaibis;
  \item[paveldėjimas] – galimybė perpanaudoti vieno objekto apibrėžimą,
    apibrėžiant kitą objektą.
\end{description}

\section{Sutvarkyti}

Objektinio problemos:
\begin{itemize}
  \item pataisius vieną klasę, gali reikėti taisyti visas nuo jos
    priklausomas (objektiniame, tai galima spręsti taikant DIP
    \en{Dependency Inversion Principle});
  \item gali reikėti pakeisti konkrečios klasės egzemplioriaus veikseną,
    nekeičiant jo klasės kodo (atrodo, kad šioje vietoje Scala skiriasi
    nuo „tikro“ komponentinio tuo, kad ji imasi „gydimo“, o komponentinis
    – „prevencijos“, tai yra šioje vietoje turime ne grynai objektinio
    problemą, bet netinkamos architektūros problemą);
  \item dalykinės srities kodas „paslepiamas“ „palaikančio“ kodo
    (žurnalizavimas, transakcijos, saugumas ir t.t.) – šią problemą
    bando spręsti \en{Aspect-oriented programming}, kuris yra objektinio
    „praplėtimas“ (kita kryptimi, nei tai daro komponentinis; pavyzdžiui,
    EJB konteineris teikia kai kuriuos servisus, bet kurti naujus
    servisus nėra galimybės \cite[285]{mastering-EJB});

    \TODO: EJB: CDI Portable extensions.

    \TODO Komponento modifikavimas. Ką reiškią paveldėjimas tarp
    komponentų?

    \TODO Ar Scalable Component Abstractions autoriai yra teisūs
    siūlydami komponentinį programavimo būdą? (Užmesti akį į
    \cite{odersky:scala-experiment}.) Išsiaiškinti CakePattern
    ir Scalable Component Abstractions ir ką tai duoda daugiau
    nei paprastas programavimas. O jei duoda, tai parodyti, kaip
    eiliniam programuotojui tuo pasinaudoti.
    Standartiniam komponentiniam kompiliatorius komponentų jungimui nėra
    kviečiamas.

  \item klasės vardų srities užteršimas, jei naudojami „mixin“
    (žr.: \url{http://www.artima.com/weblogs/viewpost.jsp?thread=246341}
    ir \url{http://www.artima.com/weblogs/viewpost.jsp?thread=246483}).
    Ar Scala įdėtųjų \en{nested} klasių naudojimas sprendžia šią problemą?
\end{itemize}


TODO: Kuo skiriasi paveldėjimas nuo pavedimo dinaminėse objektinėse
programavimo kalbose tokiose, kaip Python? Skirtumai:
\begin{itemize}
  \item pavedimo atveju, keli „vaikai“ (objektai) gali turėti tą
    patį objektą, kaip „tėvą“.
\end{itemize}
Skirtumai statinėse objektinėse programavimo kalbose, tokiose, kaip
Java:
\begin{itemize}
  \item pavedimo atveju, keli „vaikai“ (objektai) gali turėti tą
    patį objektą, kaip „tėvą“;
  \item pavedimo atveju, „vaikas“ gali turėti kelis „tėvus“;
  \item paveldėjimo atveju, „vaiką“ galima visada naudoti vietoj „tėvo“.
\end{itemize}

TODO: Pridėti paaiškinimą, kodėl man rūpi tik pirmas:
\begin{itemize}
  \item \url{http://en.wikipedia.org/wiki/Class-based_programming},
  \item \url{http://en.wikipedia.org/wiki/Prototype-based_programming}.
\end{itemize}

TODO: Nurodyti, kodėl miniu būtent šituos šaltinius. (Kodėl būtent jie
yra svarbūs.)

TODO: Užmesti akį į: basicoo.pdf, mcr.pdf

TODO: Penki gero objektinio programavimo stiliaus principai:
\url{http://en.wikipedia.org/wiki/Solid_(object-oriented_design)}

\subsubsection{Scala prieš Java}

Kuo Scala pranašesnė už Java? (Ar pranašesnė?) Ir kaip reikia
programuoti, kad pasinaudoti tais privalumais? Ir į ką tai labiau
panašu: į komponentinį ar į objektinį?
Gauti sąrašėlį, ką Scaloje dar įmanoma padaryti, ko nebeįmanoma
su Java.

Scala privalumai prieš Java:
\begin{enumerate}
  \item galima apsieiti be null (panaudojant Options)
    \url{http://ofps.oreilly.com/titles/9780596155957/TypeLessDoMore.html#OptionSomeNone};
  \item didesnės galimybės nurodyti kas yra matoma paketo (komponento)
    klientams
    \url{http://ofps.oreilly.com/titles/9780596155957/ApplicationDesign.html#FineGrainedVisibilityRules};
  \item neišreikštinis konvertavimas tarp tipų leidžiantis:
    \begin{itemize}
      \item „modifikuoti“ klasę, pažymėtą, kaip „final“
        Martin Odersky straipsnis „Pimp my Library“
        \url{http://www.artima.com/weblogs/viewpost.jsp?thread=179766}
        ir \cite[173]{beginning-scala}
        \TODO Kuo tai yra susiję su „Adapter Pattern“?;
      \item kurti dalykinės srities kalbą\cite[175]{beginning-scala}
        (\verb|val a = 2 days|);
    \end{itemize}
  \item sudėtingos klasių hierarchijos, garantavimas, kad objektas
    tenkina ne vieną, o kelias sąsajas\cite[184]{beginning-scala};
  \item saugesnė tipų sistema – apsauga nuo „rankinių“,
    kompiliatoriaus netikrinamų konvertavimų tarp tipų
    \cite[172]{beginning-scala} ir
    \en{covariant, contravariant, invariant} \cite[207]{beginning-scala};
    \TODO: \cite{scala:type-checking}
    \TODO: A Nominal Theory of Objects with Dependent Types
    \url{http://www.springerlink.com/content/cc97g8gruwtfudm5/}
  \item TODO: galingesnė tipų sistema? Žr.: duomenų bazės abstrakcijos
    lygio realizaciją \cite[190]{beginning-scala};
  \item didesnės galimybės pataisyti svetimos bibliotekos klases.
\end{enumerate}

Konkrečios situacijos.
\begin{enumerate}
  \item Turime trečiųjų šalių sukurtą Java biblioteką (jos kodo
    keisti negalime), kurioje yra įgyvendintas „Metodo šablono“
    projektavimo šablonas. Tarkime, kad mums prisireikė pakeisti
    abstrakčios klasės kažkurį tai iš metodų. (Žr. KursinisMethodTemplate
    Eclipse projektą.)

    TODO: Parodyti galimus sprendimus su Java:
    \begin{itemize}
      \item sukuriant klasę, kuri deleguoja visas žinutes išskyrus
        \verb|someMethod|, kurią perdengia;
      \item sukuriant išvestines klases klasėms \verb|ConcreteClass1|
        ir \verb|ConcreteClass2|, kurios perdengia \verb|someMethod|
        metodą.
    \end{itemize}

    TODO: Parodyti galimus sprendimus su C++:
    \begin{itemize}
      \item panaudojant template.
    \end{itemize}

    Čia Scala suteikiamas privalumas yra metodų kodo perpanaudojimas.

  \item TODO: Turime Java final klasę. Scala programavimo kalboje
    galime pasinaudoti \verb|implicit| konstrukcija. Java – reiktų
    naudoti delegavimą ir išreikštinį konvertavimą.
  \item TODO: Type safe database abstraction layer
    \cite[190]{beginning-scala}.
    FIXME: Ar šitas pavyzdys tinka?
  \item TODO: Pavyzdys su daugybiniu paveldėjimu. (Pademonstruoti jo
    realizaciją su Java, panaudojant pavedimą.)
  \item „Design Patterns“ patobulinimai:
    \begin{itemize}
      \item „Method Template“ – tą pačią funkcionalumo variaciją galima
        pritaikyti kelioms skirtingoms abstrakčioms klasėms tol, kol
        jos naudoja tą patį šablono metodą;
    \end{itemize}
\end{enumerate}

\subsection{Robert C. Martin}

Autorius teigia (\cite[4]{design-principles-and-design-patterns}), kad
pagrindinė problema dėl ko programinė įranga pradeda pūti yra
priklausomybių tarp sistemos elementų problemos.

Jis taip pat teigia, kad
(\cite[12]{design-principles-and-design-patterns}) „atvirumo-uždarumo“
principas yra OO architektūros tikslas, o priklausomybių
„apvertimas“ \en{dependency inversion} yra pagrindinis įrankis jam
pasiekti, kuris lemia komponentinės paradigmos privalumus.

\subsubsection{Sutvarkyti}

Jei sistemos dalys yra sujungtos tiesiogiai, tai, dėl pakeitimų vienoje
dalyje, gali reikėti taisyti visas nuo tos dalies priklausomas. Sprendimas
būtų dalis daryti priklausomas tik nuo abstrakčių sąsajų, ką komponentinis
būtent ir verčia daryti.

\subsection{Privalomos savybės}
\subsection{Papildomos savybės}

\begin{description}
  \item[objektų klasės] \en{classes of objects};
  \item[FIXME: klasių objektai] \en{instances of classes};
  \item[metodai susieti su objektais] \en{methods which act on the
    attached objects};
  \item[žinučių siuntimas (kitiems procesams)] \en{message passing}
    TODO: \url{http://en.wikipedia.org/wiki/Message_passing};
  \item[abstrakcija] \en{abstraction}
    TODO: \url{http://en.wikipedia.org/wiki/Abstraction_(computer_science)}
\end{description}
