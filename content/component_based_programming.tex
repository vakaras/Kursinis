\chapter{Komponentinės paradigmos apibrėžimas}

TODO: Kodėl komponentinio reikia? (Motyvacija.) Kodėl jį reikia pirkti.
Ypač lyginant su objektiniu. (Pasižiūrėti: modifikuojamumas,
evoliucinis vystymosi modelis prieš revoliucinį.)

Jei objektinis (klasinis objektinis) duotų modifikuojamumą, tai
turbūt komponentinio ir nereiktų.

\section{Komponentinių programų sistemų inžinerija}

\cite{analytical-study-cbse} pateikti tokie principai:
\begin{description}
  \item[nepriklausomas programinės įrangos kūrimas] \en{independent
    software development} – didelės sistemos yra sujungiamos iš dalių,
    kurias kūrė skirtingi žmonės. Tam, kad palengvinti nepriklausomą
    kūrimą, yra būtina atskirti komponentų kūrėjus nuo jų naudotojų,
    panaudojant nuo realizacijos nepriklausomą sąsają, kuri aprašo
    komponento elgesį;
  \item[perpanaudojamumas] \en{reusability} – 
  \item[programinės įrangos kokybė] \en{software quality} – turi
    būti parodyta, kad komponentas ar sistema elgiasi būtent taip, kaip
    yra tikimasi;
  \item[palaikymas] \en{maintainability} – sistema turi būti suprantama
    ir lengvai plečiama.
\end{description}

„Komponentas yra programinės įrangos elementas, kuris prisitaiko prie
programinės įrangos modelio ir gali būti nepriklausomai vystomas
bei įkomponuotas nedarant jame pakeitimų ir laikantis komponavimo
standarto.“\cite[438]{analytical-study-cbse} (Originalas iš
\cite{heineman2001component}.)
FIXME: Citatoje, pateiktoje \cite{classification-framework-for-scm},
vietoje „software model“ minimas „component model“.

\begin{defn}[Komponentų modelis]
  Komponentų modelis apibrėžia aibę standartų, skirtų komponentų
  realizacijai, įvardinimui, veikimui kartu \en{interoperability},
  pritaikymui, komponavimui, evoliucijai ir naudojimui \en{deployment}.
\end{defn}

\section{UML 2.2}

% 159 – puslapis PDF dokumente.
„Modulinis vienetas su aiškiai apibrėžtomis sąsajomis, kurį jo
aplinkoje galima pakeisti kitu.“\cite[143]{UML-superstructure}
(TODO: Perfrazuoti.)

Savybės:
\begin{itemize}
  \item komponentų perpanaudojimas;
  \item komponentas visada gali būti traktuojamas, kaip savarankiškas
    vienetas sistemoje arba posistemėje;
  \item komponentas pateikia ir/arba prašo bent vienos sąsajos;
  \item komponento vidus yra paslėptas ir prie jo galima prieiti tik
    per komponento pateikiamas sąsajas;
  \item komponentui nereikia kitų sistemos elementų, išskyrus tuos, kurių
    išreikštinai prašo per sąsajas;
  \item komponentas gali būti kuriamas atskirai nuo visos sistemos.
\end{itemize}

Kitas apibrėžimas: „Komponentas reprezentuoja modulinę sistemos dalį, kuri
inkapsuliuoja savo turinį ir kurią galima pakeisti jos aplinkoje.“
\cite[146]{UML-superstructure}

\begin{note}
  Realizacijos detalės:

  Apibrėžimas iš
  \emph{BasicComponents}\cite[146]{UML-superstructure}: Komponentas yra
  klasės potipis, todėl turi viską, ką turi ir klasė.  Komponentas
  taip pat gali turėti vidinę struktūrą ir prievadų (\emph{Ports})
  aibę, kuri formalizuoja sąveikos su juo taškus. Kiekvienas
  komponentas turi pateikiamas ir prašomas sąsajas, kurios suteikia
  galimybę jungti komponentus į visumą naudojantis
  \emph{Dependencies} ar \emph{Connectors}. (TODO: Pasižiūrėti
  terminų apibrėžimus specifikacijoje.)

  TODO: Išsinagrinėti \emph{PackagingComponents}.
\end{note}

\section{Component software: beyond object-oriented programming}

„To be specific, for the purposes of this book, software components
are executable units of independent production, acquisition, and deployment
that can be composed into a functioning system.“ 
\cite[3]{cs-beyond-object-oriented-programming}

TODO: Pasidomėti: „Descriptions in this sense are sometimes called
components (Sametinger, 1997).“%
\cite[3]{cs-beyond-object-oriented-programming}

TODO: Apibrėžti, kas yra komponentų modelis. \emph{Component model}

Komponentų savybės\cite[36]{cs-beyond-object-oriented-programming}:
\begin{description}
  \item[TODO] \en{is a unit of independent deployment}
    – tai lemia, kad komponentas yra uždaras (inkapsuliuotas) ir, kad
    komponentas yra gerai atskirtas nuo aplinkos ir kitų komponentų;
    % „Also, as it is a unit of deployment, a component will never
    % be deployed partially.“
  \item[jungus su „svetimais“] \en{is a unit of third-party composition}
    – komponentas slepia savo turinį ir su išore bendrauja per gerai
    apibrėžtas sąsajas;
  \item[neturi (išoriškai) matomos būsenos] \en{has no (externally)
    observable state} – turi būti neįmanoma atskirti komponentą
    nuo jo kopijų.
\end{description}
Yra akcentuojama, kad dėl to, jog komponentai neturi stebimos būsenos,
jų konkrečioje vykdymo aplinkoje turėti daugiau nei vieną nėra prasmės.
TODO: Išsiaiškinti\cite[37]{cs-beyond-object-oriented-programming}:
Komponentai yra nekintamos programos, kurios „dirba“ su kintamais
objektais. Komponentai „pateikia“ objektus. \en{components provide objects}
Pavyzdys su duombaze (objektu) ir duomenų bazės serveriu (komponentu).

Palyginimui objekto savybės\cite[36]{cs-beyond-object-oriented-programming}:
\begin{itemize}
  \item \en{is a unit of instantiation, it has a unique identity}
    – objektas negali būti sukurtas dalinai, taip pat tam, kad galėtume
    sukurti objektą, reikia turėti jo kūrimo planą, kuris vadinamas klase,
    arba objektą \en{prototype object}, kurį klonuosime;
  \item \en{may have state and this can be externally observable};
  \item \en{encapsulates its state and behavior}.
\end{itemize}

Komponentai, skirtingai nei
moduliai\cite[39-40]{cs-beyond-object-oriented-programming}:
\begin{itemize}
  \item gali būti parametrizuoti panaudojant resursus (pavyzdžiui,
    lokalizavimo taisyklės), moduliai turi tik tą informaciją, kuri
    buvo įrašyta (įkompiliuota) jų kode;
  \item neturi būsenos (moduliai gali turėti statinius kintamuosius).
\end{itemize}

\begin{defn}[Programinės įrangos komponentas]
  A software component is a unit of composition with contractually
  specified interfaces and explicit context dependencies only. A
  software component can be deployed independently and is subject
  to composition by third parties.
  \cite[41]{cs-beyond-object-oriented-programming}
% FIXME Pasitikrinti ar teisingai išverčiau.
% Komponavimo vienetas su kontraktu apibrėžtomis sąsajomis ir tik
% išreikštinai nurodytais reikalavimais. Komponentas gali būti
% naudojamas nepriklausomai ir įkomponuotas trečiųjų šalių.
\end{defn}

TODO: Perskaityti. (Dabar perskaityta 0-39, 69-79)

\section{Scalable Component Abstractions}

Bendrai komponentai yra tiesiog programos dalys, kurios gali būti
panaudotos kuriant didesnes dalis ar aplikacijas. Galimos įvairios
komponentų formos: moduliai, klasės, bibliotekos, karkasai, procesai
interneto servisai.

Komponento savybės:
\begin{itemize}
  \item svarbiausia komponento savybė yra galimybė jo nepakeitus jį
    panaudoti kitame kontekste, nei jis buvo kurtas;
  \item tam užtikrinti komponentai turi turėti sąsajas per kurias
    teikia ir gauna servisus, taip pat komponentai turėtų minimizuoti
    tvirtą susiejimą \en{hard links} su aplinka;
\end{itemize}

\begin{note}
  While these languages offer some support for attaching interfaces
  describing the provided services of a component, they lack the
  capability to abstract over the services that are required.
  \cite[1]{scalable-component-abstractions}
\end{note}

\begin{note}
  Realizacijos detalės:

  Servisinis komponentinis modelis \en{Service-Oriented Component Model}:
  \begin{itemize}
    \item programinės įrangos komponentai yra skaičiavimo vienetai, kurie
      pateikia gerai apibrėžtą servisų aibę;
    \item jiems reikia kitų servisų, kuriuos teikia kiti komponentai;
    \item komponentas yra klasė (būtinas įdėtinių klasių palaikymas!);
    \item \en{concrete members} – kuriami servisai;
    \item \en{abstract members} – prašomi servisai;
    \item komponentų jungimas remiasi \en{mixins}.
  \end{itemize}

  Norint sukurti plečiamų \en{scalable} ir dinaminių \en{dynamic} komponentų
  sistemas yra būtina (darome prielaida, jog kalba apie stipriai
  \en{strongly} ir statiškai \en{statically} tipizuotas objektines
  programavimo kalbas):
  \begin{itemize}
    \item įdėtinių \en{nested} klasių palaikymas;
    \item \en{mixin} arba \en{trait} kompozicijos palaikymas arba
      multipaveldėjimas – būtina, kad klasėse, kaip nariai, galėtų
      būti aprašomi \en{mixin} arba klasės, bei, kad konkretūs klasės
      nariai pakeistų abstrakčius, nepriklausomai nuo to kokiu būdu
      buvo atliktas jungimas;
    \item galimybė abstrakčiai apibrėžti ko reikia klasei.
  \end{itemize}
\end{note}

\begin{note}
  Komponentų dinaminis radimas ir platinimas nėra nagrinėjamas.
\end{note}

\section{Lessons learned through six years of component-based development}

Autorius komponentą apibrėžia taip\cite{Sparling:2000:LLT:352183.352202}:
\begin{defn}[Komponentas]
  Komponentas yra nuo programavimo kalbos nepriklausomas, nepriklausomai
  realizuotas programinės įrangos servisų paketas, pristatytas
  uždarame \en{encapsulated} ir pakeičiamame konteineryje, pasiekiamas
  per vieną ar daugiau viešų sąsajų.

  Nors komponentas gali turėti galimybę keisti duombazę, bet neturėtų
  būti tikimasi, kad jis turės būsenos informaciją. Komponentas nėra
  nei suvaržytas platformos \en{platform-constrained}, nei apribotas
  aplikacijos srities \en{application-bound}.
\end{defn}

\section{Component primer}

Autorius komponentą apibrėžia, kaip\cite{Hopkins:2000:CP:352183.352198}:
\begin{defn}[Komponentas]
  Programinės įrangos komponentas yra fizinis paketas, vykdomos
  \en{executable} programinės įrangos su gerai apibrėžtomis ir
  paviešintomis sąsajomis.
\end{defn}

Taip pat autorius pabrėžia, kad siekimas sukurti gerai apibrėžtas sąsajas,
nepriklausomas nuo jų realizacijos yra būtinas siekiant sukurti
„loosely coupled systems“.
(TODO: \url{http://en.wikipedia.org/wiki/Loose_coupling}.)

\section{Objects, Components and Frameworks with UML: The Catalysis
Approach}

Autoriai komponentą apibrėžia,
kaip\cite[385]{objects-components-and-frameworks-with-uml}:
\begin{defn}[Komponentas (bendrai)]
  Rišlus programinės įrangos artefaktų paketas, kuris gali būti
  nepriklausomai kuriamas ir pristatytas \en{delivered} kaip vienetas
  ir kuris gali būti įkomponuotas kartu su kitais komponentais siekiant
  sukurti kažką didesnio.
\end{defn}

Autoriai taip pat išskiria skirtingus komponentų tipus. Kodo komponentą
apibrėžia, kaip\cite[386]{objects-components-and-frameworks-with-uml}:
\begin{defn}[Komponentas (kode)]
  Rišlus programinės įrangos realizacijos \en{implementation} paketas,
  kuris:
  \begin{itemize}
    \item gali būti nepriklausomai kuriamas ir pristatytas \en{delivered};
    \item turi išreikštines ir gerai apibrėžtas sąsajas savo pateikiamiems
      servisams;
    \item turi išreikštines ir gerai apibrėžtas sąsajas servisams, kurių
      jis tikisi;
    \item gali būti sujungtas su kitais komponentais į vieną visumą,
      nedarant juose pakeitimų.
  \end{itemize}
\end{defn}

Taip pat autoriai pabrėžia, kad komponentas:
\begin{itemize}
  \item yra „pakavimo vienetas“ \en{a unit of packaging}%
    \cite[387]{objects-components-and-frameworks-with-uml};
  \item yra „nepriklausomo perdavimo vienetas“ \en{a unit of independent
    delivery}\cite[387]{objects-components-and-frameworks-with-uml};
  \item išreikštinai nurodo tiek kuriamus servisus, tiek jam
    reikalingus servisus (skirtingai nuo klasių, kurios išreikštinai
    nurodo tik teikiamus servisus):
\end{itemize}

TODO: Perskaityti. (Dabar perskaityta 384-393)

\section{Component-Based Measurement: Few Useful Guidelines}

Autoriai, išanalizavę įvairius komponento apibrėžimus, pateikė tokį,
apibendrintą, apibrėžimą \cite[2]{Gill:2003:CMF:966221.966237}.
\begin{defn}[Komponentas]
  Rišlus programinės įrangos realizacijos paketas, kuris:
  \begin{itemize}
    \item turi keletą tarpusavyje susijusių servisų ir funkcijų;
    \item siūlo gerai apibrėžtas ir viešas sąsajas;
    \item siūlo servisus, kurie yra pasiekiami tik per jo sąsajas;
    \item yra perpanaudojamas;
    \item gali būti nepriklausomai kuriamas ir pristatytas.
  \end{itemize}
\end{defn}

\section{Vykdomasis neadaptyvus komponentas}

Dauguma autorių sutaria, kad vykdomasis komponentas yra programinės
įrangos vienetas, kuris:
\begin{enumerate}
  \item \label{com:exe:independent} gali būti kuriamas nepriklausomai;
  \item \label{com:exe:reusable} gali būti perpanaudojamas;
  \item \label{com:exe:blackbox} yra juoda dėžė;
  \item \label{com:exe:interfaceprovider} prie jo funkcionalumo galima
    prieiti tik per išreikštinai apibrėžtas sąsajas;
  \item \label{com:exe:interfaceuser} savo poreikius nurodo tik per
    išreikštinai apibrėžtas sąsajas;
  \item \label{com:exe:deployment} yra fizinis diegimo vienetas
    \en{unit of deployment};
    TODO: Pakeisti visur deployment → diegimo.
  \item \label{com:exe:composed} gali būti be pakeitimų sujungtas su
    kitais komponentais į vieną sistemą;
  \item \label{com:exe:interchangable} gali būti pakeičiamas kitu, jei…
\end{enumerate}

Kai kurie autoriai nurodo dar ir tokias savybes:
\begin{itemize}
  \item gali būti traktuojamas, kaip savarankiškas vienetas;
  \item turi būti silpnai susietas su aplinka;
  \item komponentų technologija nepriklausoma nuo programavimo kalbos;
  \item neturi (išoriškai) matomos būsenos.
\end{itemize}

TODO:
\begin{itemize}
  \item vieną paketą pakeisti kitu vykdymo metu;
\end{itemize}

\section{Vykdomasis adaptyvus komponentas}

TODO

\section{Sutvarkyti}

Mano hipotezė: komponentinę paradigmą galima suvokti, kaip dviejų dalykų
junginį:
\begin{itemize}
  \item paketų sistemos poaibio:
    \begin{itemize}
      \item atsakingi už \ref{com:exe:independent} (ta prasme, kad paketo
        kūrimo metu nereikia taisyti kitų paketų), \ref{com:exe:reusable},
        \ref{com:exe:deployment}, \ref{com:exe:composed};
      \item taip pat, OSGi gyvenimo ciklo etapai
        (\url{http://en.wikipedia.org/wiki/OSGi#Life-cycle}), atrodo,
        kad priklausytų čia (palyginimas su zc.buildout);
      \item pavyzdžiai, palaikantys tik šitą dalį: Python Egg, Debian DEB;
      \item kaip su Java JAR'ais? Kokią meta informaciją, jie savyje turi?
        Ar turi priklausomybių sąrašus? (Tai yra, ar pačiame JAR'e nurodyta,
        kad jam reikia kito JAR'o?)
      \item ar būtinai paketas turi būti vienas failas? Gal pakanka, kad
        būtų galima įdiegti paketą pagal pavadinimą:
        \emph{įdiek «paketas»} (Gentoo)?
    \end{itemize}
  \item objektinės paradigmos praplėtimo:
    \begin{itemize}
      \item atsakingi už \ref{com:exe:independent},
        \ref{com:exe:reusable}, \ref{com:exe:blackbox},
        \ref{com:exe:interfaceprovider}, \ref{com:exe:interfaceuser},
        \ref{com:exe:composed}, \ref{com:exe:interchangable};
      \item pavydžiai, palaikantys tik šią dalį: Scala;
    \end{itemize}
\end{itemize}

TODO: „Component-oriented programming“ Andy Ju An Wang, Kai Qian:
\url{http://onlinelibrary.wiley.com/doi/10.1002/0471713708.fmatter/summary}

TODO: Išsiaiškinti visą ginčą:
\url{http://drdobbs.com/architecture-and-design/184414588}
\cite{what-to-compose}

TODO: Component-Based Development Process and Component Lifecycle
\url{http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4031829}

TODO: Making components contract aware
\url{http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=774917}

TODO: The impact of research on the development of middleware technology
\url{http://dl.acm.org/citation.cfm?id=13487692}

TODO: Software Component Models
\url{http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4302781}

TODO: Component-Based and Service-Oriented Software Engineering: Key Concepts and Principles 
\url{http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4301060}

TODO: An Efficient Component Model for the Construction of Adaptive Middleware
\url{http://dl.acm.org/citation.cfm?id=697779}

TODO: Classification and survey of component models
\url{http://swepub.kb.se/bib/swepub:oai:DiVA.org:mdh-8858?tab2=abs&language=en}

TODO: Concerning Predictability in Dependable Component-Based Systems: Classification of Quality Attributes 
\url{http://www.springerlink.com/content/dpc7hnegdgdfnn5a/}

TODO: Perskaityti \cite[18]{classification-framework-for-scm} 7 skyrių
„Related Work“ ir išsirinkti kokius dar dokumentus reikėtų perskaityti.

TODO: \url{http://en.wikipedia.org/wiki/Separation_of_concerns}

TODO: \url{http://en.wikipedia.org/wiki/Architecture_description_language}

\subsection{A Classification Framework for Software Component Models}

Akcentuojamas ne be komponentas, o komponentų modelis.

\begin{defn}[Komponentų modelis]
  Komponentų modelis apibrėžia:
  \begin{enumerate}
    \item kokius reikalavimus turi tenkinti kiekvienas komponentas;
    \item komponentų sujungimo metodus (taip pat ir jų tarpusavio
      bendravimo).
  \end{enumerate}
  \cite[2]{classification-framework-for-scm}
\end{defn}

\begin{defn}[Komponentinė sistema]
  Komponentinė sistema apibrėžia:
  \begin{enumerate}
    \item komponentus;
    \item platformą;
    \item susiejimo mechanizmus.
  \end{enumerate}
  \cite[2]{classification-framework-for-scm}
\end{defn}
