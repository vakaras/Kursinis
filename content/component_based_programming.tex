\chapter{Komponentinės paradigmos apibrėžimas}

\section{Komponentinių programų sistemų inžinerija}

\cite{analytical-study-cbse} pateikti tokie principai:
\begin{description}
  \item[nepriklausomas programinės įrangos kūrimas] \en{independent
    software development} – didelės sistemos yra sujungiamos iš dalių,
    kurias kūrė skirtingi žmonės. Tam, kad palengvinti nepriklausomą
    kūrimą, yra būtina atskirti komponentų kūrėjus nuo jų naudotojų,
    panaudojant nuo realizacijos nepriklausomą sąsają, kuri aprašo
    komponento elgesį;
  \item[perpanaudojamumas] \en{reusability} – 
  \item[programinės įrangos kokybė] \en{software quality} – turi
    būti parodyta, kad komponentas ar sistema elgiasi būtent taip, kaip
    yra tikimasi;
  \item[palaikymas] \en{maintainability} – sistema turi būti suprantama
    ir lengvai plečiama.
\end{description}

„Komponentas yra programinės įrangos elementas, kuris prisitaiko prie
programinės įrangos modelio ir gali būti nepriklausomai vystomas
bei įkomponuotas nedarant jame pakeitimų ir laikantis komponavimo
standarto.“\cite[438]{analytical-study-cbse} (Originalas iš
\cite{heineman2001component}.)

\section{UML 2.2}

% 159 – puslapis PDF dokumente.
„Modulinis vienetas su aiškiai apibrėžtomis sąsajomis, kurį jo
aplinkoje galima pakeisti kitu.“\cite[143]{UML-superstructure}
(TODO: Perfrazuoti.)

Savybės:
\begin{itemize}
  \item komponentų perpanaudojimas;
  \item komponentas visada gali būti traktuojamas, kaip savarankiškas
    vienetas sistemoje arba posistemėje;
  \item komponentas pateikia ir/arba prašo bent vienos sąsajos;
  \item komponento vidus yra paslėptas ir prie jo galima prieiti tik
    per komponento pateikiamas sąsajas;
  \item komponentui nereikia kitų sistemos elementų, išskyrus tuos, kurių
    išreikštinai prašo per sąsajas;
  \item komponentas gali būti kuriamas atskirai nuo visos sistemos.
\end{itemize}

Kitas apibrėžimas: „Komponentas reprezentuoja modulinę sistemos dalį, kuri
inkapsuliuoja savo turinį ir kurią galima pakeisti jos aplinkoje.“
\cite[146]{UML-superstructure}

Apibrėžimas iš \emph{BasicComponents}\cite[146]{UML-superstructure}:
Komponentas yra klasės potipis, todėl turi viską, ką turi ir klasė. 
Komponentas taip pat gali turėti vidinę struktūrą ir prievadų (\emph{Ports})
aibę, kuri formalizuoja sąveikos su juo taškus. Kiekvienas komponentas turi
pateikiamas ir prašomas sąsajas, kurios suteikia galimybę jungti
komponentus į visumą naudojantis \emph{Dependencies} ar \emph{Connectors}.
(TODO: Pasižiūrėti terminų apibrėžimus specifikacijoje.)

TODO: Išsinagrinėti \emph{PackagingComponents}.

\section{Component software: beyond object-oriented programming}

„To be specific, for the purposes of this book, software components
are executable units of independent production, acquisition, and deployment
that can be composed into a functioning system.“ 
\cite[3]{cs-beyond-object-oriented-programming}

TODO: Pasidomėti: „Descriptions in this sense are sometimes called
components (Sametinger, 1997).“%
\cite[3]{cs-beyond-object-oriented-programming}

TODO: Apibrėžti, kas yra komponentų modelis. \emph{Component model}

Komponentų savybės\cite[36]{cs-beyond-object-oriented-programming}:
\begin{description}
  \item[TODO] \en{is a unit of independent deployment}
    – tai lemia, kad komponentas yra uždaras (inkapsuliuotas) ir, kad
    komponentas yra gerai atskirtas nuo aplinkos ir kitų komponentų;
    % „Also, as it is a unit of deployment, a component will never
    % be deployed partially.“
  \item[jungus su „svetimais“] \en{is a unit of third-party composition}
    – komponentas slepia savo turinį ir su išore bendrauja per gerai
    apibrėžtas sąsajas;
  \item[neturi (išoriškai) matomos būsenos] \en{has no (externally)
    observable state} – turi būti neįmanoma atskirti komponentą
    nuo jo kopijų.
\end{description}
Yra akcentuojama, kad dėl to, jog komponentai neturi stebimos būsenos,
jų konkrečioje vykdymo aplinkoje turėti daugiau nei vieną nėra prasmės.
TODO: Išsiaiškinti\cite[37]{cs-beyond-object-oriented-programming}:
Komponentai yra nekintamos programos, kurios „dirba“ su kintamais
objektais. Komponentai „pateikia“ objektus. \en{components provide objects}
Pavyzdys su duombaze (objektu) ir duomenų bazės serveriu (komponentu).

Palyginimui objekto savybės\cite[36]{cs-beyond-object-oriented-programming}:
\begin{itemize}
  \item \en{is a unit of instantiation, it has a unique identity}
    – objektas negali būti sukurtas dalinai, taip pat tam, kad galėtume
    sukurti objektą, reikia turėti jo kūrimo planą, kuris vadinamas klase,
    arba objektą \en{prototype object}, kurį klonuosime;
  \item \en{may have state and this can be externally observable};
  \item \en{encapsulates its state and behavior}.
\end{itemize}

Komponentai, skirtingai nei
moduliai\cite[39-40]{cs-beyond-object-oriented-programming}:
\begin{itemize}
  \item gali būti parametrizuoti panaudojant resursus (pavyzdžiui,
    lokalizavimo taisyklės), moduliai turi tik tą informaciją, kuri
    buvo įrašyta (įkompiliuota) jų kode;
  \item neturi būsenos (moduliai gali turėti statinius kintamuosius).
\end{itemize}

\begin{defn}[Programinės įrangos komponentas]
  A software component is a unit of composition with contractually
  specified interfaces and explicit context dependencies only. A
  software component can be deployed independently and is subject
  to composition by third parties.
  \cite[41]{cs-beyond-object-oriented-programming}
% FIXME Pasitikrinti ar teisingai išverčiau.
% Komponavimo vienetas su kontraktu apibrėžtomis sąsajomis ir tik
% išreikštinai nurodytais reikalavimais. Komponentas gali būti
% naudojamas nepriklausomai ir įkomponuotas trečiųjų šalių.
\end{defn}

TODO: Perskaityti. (Dabar perskaityta 0-39, 69-79)

\section{Scalable Component Abstractions}

Bendrai komponentai yra tiesiog programos dalys, kurios gali būti
panaudotos kuriant didesnes dalis ar aplikacijas. Galimos įvairios
komponentų formos: moduliai, klasės, bibliotekos, karkasai, procesai
interneto servisai.

Komponento savybės:
\begin{itemize}
  \item svarbiausia komponento savybė yra galimybė jo nepakeitus jį
    panaudoti kitame kontekste, nei jis buvo kurtas;
  \item tam užtikrinti komponentai turi turėti sąsajas per kurias
    teikia ir gauna servisus, taip pat komponentai turėtų minimizuoti
    tvirtą susiejimą \en{hard links} su aplinka;
\end{itemize}

\begin{note}
  While these languages offer some support for attaching interfaces
  describing the provided services of a component, they lack the
  capability to abstract over the services that are required.
  \cite[1]{scalable-component-abstractions}
\end{note}

Servisinis komponentinis modelis \en{Service-Oriented Component Model}:
\begin{itemize}
  \item programinės įrangos komponentai yra skaičiavimo vienetai, kurie
    pateikia gerai apibrėžtą servisų aibę;
  \item jiems reikia kitų servisų, kuriuos teikia kiti komponentai;
  \item komponentas yra klasė (būtinas įdėtinių klasių palaikymas!);
  \item \en{concrete members} – kuriami servisai;
  \item \en{abstract members} – prašomi servisai;
  \item komponentų jungimas remiasi \en{mixins}.
\end{itemize}

Norint sukurti plečiamų \en{scalable} ir dinaminių \en{dynamic} komponentų
sistemas yra būtina (darome prielaida, jog kalba apie stipriai
\en{strongly} ir statiškai \en{statically} tipizuotas objektines
programavimo kalbas):
\begin{itemize}
  \item įdėtinių \en{nested} klasių palaikymas;
  \item \en{mixin} arba \en{trait} kompozicijos palaikymas arba
    multipaveldėjimas – būtina, kad klasėse, kaip nariai, galėtų
    būti aprašomi \en{mixin} arba klasės, bei, kad konkretūs klasės
    nariai pakeistų abstrakčius, nepriklausomai nuo to kokiu būdu
    buvo atliktas jungimas;
  \item galimybė abstrakčiai apibrėžti ko reikia klasei.
\end{itemize}

\begin{note}
  Komponentų dinaminis radimas ir platinimas nėra nagrinėjamas.
\end{note}

\section{Lessons learned through six years of component-based development}

Autorius komponentą apibrėžia taip\cite{Sparling:2000:LLT:352183.352202}:
\begin{defn}[Komponentas]
  Komponentas yra nuo programavimo kalbos nepriklausomas, nepriklausomai
  realizuotas programinės įrangos servisų paketas, pristatytas
  uždarame \en{encapsulated} ir pakeičiamame konteineryje, pasiekiamas
  per vieną ar daugiau viešų sąsajų.

  Nors komponentas gali turėti galimybę keisti duombazę, bet neturėtų
  būti tikimasi, kad jis turės būsenos informaciją. Komponentas nėra
  nei suvaržytas platformos \en{platform-constrained}, nei apribotas
  aplikacijos srities \en{application-bound}.
\end{defn}

\section{Component primer}

Autorius komponentą apibrėžia, kaip\cite{Hopkins:2000:CP:352183.352198}:
\begin{defn}[Komponentas]
  Programinės įrangos komponentas yra fizinis paketas, vykdomos
  \en{executable} programinės įrangos su gerai apibrėžtomis ir
  paviešintomis sąsajomis.
\end{defn}

Taip pat autorius pabrėžia, kad siekimas sukurti gerai apibrėžtas sąsajas,
nepriklausomas nuo jų realizacijos yra būtinas siekiant sukurti
„loosely coupled systems“.
(TODO: \url{http://en.wikipedia.org/wiki/Loose_coupling}.)

\section{Objects, Components and Frameworks with UML: The Catalysis
Approach}

Autoriai komponentą apibrėžia,
kaip\cite[385]{objects-components-and-frameworks-with-uml}:
\begin{defn}[Komponentas (bendrai)]
  Rišlus programinės įrangos artefaktų paketas, kuris gali būti
  nepriklausomai kuriamas ir pristatytas \en{delivered} kaip vienetas
  ir kuris gali būti įkomponuotas kartu su kitais komponentais siekiant
  sukurti kažką didesnio.
\end{defn}

Autoriai taip pat išskiria skirtingus komponentų tipus. Kodo komponentą
apibrėžia, kaip\cite[386]{objects-components-and-frameworks-with-uml}:
\begin{defn}[Komponentas (kode)]
  Rišlus programinės įrangos realizacijos \en{implementation} paketas,
  kuris:
  \begin{itemize}
    \item gali būti nepriklausomai kuriamas ir pristatytas \en{delivered};
    \item turi išreikštines ir gerai apibrėžtas sąsajas savo pateikiamiems
      servisams;
    \item turi išreikštines ir gerai apibrėžtas sąsajas servisams, kurių
      jis tikisi;
    \item gali būti sujungtas su kitais komponentais į vieną visumą,
      nedarant juose pakeitimų.
  \end{itemize}
\end{defn}

Taip pat autoriai pabrėžia, kad komponentas:
\begin{itemize}
  \item yra „pakavimo vienetas“ \en{a unit of packaging}%
    \cite[387]{objects-components-and-frameworks-with-uml};
  \item yra „nepriklausomo perdavimo vienetas“ \en{a unit of independent
    delivery}\cite[387]{objects-components-and-frameworks-with-uml};
  \item išreikštinai nurodo tiek kuriamus servisus, tiek jam
    reikalingus servisus (skirtingai nuo klasių, kurios išreikštinai
    nurodo tik teikiamus servisus):
\end{itemize}

TODO: Perskaityti. (Dabar perskaityta 384-393)

\section{Component-Based Measurement: Few Useful Guidelines}

Autoriai, išanalizavę įvairius komponento apibrėžimus, pateikė tokį,
apibendrintą, apibrėžimą \cite[2]{Gill:2003:CMF:966221.966237}.
\begin{defn}[Komponentas]
  Rišlus programinės įrangos realizacijos paketas, kuris:
  \begin{itemize}
    \item turi keletą tarpusavyje susijusių servisų ir funkcijų;
    \item siūlo gerai apibrėžtas ir viešas sąsajas;
    \item siūlo servisus, kurie yra pasiekiami tik per jo sąsajas;
    \item yra perpanaudojamas;
    \item gali būti nepriklausomai kuriamas ir pristatytas.
  \end{itemize}
\end{defn}

\section{Sutvarkyti}

TODO: „Component-oriented programming“ Andy Ju An Wang, Kai Qian:
\url{http://onlinelibrary.wiley.com/doi/10.1002/0471713708.fmatter/summary}

TODO: \url{http://en.wikipedia.org/wiki/Separation_of_concerns}
