\chapter{Objektinis programavimas}

Norint atskirti objektinę paradigmą nuo komponentinės, reikia
tiksliai apibrėžti, kas priklauso kiekvienai iš jų.
Šiame skyriuje pabandyta išskirti, kas yra objektinis programavimas
apskritai, kokios yra objektinio programavimo rūšys\NTODO{Nagrinėjant
Scala yra svarbu nurodyti ant kokio objektinio ji „stovi“.} bei kam
tos rūšys yra reikalingos (jų pritaikymo sritys)\NTODO{Nagrinėjant
Scala panagrinėti ar ji keičia pritaikymo sritį.}\NFIXME{Aurelijaus
pastaba: „Siūlau pradėti pastraipą nuo šito sakinio. Arba
„Objektinį programavimą skirtingi autoriai apibrėžia skirtingai
arba neišsamiai arba nepakankamai [Bla12; Bla13; Bla14]“}.

\section{Objektinio programavimo apibrėžimas}

\cite[225]{types-and-programming-languages} teigimu yra beprasmiška
bandyti tiksliai apibrėžti, ką reiškia „objektiškai orientuotas“,
bet objektinį programavimą bendrąja prasme galima suvokti, kaip
programavimą pasinaudojant objekto abstrakcija. Objektą galima
apibrėžti, kaip \inlinequote{esybę, kuri apjungia duomenų ir procedūrų
savybes tam, kad galėtų atlikti veiksmus ir turėti
būseną}\cite[41]{OOP-themes-and-variations}. Objektinės sistemos veikimas
yra suvokiamas, kaip objektų tarpusavio sąveika: objektai vienas kitam
siuntinėja žinutes, o kiekvienas gavęs žinutę objektas į ją sureaguoja
įvykdydamas atitinkamos procedūros (metodo)
kodą\cite[41]{OOP-themes-and-variations}%
\cite[277]{concepts-in-programming-languages}%
\cite[168]{Wegner:1987:DOL:38807.38823}.\NFIXME{Aurelijaus pastaba:
„Perskaičius pirmus sakinius man iš karto norėjosi išgirsti, kad
objektai visų pirma skirti darbui su savyje saugomais duomenimis.
Būsenos kažką į tą pusę sako, bet nepakankamai aiškiai
„tūlam“ skaitytojui. Tai būtų kaip „abstrakciją“
paaiškinimas, nes išreikštinio susiejimo su abstrakcijos formomis
taip iki pastraipos galo ir neradau. Kai matai, kad nesiskaito, dėk
pavyzdžius: procedūrinė (pvz., OpenGL) turi būsenų sistemą, bet
bendrą „RAM'ą“, o programuojant objektiškai kiekvienas gauna savo
gabalą ir daugiausia tik su tuo gabalu ir dirba. Su gabalais dirba ir
funkcinės programavimo kalbos, bet jos paima pradinę būseną ir
išspjauna galine (čia tinka tavo bendravimas žinutėmis). Kiek
supratau, ši mano rašliava pas tave atitinka „unikalią
tapatybę“, bet kadangi aš abejoju, tai reikės „unikalios
tapatybės“ paaiškinimo.“}
Be būsenos ir veiksenos\NFIXME{Aurelijaus pastaba: „low
suprantability. „veikimas“, „kodo dalių vykdymas“,
„paprogramių vykdymas“ (paprogramės įprastos informatikams, bet
pridėjus į žodyną, turėtų sueiti.“}, prie objekto išskirtinių
savybių \cite[37]{cs-beyond-object-oriented-programming} bei
populiariausių objektinių programavimo kalbų kūrėjai nurodo
dar ir tai, kad kiekvienas objektas turi unikalią tapatybę.
Taigi apibendrinant, objektai yra esybės, kurios:
\begin{enumerate}
  \item turi unikalią tapatybę;
  \item turi būsenas;
  \item sąveikauja besikeisdamos žinutėmis;
  \item reaguoja į žinutes įvykdydamos tam tikrą procedūrą.\NFIXME{
    Aurelijaus pastaba: „Pasižiūrėk skirtumus tarp procedūrų ir
    funkcijų. Nes „sąveikauja besikeisdamos žinutėmis“ tai man
    asocijuojasi su sekų diagramomis, taigi ir return (funkciškesniu)
    apibrėžimu. Čia tik tik pastebėjimas, jei prisikabintų per
    ginimus.“}
\end{enumerate}

Siekiant išskirti
\gls{object-oriented-programming-language}{objektines programavimo
kalbas} iš programavimo kalbų, kuriomis įmanoma programuoti
objektiškai (pavyzdžiui, tarę, kad programavimo kalbos \plangname{Modula-2}
modulis yra objektas, su ja galėtume programuoti objektiškai), yra
reikalaujama, kad programavimo kalba, kurią vadiname objektine
palaikytų objektinį programavimą kalbinėmis priemonėmis. 1987\NFIXME{
Aurelijaus pastaba: „Prie mano „istorinių faktų“ vadovas kibo,
klausė, „ar tai tiksliui/uždaviniams tikrai reikalinga“. Kadangi
su apimtimi problemos, tai siūlyčiau truputi įdėti beletristikos su
kalbų pavyzdžiais (kaip kas daro), taip ir suprantability turėtų
padidėti. Istoriniai faktai yra naudingi, jei yra žinomas kontekstas:
kokia situacija su kalbų įvairove buvo 1987 metais, kodėl svarbi ACM
(neinformatikui), OOPSLA (wtf?), Orlando susitikime (ar kas nors
pasikeistų, jei būtų „Kupiškio“)“}
metais ACM OOPSLA konferencijos metu paskelbtame „Orlando
susitarime“ \en{„The Treaty of Orlando“}
\cite{Lieberman:1987:TO:62139.62144} nurodoma, kad esminis
objektinių programavimo kalbų bruožas yra 
\gls{object-description-sharing-mechanism}{dalinimosi \en{sharing}
mechanizmas} – galimybė perpanaudoti esamų objektų apibrėžimų dalis
apibrėžiant naujus objektus.
\gls{object-oriented-programming-language}{Objektinės programavimo kalbos}
tai gali įgyvendinti panaudodamos \gls{delegation}{delegavimo} arba
\gls{class-inheritance}{paveldėjimo}
mechanizmus.\NFIXME{Ar reikia pavyzdžio su Python, kuris parodo, jog
paveldėjimas ir delegavimas yra tas pats
\cite[1]{Stein:1987:DI:38807.38820}?
(Jei $a$ yra klasės $A$ tipo
objektas, o klasė $A$ paveldi iš $B$, tai delegavimo ryšys būtų:
$a \to A \to B$, o \varname{self} yra tiesiog paprasčiausias
argumentas.)}
Šis mechanizmas yra itin svarbus tuo, kad leidžia objektus apibrėžti
palaipsniui. Taigi, \plangname{Modula-2} nėra objektinė programavimo
kalba, nes jos modulis negali automatiškai „perimti“ dalies kito modulio
veiksenos.
\TODO{Paminėti teiginį iš \cite{Wegner:1987:DOL:38765.38823}, kad
paveldėjimas yra delegavimo mechanizmo poaibis. Tai palengvintų
terminologiją. Bet tada netinka prototipinis su „deepcopy“?}

Be šios „Orlando susitarime“ nurodytos savybės, dauguma
objektinių programavimo kalbų turi ir daugiau bendrų bruožų,
kuriuos išskyrė \cite[225-227]{types-and-programming-languages}:
\begin{description}
  \item[\gls{dynamic-dispatch}{dinaminis susiejimas}] –
    objekto reakcija į gautą žinutę yra nustatoma vykdymo metu;
  \item[\gls{encapsulation}{uždarumas}] – vidinė objekto
    struktūra yra slepiama;
  \item[\gls{subtyping}{potipiai}] – kai norime pasinaudoti objektu, 
    tai mums rūpi tik jo sąsaja ir mes galime naudoti objektą $I$ vietoj
    objekto $J$, jei objekto $J$ sąsaja yra objekto $I$ sąsajos poaibis;
  \item[\gls{object-description-sharing-mechanism}{paveldėjimas,
    pavedimas}] – galimybė perpanaudoti jau egzistuojantį kodą: tai
    gali būti pasiekiama objektų kūrimui naudojant klases, kurios
    gali paveldėti kai kurias savybes iš tėvinių klasių, arba
    naudojant žinučių persiuntimą;
  \item[\gls{open-recursion}{atvira rekursija}] –
    (dažniausiai jis vadinamas „this“, arba „self“)
    egzistavimas, kuriuo pasinaudojant galima kreiptis į kitus to
    paties objekto metodus.
\end{description}
Nors paminėtos savybės ir yra bendros populiariausioms objektinėms
programavimo kalboms, bet\NFIXME{Aurelijaus pastaba: „Paįvairink
jungtukus, pradeda atsibosti...
\url{http://ualgiman.dtiltas.lt/jungtukas.html}} jos jas
\NFIXME{Aurelijaus pastaba: „Blogai. Įvardžius reikia vartoti labai
atsargiai, nes per gynimus mėgsta tokiu būtu suvar(t)inėti. Siūloma
didelio įvardžių kiekio (bent jau 2 viename) vengti. Geriau
sinonimus.} įgyvendina įvairiais būdais, dėl ko jos įgauna
savitumų, kurie daro įtaką šių programavimo kalbų galimoms
pritaikymo sritims.

\section{Objektinių kalbų rūšys}

Objektinės programavimo kalbos yra naudojamos įvairioms situacijoms:
tiek eksperimentiniam, tiriamajam bei prototipiniam programavimui, kai
dalykinė sritis yra prastai žinoma ir yra svarbus lankstumas, tiek
jau produkcijai skirtoms sistemoms, kurios palyginus
lėtai keičiasi ir kurių patikimumas yra itin
svarbus\cite{Lieberman:1987:TO:62139.62144}\NFIXME{
Aurelijaus pastaba: „4 eilutės 1-nam sakiniui „politiko“ stilius.
Pabadyk išvardyti viską trumpai, o pridėtinus (šalutinius) sakinius
parašyk po to.“}. Pagal \cite{Lieberman:1987:TO:62139.62144}\NFIXME{
Aurelijaus pastaba: „Pagal pirmuoju“ Ir šiaip, jei jau pradedi
plačiai rašyti, tai gražu būtų ir naujoje pastraipoje“} pirmuoju
atveju lankstumą suteikia galimybės\NFIXME{Aurelijaus pastaba:
„Nors taupom popierių, man gražiau skambėtų suteikia: [ENTER]“}:
\begin{itemize}
  \item modifikuoti atskiro objekto veikseną – pavyzdžiui, vienam
    konkrečiam objektui pridėti naują metodą;
  \item keisti \gls{object-description-sharing-mechanism}{dalinimosi
    mechanizmo} ryšius vykdymo metu – pavyzdžiui, pakeisti tėvinį
    objektą;
  \item išreikštinai nurodyti
    \gls{object-description-sharing-mechanism}{dalinimosi mechanizmo}
    ryšius – pavyzdžiui, kokios žinutės kokiam objektui yra
    persiunčiamos.
\end{itemize}
Šiomis savybėmis pasižymi
\gls{prototype-based-programming-language}{prototipinės objektinės
programavimo kalbos}, iš kurių, turbūt, populiariausia atstovė yra
\plangname{JavaScript}.

Kuriamų sistemų patikimumą padeda užtikrinti tokios programavimo
kalbos savybės, kaip:
\begin{itemize}
  \item galimybė užtikrinti, kad visi konkrečiai grupei priklausantys
    objektai elgsis vienodai \NFIXME{Aurelijaus pastaba: „Pridėk,
    „pvz, tai realizuojama gali būti realziuota klasėmis“.  Nes
    turi praeiti keli suprantability ciklai, kol „until sąlyga tampa
    patenkinta.“};
  \item draudimas keisti objekto apibrėžimą po jo sukūrimo – tai
    gali būti naudinga, pavyzdžiui, tuo, kad yra garantuojama,
    jog objektas tenkina tą patį kontraktą, kurį jis tenkino iš
    karto po sukūrimo;\NFIXME{Aurelijaus pastaba: „O ar yra kas, kas
    keičia apibrėžimą po sukūrimo?  Netipizuotos kalbos,
    reflectionai, dinaminiai metodai
    (\url{http://www.php.net/manual/en/language.oop5.magic.php})“}
  \item vieningas \gls{object-description-sharing-mechanism}{
    apibrėžimų dalinimosi mechanizmas}, kuris palengvina supratimą
    kaip veikia sistema.
\end{itemize}
Šiomis savybėmis pasižymi
\gls{class-based-programming-language}{klasinės objektinės
programavimo kalbos}, tokios, kaip \plangname{Java}, \plangname{C++},
\plangname{Python}, \plangname{Ruby}.

Kaip pavyzdys situacijos, kur prototipinės objektinės programavimo
kalbos savybės yra naudingesnės nei klasinės objektinės, galėtų
būti natūralios žmonių kalbos sintezatoriaus kūrimas. Tarkime, kad
mums reikia galimybės turint veiksmažodžio bendratį susigeneruoti
visas jo formas. Naudodami klasinę objektinę programavimo kalbą
kiekvienai veiksmažodžių rūšiai galėtume susikurti po klasę,
kuri gavusi bendratį mokėtų sugeneruoti tos rūšies veiksmažodžių
formas. Problema ta, kad natūralios žmonių kalbos pasižymi didele
išimčių gausa ir šiuo atveju kiekvienai išimčiai irgi reikėtų
sukurti po klasę. Jei naudotume prototipinę objektinę programavimo
kalbą, tai kiekvieną kartą pridėdami po naują veiksmažodžio
objektą, jam kaip prototipą galėtume nurodyti panašiausią į jį ir
tereikėtų perrašyti tik jų skirtumus.

Pagal \cite[2]{Madsen:1990:STO:97946.97964}, programavimo kalbų
lankstumą dar padidina \gls{weakly-typed-programming-language}{silpna
tipizacija} bei \gls{dynamically-typed-programming-language}{dinaminis
tipų tikrinimo mechanizmas}. Tuo tarpu
\gls{strongly-typed-programming-language}{stipri tipizacija} bei
\gls{statically-typed-programming-language}{statinis tipų tikrinimo
mechanizmas} leidžia nemažai klaidų surasti dar programos kompiliavimo
stadijoje, kas padidina programos patikimumą. Taigi siekiant kurti
sistemas, kurioms yra itin svarbus jų patikimumas, derėtų naudoti
\gls{statically-typed-programming-language}{statines}
\gls{strongly-typed-programming-language}{stipriai tipizuotas}
\gls{class-based-programming-language}{klasines} programavimo kalbas.
Kadangi šiame darbe yra nagrinėjamos priemonės, kurios pagelbėtų
kuriant verslo palaikymo sistemas, kurioms ir yra itin svarbus
patikimumo kriterijus, tai toliau darbe yra nagrinėjamos tik
\gls{statically-typed-programming-language}{statinės}
\gls{strongly-typed-programming-language}{stipriai tipizuotos}
\gls{class-based-programming-language}{klasinės}
\gls{object-oriented-programming-language}{objektinės} programavimo
kalbos.

\FIXME{Aurelijaus pastaba: „Loginė slinktis: eksperimentinis,
tiramosios, prototipinės ->  Prototipinės, klasinės [norėtųsi
susieti su eksperimentinėmis arba tiriamosiomis], [vėl] prototipinės,
tipizacija~lankstumas. Minčių šokinėjimas blogiau nei vidurkis :(“}
