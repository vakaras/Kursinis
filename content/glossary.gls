# vim: ft=python
[
    {
        'id': 'evolutionary-software-development-process',
        'lang': {
            'lt': 'evoliucinis programinės įrangos kūrimo procesas',
            'en': 'evolutionary software development process',
            },
        'long': '''
            Procesas, kurio metu programinė įranga papildoma nauju
            funkcionalumu, neliečiant jau egzistuojančio.
          ''',
    },
    {
        'id': 'component-oriented-software-development',
        'lang': {
            'lt': 'komponentinis programinės įrangos kūrimas',
            'en': 'component oriented software development',
            },
        'long': '''
            Programinės įrangos kūrimo būdas, kai ji yra surenkama
            iš atskirų, išreikštinai nesusijusių gabalų, kurie yra
            vadinami komponentais.
            '''
    },
    {
        'id': 'trait',
        'lang': {
            'lt': 'fragmentas',
            'en': 'trait',
            },
        'short': r'''
            Programavimo kalbos Scala konstrukcija. Scala
            fragmentai nuo Java sąsajų skiriasi tuo, kad gali turėti
            metodų realizacijas. Taigi tuo jie primena abstrakčias
            klases, bet nuo pastarųjų skiriasi tuo, kad jų
            konstruktoriai negali turėti parametrų.
          ''',
        'long': r'''
            Programavimo kalbos \gls{scala}{Scala} konstrukcija. Scala
            fragmentai nuo Java sąsajų skiriasi tuo, kad gali turėti
            metodų realizacijas. Taigi tuo jie primena abstrakčias
            klases, bet nuo pastarųjų skiriasi tuo, kad jų
            konstruktoriai negali turėti parametrų.
          ''',
    },
    {
        'id': 'scala',
        'lang': {
            'lt': 'Scala',
            },
        'url': r'http://www.scala-lang.org',
        'long': '''
            Multiparadigminė programavimo kalba.
            ''',
    },
    {
        'id': 'abstract-type-member',
        'lang': {
            'lt': 'abstraktus tipas-atributas',
            'en': 'abstract type member',
            },
        'short': r'''
            Abstraktūs tipai, kaip atributai yra objektiškai
            orientuota Scala konstrukcija, kuri leidžia
            abstrahuotis nuo komponento funkcionavimui reikalingų
            komponentų.
            ''',
        'long': r'''
            Abstraktūs tipai, kaip atributai yra objektiškai
            orientuota \gls{scala}{Scala} konstrukcija, kuri leidžia
            abstrahuotis nuo komponento funkcionavimui reikalingų
            komponentų. Plačiau jie aprašyti \cite[8]{scala-overview}.
            ''',
    },
    {
        'id': 'selftype-annotation',
        'lang': {
            'lt': 'savo tipo anotacija',
            'en': 'selftype annotation',
            },
        'short': r'''
            Scala konstrukcija leidžianti specialiajam
            kintamajam this priskirti kitą tipą.
            ''',
        'long': r'''
            \gls{scala}{Scala} konstrukcija leidžianti specialiajam
            kintamajam \varname{this} priskirti kitą tipą.
            '''
    },
    {
        'id': 'modular-mixin-composition',
        'lang': {
            'lt': 'modulinė maišos kompozicija',
            'en': 'modular mixin composition',
            },
        'short': r'''
            Komponentų jungimo būdas realizuotas programavimo kalboje
            Scala.
            ''',
        'long': r'''
            Komponentų jungimo būdas realizuotas programavimo kalboje
            \gls{scala}{Scala}.
            ''',
    },
    {
        'id': 'statically-typed-programming-language',
        'lang': {
            'lt': 'statiškai tipizuota programavimo kalba',
            'en': 'statically typed programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Static_typing\#Static_typing',
        'short': r'''
            Programavimo kalba, kurioje tipų patikrinimas yra
            atliekamas kompiliavimo metu.
            ''',
        'long': r'''
            Programavimo kalba, kurioje tipų patikrinimas yra
            atliekamas kompiliavimo metu.
            \cite[2]{Madsen:1990:STO:97946.97964}
            ''',
    },
    {
        'id': 'dynamically-typed-programming-language',
        'lang': {
            'lt': 'dinamiškai tipizuota programavimo kalba',
            'en': 'dynamically typed programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Dynamic_typing\#Dynamic_typing',
        'short': r'''
            Programavimo kalba, kurioje tipų patikrinimas yra
            atliekamas vykdymo metu. Kalbose, kurios naudoja dinaminį
            tipų tikrinimą, tipus turi turi reikšmės, o ne
            kintamieji.
            ''',
        'long': r'''
            Programavimo kalba, kurioje tipų patikrinimas yra
            atliekamas vykdymo metu
            \cite[2]{Madsen:1990:STO:97946.97964}. Kalbose, kurios
            naudoja dinaminį tipų tikrinimą, tipus turi turi
            reikšmės, o ne kintamieji.
            ''',
    },
    {
        'id': 'class-based-programming-language',
        'lang': {
            'lt': 'klasinė programavimo kalba',
            'en': 'class based programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Class-based_programming',
        'short': r'''
            Objektinė programavimo kalba, kurioje objektai yra apibrėžiami,
            kaip klasių egzemplioriai. Pavedimas yra pasiekiamas
            pasinaudojant klasių paveldėjimo konstrukciją.
            ''',
        'long': r'''
            \gls{object-oriented-programming-language}{Objektinė
            programavimo kalba}, kurioje objektai yra apibrėžiami,
            kaip klasių egzemplioriai. \TODO{Pavedimas} yra pasiekiamas
            pasinaudojant klasių paveldėjimo konstrukciją.
            ''',
    },
    {
        'id': 'prototype-based-programming-language',
        'lang': {
            'lt': 'prototipinė programavimo kalba',
            'en': 'prototype based programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Prototype-based_programming',
        'short': r'''
            Objektinė programavimo kalba, kurioje objektai yra apibrėžiami,
            nukopijuojant jau egzistuojančių objektų, kurie yra
            vadinami prototipais, apibrėžimus arba nurodant, kad
            objektui neradus, kaip jis turėtų apdoroti gautąją
            žinutę, ji turėtų būti persiųsta jo prototipui.
            ''',
        'long': r'''
            \gls{object-oriented-programming-language}{Objektinė
            programavimo kalba}, kurioje objektai yra apibrėžiami,
            nukopijuojant jau egzistuojančių objektų, kurie yra
            vadinami prototipais, apibrėžimus arba nurodant, kad
            objektui neradus, kaip jis turėtų apdoroti gautąją
            žinutę, ji turėtų būti persiųsta jo
            prototipui. \cite[176]{Wegner:1987:DOL:38807.38823}
            ''',
    },
    {
        'id': 'object-oriented-programming-language',
        'lang': {
            'lt': 'objektiškai orientuota programavimo kalba',
            'en': 'object oriented programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Object_oriented',
        'short': r'''
            Programavimo kalba, su kuria galima programuoti
            pasinaudojant objekto abstrakcija bei kurioje yra
            realizuotas objektų apibrėžimų dalinimosi mechanizmas.
            ''',
        'long': r'''
            Programavimo kalba, su kuria galima programuoti
            pasinaudojant objekto abstrakcija bei kurioje yra
            realizuotas
            \gls{object-description-sharing-mechanism}{objektų
            apibrėžimų dalinimosi mechanizmas}.
            ''',
    },
    {
        'id': 'object-description-sharing-mechanism',
        'lang': {
            'lt': 'objekto aprašymo dalinimosi mechanizmas',
            'en': 'object description sharing mechanism',
            },
        'short': r'''
            Mechanizmas leidžiantis egzistuojančių objektų
            apibrėžimus panaudoti apibrėžiant naujus objektus.
            Objektinėse programavimo kalbose tai gali būti realizuota, kaip
            delegavimas arba klasių paveldėjimas.
            ''',
        'long': r'''
            Mechanizmas leidžiantis egzistuojančių objektų
            apibrėžimus panaudoti apibrėžiant naujus objektus.
            \gls{object-oriented-programming-language}{Objektinėse
            programavimo kalbose} tai gali būti realizuota, kaip
            \gls{delegation}{delegavimas} arba
            \gls{class-inheritance}{klasių paveldėjimas}.
            ''',
    },
    {
        'id': 'delegation',
        'lang': {
            'lt': 'delegavimas',
            'en': 'delegation',
            },
        'short': r'''
            Objektų apibrėžimų dalinimosi mechanizmas, kai naujas objektas
            yra apibrėžiamas pasinaudojant jau egzistuojančio objekto
            apibrėžimu. Šis mechanizmas vadinamas delegavimu, nes
            neradus žinutę atitinkančio metodo ji yra persiunčiama
            (deleguojama) tėviniam objektui.
            ''',
        'long': r'''
            \gls{object-description-sharing-mechanism}{Objektų
            apibrėžimų dalinimosi mechanizmas}, kai naujas objektas
            yra apibrėžiamas pasinaudojant jau egzistuojančio objekto
            apibrėžimu. Šis mechanizmas vadinamas delegavimu, nes
            neradus žinutę atitinkančio metodo ji yra persiunčiama
            (deleguojama) tėviniam objektui.
            ''',
    },
    {
        'id': 'class-inheritance',
        'lang': {
            'lt': 'klasių paveldėjimas',
            'en': 'class inheritance',
            },
        'short': r'''
            Objektų apibrėžimų dalinimosi mechanizmas, kai kiekvienas
            objektas yra laikomas kokios nors klasės egzemplioriumi
            (tai yra, jis apibrėžiamas pasinaudojant klase), o klasės
            gali paveldėti savybes vienos iš kitų.
            ''',
        'long': r'''
            \gls{object-description-sharing-mechanism}{Objektų
            apibrėžimų dalinimosi mechanizmas}, kai kiekvienas
            objektas yra laikomas kokios nors klasės egzemplioriumi
            (tai yra, jis apibrėžiamas pasinaudojant klase), o klasės
            gali paveldėti savybes vienos iš kitų.
            ''',
    },
    {
        'id': 'strongly-typed-programming-language',
        'lang': {
            'lt': 'stipriai tipizuota programavimo kalba',
            'en': 'strongly typed programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Strong_typing',
        'short': r'''
            Tipizacijos stiprumas yra tai, kokį kiekį informacijos
            turi konkrečios išraiškos tipas. Idealiu atveju stipriai
            tipizuotoje kalboje iš nuorodos į objektą tipo visada
            galima pasakyti kokias žinutes galima siųsti tam
            objektui.
            ''',
        'long': r'''
            Tipizacijos stiprumas yra tai, kokį kiekį informacijos
            turi konkrečios išraiškos tipas. Idealiu atveju stipriai
            tipizuotoje kalboje iš nuorodos į objektą tipo visada
            galima pasakyti kokias žinutes galima siųsti tam
            objektui. \cite[1]{Madsen:1990:STO:97946.97964}
            ''',
    },
    {
        'id': 'weakly-typed-programming-language',
        'lang': {
            'lt': 'silpnai tipizuota programavimo kalba',
            'en': 'weakly typed programming language',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Strong_typing',
        'short': r'''
            Tipizacijos stiprumas yra tai, kokį kiekį informacijos
            turi konkrečios išraiškos tipas. Silpnai tipizuotoje
            kalboje neįmanoma nustatyti kokias žinutes galima siųsti
            objektui iš nuorodos į jį tipo.
            ''',
        'long': r'''
            Tipizacijos stiprumas yra tai, kokį kiekį informacijos
            turi konkrečios išraiškos tipas. Silpnai tipizuotoje
            kalboje neįmanoma nustatyti kokias žinutes galima siųsti
            objektui iš nuorodos į jį
            tipo. \cite[1]{Madsen:1990:STO:97946.97964}
            ''',
    },
    {
        'id': 'dynamic-dispatch',
        'lang': {
            'lt': 'dinaminis susiejimas',
            'en': 'dynamic dispatch, dynamic binding',
            },
        'wikipedia': r'http://en.wikipedia.org/wiki/Dynamic_dispatch',
        'short': r'''
            Nusprendimo, kokią procedūrą vykdyti gavus žinutę,
            procesas, atliekamas programos vykdymo metu.
            ''',
        'long': r'''
            Nusprendimo, kokią procedūrą vykdyti gavus žinutę,
            procesas, atliekamas programos vykdymo metu.
            \cite[225]{types-and-programming-languages}
            ''',
    },
    {
        'id': 'encapsulation',
        'lang': {
            'lt': 'uždarumas',
            'en': 'encapsulation',
            },
        'short': r'''
            Savybė, kai vidinė objekto struktūra yra slepiama nuo
            išorės naudotojų.
            ''',
        'long': r'''
            Savybė, kai vidinė objekto struktūra yra slepiama nuo
            išorės naudotojų.
            \cite[225]{types-and-programming-languages}
            ''',
    },
    {
        'id': 'subtyping',
        'lang': {
            'lt': 'potipiai',
            'en': 'subtyping',
            },
        'short': r'''
            Objektinės programavimo kalbos savybė, kai norint
            pasinaudoti objektu mums rūpi tik jo sąsaja ir mes galime
            naudoti objektą I vietoj objekto J, jei objekto J sąsaja
            yra objekto I sąsajos poaibis.
            ''',
        'long': r'''
            \gls{object-oriented-programming-language}{Objektinės
            programavimo kalbos} savybė, kai norint pasinaudoti objektu
            mums rūpi tik jo sąsaja ir mes galime naudoti objektą $I$
            vietoj objekto $J$, jei objekto $J$ sąsaja yra objekto $I$
            sąsajos poaibis.
            \cite[226]{types-and-programming-languages}
            ''',
    },
    {
        'id': 'open-recursion',
        'lang': {
            'lt': 'atvira rekursija',
            'en': 'open recursion',
            },
        'short': r'''
            Specialaus kintamojo (dažniausiai jis vadinamas this, arba
            self) egzistavimas, kuriuo pasinaudojant galima kreiptis į
            kitus to paties objekto metodus.
            ''',
        'long': r'''
            Specialaus kintamojo (dažniausiai jis vadinamas
            \varname{this}, arba \varname{self}) egzistavimas, kuriuo
            pasinaudojant galima kreiptis į kitus to paties objekto
            metodus. \cite[226]{types-and-programming-languages}
            ''',
    },
    {
        'id': 'component-instance',
        'lang': {
            'lt': 'komponento egzempliorius',
            'en': 'component instance',
            },
        'long': r'''
            Komponento inicializacijos rezultatas. Vertėtų atkreipti
            dėmesį, kad komponento įdiegimas tai yra procedūra, po
            kurios pats komponentas tampa pasiekiamas sistemoje. Tai
            nėra jo inicializavimas.
            ''',
    },
    {
        'id': 'extra-functional-properties',
        'lang': {
            'lt': 'ekstra-funkcinės savybės',
            'en': 'extra-functional properties',
            },
        'long': r'''
            Tai yra ne funkcinės sistemos savybės, tokios kaip
            patikimumas, užduočių įvykdymo greitis, sunaudojamas
            resursų kiekis, apkrovos paskirstymas, autentifikacija ir
            t.t.
            ''',
    },
    {
        'id': 'vertical-binding',
        'lang': {
            'lt': 'vertikalus saistymas',
            'en': 'vertical binding',
            },
        'short': r'''
            Komponentinis modelis palaiko vertikalų saistymą tada, kai
            sujungus komponentus gautas ansamblis turi sąsają, kuri
            yra sujungtų komponentų sąsajų kompozicijos rezultatas,
            ir ta sąsaja atitinka komponentinio modelio keliamus
            reikalavimus.
            ''',
        'long': r'''
            Pagal \cite[598]{classification-framework-for-scm}
            komponentinis modelis palaiko vertikalų saistymą tada, kai
            sujungus komponentus gautas ansamblis turi sąsają, kuri
            yra sujungtų komponentų sąsajų kompozicijos rezultatas,
            ir ta sąsaja atitinka komponentinio modelio keliamus
            reikalavimus.
            ''',
    },
    {
        'id': 'vertical-composition',
        'lang': {
            'lt': 'vertikali kompozicija',
            'en': 'vertical composition',
            },
        'short': r'''
            Komponentinis modelis palaiko vertikalią kompoziciją tada,
            kai jis palaiko vertikalų saistymą ir kai sujungus
            komponentus gauto ansamblio savybės tenkina komponentinio
            modelio komponentams keliamus reikalavimus. Kitaip tariant
            komponentinis modelis palaiko vertikalią kompoziciją tada,
            kai komponentų kompozijos rezultatas yra komponentas.
            ''',
        'long': r'''
            Pagal \cite[599]{classification-framework-for-scm}
            komponentinis modelis palaiko vertikalią kompoziciją tada,
            kai jis palaiko \gls{vertical-binding}{vertikalų saistymą}
            ir kai sujungus komponentus gauto ansamblio savybės tenkina
            komponentinio modelio komponentams keliamus reikalavimus.
            Kitaip tariant komponentinis modelis palaiko vertikalią
            kompoziciją tada, kai komponentų kompozijos rezultatas yra
            komponentas.
            ''',
    },
    {
        'id': 'polymorphism',
        'lang': {
            'lt': 'polimorfismas',
            'en': 'polymorphism',
            },
        'wikipedia': [
            r'http://en.wikipedia.org/wiki/Polymorphism_(computer_science)',
            r'http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming',
            ],
        'short': r'''
            Programavimo kalbos savybė, kuri leidžia su skirtingų
            tipų duomenimis dirbti naudojantis ta pačia sąsaja.
            ''',
        'long': r'''
            Programavimo kalbos savybė, kuri leidžia su skirtingų
            tipų duomenimis dirbti naudojantis ta pačia sąsaja.
            Išskiriami trys polimorfizmo tipai:
            \begin{itemize}
              \item \emph{Ad-hoc} polimorfizmas \en{Ad-hoc polymorphism} –
                  iš esmės, tai yra funkcijų perdengimas;
              \item parametrinis polimorfizmas \en{parametric
                  polymorphism} – programuojama taip, kad kodas
                  nepriklausytų nuo duomenų tipo (pavyzdys būtų C++
                  šablonai ir Java generics);
              \item potipio polimorfizmas \en{subtype polymorphism} –
                    jei $T$ yra $S$ potipis, tai $T$ galima naudoti
                    vietoje $S$.
            \end{itemize}
            ''',
    },
    {
        'id': 'method-overriding',
        'lang': {
            'lt': 'metodo užklotis',
            'en': 'method overriding',
            },
        'long': r'''
            Objektinės programavimo kalbos savybė, kuri leidžia
            paveldinčiai klasei realizuoti metodą, kurį jau yra
            realizavusi kažkuri iš jos tėvinių klasių.
            Paveldinčios klasės metodo realizacija užkloja (paslepia)
            tėvinės klasės metodą.
            ''',
    },
    {
        'id': 'function-overloading',
        'lang': {
            'lt': 'funkcijos perdengimas',
            'en': 'function overloading',
            },
        'long': r'''
            Programavimo kalbos savybė, kuri leidžia aprašyti kelias
            funkcijas turinčias tą patį vardą, kurios yra
            atskiriamos pagal jų argumentų tipus.
            ''',
    },
    {
        'id': 'nested-class',
        'lang': {
            'lt': 'įdėtinė klasė',
            'en': 'nested class, static inner class',
            },
        'short': r'''
            Java kalboje, tai klasė apibrėžta kitos klasės viduje,
            bet kurios objekto sukūrimui nėra būtinas gaubiančiosios
            klasės objektas. Ji apibrėžiama su static konstrukcija.
            Scala neturi įdėtinių klasių.
            ''',
        'long': r'''
            Java kalboje, tai klasė apibrėžta kitos klasės viduje,
            bet kurios objekto sukūrimui nėra būtinas gaubiančiosios
            klasės objektas. Ji apibrėžiama su \varname{static}
            konstrukcija. Scala neturi įdėtinių klasių.
            ''',
    },
    {
        'id': 'inner-class',
        'lang': {
            'lt': 'vidinė klasė',
            'en': 'inner class',
            },
        'long': r'''
            Java kalboje, tai klasė apibrėžta kitos klasės viduje.
            Jos objekto sukūrimui yra būtinas gaubiančiosios klasės
            objektas.  Scala kalboje visos klasės apibrėžtos kitų
            klasių viduje yra vidinės klasės.
            ''',
    },
    #{
        #'id': '<++>',
        #'lang': {
            #'lt': '<++>',
            #'en': '<++>',
            #},
        #'wikipedia': r'<++>',
        #'long': r'''
            #''',
    #},
]
