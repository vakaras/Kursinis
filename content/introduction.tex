\chapter{Įvadas}

Programinės įrangos naudojimas nuo pat jos atsiradimo nuolat auga,
verslo palaikymo sistemos perima vis daugiau verslo funkcijų, todėl
jos tampa vis didesnės ir tuo pačiu vien dėl savo dydžio tampa
sudėtingos. Be to, verslo poreikiai nuolat kinta, o kartu su jais
ir programų sistemoms keliami reikalavimai. Esant tokiai situacijai
atsiranda noras turėti priemones, kurios leistų susitvarkyti
su problemomis atsirandančiomis dėl kuriamų sistemų dydžio. Kitaip
tariant, norisi turėti priemones, kurios:
\begin{itemize}
  \item leistų kurti dideles sistemas
    \gls{evolutionary-software-development-process}{evoliuciniu būdu};
  \item leistų darbus efektyviai paskirstyti didelei grupei žmonių.
\end{itemize}

Viena iš šias galimybes žadančių priemonių yra
\gls{component-oriented-software-development}{komponentinis programavimas}.
\NFIXME{Aurelijaus pastaba: „Susidaro įvaizdis, kad svarbiau galimybė,
o ne problemos, apibendrintos šiomis galimybėmis (gal geriau savybės,
o ne galimybės)“. Nebūčiau linkęs „galimybės“ keisti į „savybes“,
nes priemonės turi savybes, bet jų nežada. O čia būtent žada, nes ką
duoda, tai jau bus prie išvadų.}
Idealiu atveju komponentinis sistemų kūrimo būdas yra veikiančios
sistemos surinkimas iš trečiųjų šalių sukurtų dalių –
komponentų, kurie yra tarpusavyje nepriklausomi. (Nepriklausomi ta
prasme, kad jokio komponento veikimui nereikia jokio kito konkretaus
komponento, tačiau jam gali reikėti komponento tenkinančio tam
tikras savybes.) Taigi, dėl komponentų nepriklausomumo, kiekvieną iš
komponentų galėtų kurti atskira komanda, kas leistų sistemos kūrimu
užsiimti palyginti didelei grupei žmonių. Taip pat, komponentinėje
sistemoje vieną komponentą galima pakeisti kitu neperdarant visos
sistemos, kas leidžia vystyti sistemą
\gls{evolutionary-software-development-process}{evoliuciniu būdu}%
\cite[6]{cs-beyond-object-oriented-programming}. Be paminėtų,
komponentinis sistemų kūrimas turi dar ir tą privalumą, kad tuos
pačius komponentus galima panaudoti keliose skirtingose sistemose, kas
leidžia sumažinti kuriamų sistemų
kainą\cite[6]{cs-beyond-object-oriented-programming}.

Programavimo kalbos \gls{scala}{\plangname{Scala}} autoriaus \human{Martin'o
Odersky} teigimu komponentinių technologijų plitimui trukdo
tai, kad dabartinėse programavimo kalbose trūksta priemonių leidžiančių
apibrėžti ir sujungti komponentus\cite{odersky:scala-experiment}.
Populiariausios šiuo metu naudojamos programavimo kalbos turi galimybes
išreikštinai nurodyti komponentų teikiamas paslaugas, bet neturi
galimybės išreikštinai nurodyti, kokių paslaugų
komponentui reikia. Dėl šios priežasties paslaugų naudotojai dažnai
būna pririšami prie konkrečių paslaugų teikėjų, pavyzdžiui,
bibliotekų\cite{scalable-component-abstractions}. Taip pat, norint
su dabartinėmis sistemomis programuoti komponentiškai reikia
tam naudoti specialius karkasus, dėl ko dažnai tenka rašyti
nemažai palaikančio \en{boilerplate} kodo, arba naudoti
metaprogramavimą\NTODO{Metaprogramavimas yra blogai tuo, kad jį
yra sunku „patikrinti“. Iš statinės programavimo kalbos mes tikimės
stabilumo, o naudodami metaprogramavimą, mes realiai bandom apeiti
stabilumą užtikrinančius įrankius. Naudodami metaprogramavimą
mes pakeičiam „normalią“ elgseną, kurios galbūt tikisi kitos sistemos
dalį.}\cite{extensible-software-components}.

\gls{scala}{\plangname{Scala}} kūrėjai pasiūlė pastarąsias
dabartinių programavimo kalbų problemas spręsti
\gls{statically-typed-programming-language}{statinę}
\gls{class-based-programming-language}{klasinę}
\TODO{gls:objektinę} programavimo kalbą papildydami naujomis
savybėmis\cite{scalable-component-abstractions}:
\begin{itemize}
  \item \gls{abstract-type-member}{abstrakčiais tipais-atributais};
  \item \gls{selftype-annotation}{savo tipo anotacija};
  \item \gls{modular-mixin-composition}{moduline maišos kompozicija}.
\end{itemize}
Jų teigimu\cite[1]{scalable-component-abstractions} šių trijų savybių
pridėjimas įgalina programuoti komponentiškai.

Šio darbo tikslas yra patikrinti ar šis \gls{scala}{\plangname{Scala}}
kūrėjų teiginys, jog su \gls{scala}{\plangname{Scala}} yra įmanoma
programuoti komponentiškai, yra teisingas.

Darbo tikslo bus siekiama įgyvendinant šiuos uždavinius:
\begin{enumerate}
  \item \label{introduction:task:object-oriented-programming}
    apibrėžti, kas yra objektinis programavimas;
  \item išsiaiškinti, kas yra komponentinis programavimas, kokios
    yra jį išskiriančios (privalomosios) savybės;
  \item pagal išskirtąsias savybes patikrinti ar su
    \gls{scala}{\plangname{Scala}} galima programuoti komponentiškai;
  \item jei su \gls{scala}{\plangname{Scala}} yra įmanoma programuoti
    komponentiškai, tai išsiaiškinti kokie yra
    \gls{scala}{\plangname{Scala}} komponentinės technologijos
    privalumai lyginant su objektiniu programavimu bei su kitomis
    komponentinėmis technologijomis.
\end{enumerate}
\emph{Pastabos:}
\begin{enumerate}
  \item \ref{introduction:task:object-oriented-programming}
    uždavinio rezultatas yra svarbus norint pilnai suvokti kaip būtent
    \gls{scala}{\plangname{Scala}} autoriai pakeitė objektinį programavimo
    modelį, kad iš jo gautų komponentinį, bei siekiant suprasti kuo
    susijęs objektinis su komponentiniu.
  \item Kadangi \gls{scala}{\plangname{Scala}} yra susijusi su
    \plangname{Java} (iš \gls{scala}{\plangname{Scala}} kodo galima
    kviesti \plangname{Java} kodą ir atvirkščiai), tai šiame darbe,
    kaip pagrindinė \gls{statically-typed-programming-language}{statinių}
    \gls{class-based-programming-language}{klasinių}
    \TODO{gls:objektinių} programavimo kalbų atstovė imama
    \plangname{Java}.
\end{enumerate}

Darbas suskirstytas į tris skyrius: pirmajame skyriuje surinkti
įvairūs objektinio programavimo apibrėžimai bei apibrėžta kas
yra statinis klasinis objektiškai orientuotas programavimas.
Antrajame apibrėžta kas yra komponentas bei kas yra komponentinis modelis.
Trečiajame skyriuje pristatomos galimybės, kuriomis \plangname{Scala}
papildė statines klasines objektines programavimo kalbas, tokias
kaip \plangname{Java}. Tada remiantis komponento apibrėžimu patikrinama, ar
su \plangname{Scala} iš tiesų galima programuoti komponentiškai bei
pateikiama keletas pavyzdžių, parodančių
\gls{scala}{\plangname{Scala}} privalumus.

\chapter{Išvados}

Šiame darbe buvo apibrėžta kas yra komponentinis modelis ir parodyta,
jog Scala autorių teiginys, jog su Scala galima programuoti
komponentiškai yra teisingas.

\chapter{Neišnagrinėti klausimai}

Komponentų vykdymo aplinka. Komponento konteineris. Galimybė vieną
komponentą pakeisti kitu vykdymo metu bei su tuo susijęs komponento
gyvavimo ciklas. (Pagal OSGi.)

Įtaisytųjų \en{embedded} sistemų komponentų ir paketinės sistemos
paketų (pavyzdžiui, Debian DEB) skirtumai.

Programuojant bet kaip su Java, tai tikimybė, kad gausis kažkas artimo
taisyklingam komponentiniam yra labai maža. Programuojant bet kaip su
Scala turėtų gautis žymiai mažesnis $\Delta$. \emph{Jeigu programuodami
su Java naudojame projektavimo šablonus, tai tikėtina, kad gausime
sistemą, kurią galime nesunkiai išskaidyti į komponentus. Norint
programuoti komponentiškai su Scala irgi reikia taikyti projektavimo
šablonus (Cake pattern, Stackable trait). Kitaip tariant mažai tikėtina,
kad programuojant bet kaip gausime kažką panašaus į komponentinį.}
FIXME: Čia sumaišyti Design Patterns su SOLID. Pataisyti.

Kaip pagerinti Java modifikuojamumą. \emph{Nenaudojant komponentinio,
modifikuojamumą galimą padidinti klasių hierarchiją pakeičiant
į savybių hierarchiją.}

Tiek objektiniame, tiek komponentiniame dažnai gauname, kad dalykinės
srities kodas yra „paslepiamas“ „palaikančio“ kodo (žurnalizavimas,
tranzakcijos, saugumas ir t.t.). Objektiniame šitai bandoma spręsti
naudojant Aspect-oriented programming. Kaip šitai yra bandoma
spręsti komponentiniame (pavyzdžiui, EJB CDI Portable extensions
bei Scala mixin) ir kokie tokių sprendimų privalumai lyginant su AOP?

Komponento dydžio klausimas. Kas yra modulis? Perskaityti „Modular
Programming Using Objects“ iš „2010 Programming in Scala“.

Scala autoriai siūlo priemones, kurios palengvina sudėtingų sistemų
kūrimą, bet nepateikia metodikų, kaip kurti komponentines sistemas.
Sugalvoti metodinių patarimų rinkinuką kaip derėtų programuoti
komponentiškai su Scala.

Realaus pasaulio modeliavimas pasinaudojant Scala komponentiniu
modeliu. Susirenkam komponentą variklis ir jį įkomponuojam į
mašiną.

Standartinė biblioteka nėra komponentas, nes išreikštinai nenurodo
reikalavimų. Iš principo, komponentą nuo ne komponento dažniausiai
skiria tai, kurioje pusėje būna sąsajos abstrakcija. Jei ji yra
sąsajos naudotojo pusėje, tai turime komponentinę architektūrą, o
jei paslaugos teikėjo – tada ne komponentinę architektūrą. Dėl šios
priežasties Linux nėra komponentinė technologija, nes yra
išreikštinai nurodomos teikiamos paslaugos, bet nėra išreikštinai
nurodomos norimos gauti paslaugos. Bet \cite[34]{heineman2001component}
ir Szyperski teigia, kad operacinės sistemos yra pirmosios
komponentinės sistemos. Aplikacijas galime vadinti komponentais, bet
jos yra labai dideli komponentai ir dabartinės komponentinių sistemų
inžinerijos tikslas yra sukurti priemones mažesnių komponentų
kūrimui. (Pastaba: \cite[34]{heineman2001component} komponentą
apibrėžia per komponentinį modelį.) Ar verta įsivesti sąvoką
„paketų valdymo sistema“ ir ja remiantis atskirti paketus nuo
komponentų, kur komponentai yra paketai, kurie nurodo ne jiems
reikalingus paketus, o reikalingas sąsajas. Tokiu būdu būtų galima
atskirti DEB'us nuo EJB. Komponentinį galima būtų apibrėžti, kaip
paketinį su reikalavimu, kad vienas komponentas negali priklausyti nuo
kito (konkretaus) komponento. Jie turi priklausyti nuo abstrakčių
sąsajų.

Jei programuodami objektiškai laikysimės SOLID, tai gausime sistemą,
kurią galima nesunkiai „sukapoti“ į atskiras dalis. Tai leistų
nesunkiai kažkurią iš dalių pakeisti kita, bet kiekviena iš dalių
greičiausiai turės prasmę tik tos sistemos kontekste – kitaip
tariant dalių negalėsime vadinti komponentais, nes jų negalime
laisvai panaudoti kitose sistemose. Taip atsitinka todėl, kad
komponentai yra labiau paketai, nei klasės objektinėse programavimo
kalbose, todėl tam, kad sistemos dalys būtų perpanaudojamos, jos
turėtų būti skaidomos remiantis paketų architektūros sudarymo
principais: \en{The Release Reuse Equivalency Principle},
\en{The Common Closure Principle}, \en{The Common Reuse Principle}
\cite[17]{design-principles-and-design-patterns}.
Scala kūrėjai nieko nesako, kaip programuoti, kad sistemos
dalys būtų perpanaudojamos, kaip komponentai. Taigi, tai reikia
išsiaiškinti.

Clemens Szyperski
(\url{http://web.archive.org/web/20010609003644/http://www.sdmagazine.com/articles/2000/0002/0002l/0002l.htm})
ir Bertrand Meyer
(\url{http://web.archive.org/web/20010609010006/http://www.sdmagazine.com/articles/2000/0003/0003k/0003k.htm})
teigimu svarbiausios komponentinio teikiamos savybės yra šios:
\begin{itemize}
  \item perpanaudojamumas \en{reusability};
  \item praplečiamumas \en{extensibility} ir
  \item modifikuojamumas \en{evolvability}.
\end{itemize}
Meyer akcentuoja, kad svarbiausias yra perpanaudojamumas, tuo tarpu
Szyperski svarbiausiais laiko praplečiamumą ir modifikuojamumą.
Perpanaudojimą bei evoliuciją taip pat mini ir
\cite[28]{Hopkins:2000:CP:352183.352198}. Meyer teigia, kad
iš perpanaudojamumo išplaukia praplečiamumas ir modifikuojamumas.
Deja, paketinių sistemų pavyzdys rodo, kad taip nėra. Atrodo,
kad \plangname{Scala} pavyzdys rodo, kad ir iš praplečiamumo
bei modifikuojamumo neplaukia perpanaudojamumas.

Objektiniame mes turime nuorodą į klasę. Komponentiniame mes galime
turėti nuorodą tik į sąsają. Tai yra joks komponentas negali
žinoti apie konkrečią realizaciją, kas teoriškai leidžia, kad
vienoje sistemoje „gyventų“ dvi to paties komponento versijos.
\cite[44]{heineman2001component} mini, kad tai būtų naudinga
evoliucijos palaikymui. Su Scala atrodo, kad tai neįmanoma? Ar
įmanoma su EJB, OSGi, CORBA? OSGi nuo 4 versijos, atrodo, kad
tai turi \url{https://en.wikipedia.org/wiki/OSGi#New_in_OSGi_Release_4}.
