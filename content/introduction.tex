\chapter{Įvadas}

\section{Temos aktualumas}

Vis didėjant sistemoms, jų vystymas darosi vis sudėtingesnis procesas.
Dėl šios priežasties auga poreikis turėti priemones, kurios:
\begin{itemize}
  \item leistų sistemas kurti evoliuciniu būdu, jas vis papildant nauju
    funkcionalumu neliečiant jau veikiančių sistemos dalių;
  \item leistų sistemos kūrimo darbą efektyviai paskirstyti dideliam
    kiekiui žmonių.
\end{itemize}
TODO: Susieti su komponentiniu programavimu.

\section{Darbo tikslas}

Straipsnyje \cite{scalable-component-abstractions} Martin Odersky
ir Matthias Zenger teigia, jog su Scala galima programuoti
komponentiškai. Šio darbo tikslas yra patikrinti ar jų teiginys yra
teisingas ir jei taip, tai kokias būtent papildomas galimybes
suteikia komponentinis programavimas lyginant su statiniu
klasiniu programavimu (kaip pavyzdys nagrinėjama Java) kuriant verslo
informacines sistemas.

TODO: Martin Odersky nurodyti dabartinių programavimo kalbų trūkumai.

\section{Siekiami rezultatai}

Uždaviniai:
\begin{enumerate}
  \item išsiaiškinti kas yra objektinis programavimas;
  \item išsiaiškinti kas yra komponentinis programavimas;
  \item apibrėžti komponento sąvoką;
  \item \label{task:enum:scala-component} patikrinti ar su Scala galima
    programuoti komponentiškai;
  \item jei \ref{task:enum:scala-component}, tai nustatyti kokios
    būtent Scala galimybės tai leidžia;
  \item išsiaiškinti, kokias papildomas galimybes suteikia Scala
    lyginant su Java ir kaip turėtų būti programuojama, kad jos
    būtų išnaudojamos.
\end{enumerate}

TODO: Paaiškinti uždavinių ryšius: kodėl yra svarbu išsiaiškinti kas
yra objektinis programavimas.

\chapter{Objektinis programavimas}

\section{Objektinio programavimo apibrėžimai}

TODO:
\begin{itemize}
  \item Objektinio programavimo apibrėžimas:
    \begin{itemize}
      \item dinaminis susiejimas;
      \item inkapsuliacija;
      \item potipiai;
      \item paveldėjimas, pavedimas;
      \item atvira rekursija.
    \end{itemize}
  \item Objektinio programavimo rūšys ir kur patartina ką naudoti:
    \begin{itemize}
      \item prototipinis objektinis;
      \item dinaminis klasinis objektinis;
      \item statinis klasinis objektinis.
    \end{itemize}
\end{itemize}

\section{Statinis klasinis objektiškai orientuotas programavimas}

TODO: Apibrėžimas ir nurodymas, kad toliau darbe apsiribojama tik juo.
Kaip pagrindinis pavyzdys nagrinėjama Java programavimo kalba.

\chapter{Komponentinis programavimas}

\section{Komponento apibrėžimai}

TODO: Įvairių autorių pateikti komponento apibrėžimai.

\section{Komponentinio modelio apibrėžimas}

TODO: Komponentinio programavimo supratimo pokytis, perėjimas nuo
bandymo apibrėžti kas yra komponentas prie komponentinio modelio
sąvokos. Komponentinio modelio apibrėžimas pagal
\cite{classification-framework-for-scm}. Paaiškinimas, kuo svarbus šis
pokytis (Clemens Szyperski nurodo, kad komponentas yra diegimo
vienetas\cite{cs-beyond-object-oriented-programming}, bet tiesiog
pasakymas, kad komponentas turi būti įdiegiamas (TODO: kritika
išsakyta Szyperski'ui dėl jo minties, kad komponentas turi būti
sukompiliuotas) duoda mažai naudos, tuo tarpu komponentinis
modelis apibrėžia kaip yra platinami ir įdiegiami komponentai).

\section{Komponento savybių sąrašas}

TODO: Iš ankstesnių skyrelių surinktas komponento būtinųjų savybių
sąrašas.

\chapter{Scala}

\section{Scala ir Java skirtumai}

TODO: Ką Scala pridėjo objektiniam (Java):
\begin{itemize}
  \item Scala tipų sistema;
  \item Scala savybės \en{trait} konstrukcija;
  \item savybių jungimas į klases panaudojant modulių maišos
    kompoziciją \en{modular mixin composition};
  \item atviros rekursijos anotacija \en{selftype annotations} –
    iš principo tik sintaksinis saldainiukas;
  \item savybių naudojimo vietoj klasių privalumai, pavyzdys e1
    (savybės perdengimas vidury hierarchijos).
\end{itemize}

TODO: Scala vidinių klasių ir Java įdėtinių klasių skirtumai. Taip pat
pavyzdys su Scala tipų sistema ir Abstract factory projektavimo šablonu.

TODO: Scala savybės nuo Java sąsajų skiriasi tuo, kad savybės gali turėti
metodų realizacijas.

TODO: Scala savybės nuo klasių skiriasi tuo, kad savybės negali turėti
konstruktoriaus parametrų. Šis apribojimas leidžia efektyviai
išspręsti su multipaveldėjimu susijusią rombo problemą.

Šio skyrelio tikslas parodyti kuo Scala papildė Java objektinį ir
kokias papildomas galimybes tai suteikia. (Scala, kaip komponentinė
programavimo kalba dar nenagrinėjama)

\section{Scala komponentinis modelis}

TODO: Scala komponentinio modelio apibrėžimas (pagal išrinktas savybes).
Parodymas, kad Scala komponentinis modelis tenkina reikalavimus,
nurodymas kokios būtent Scala programavimo kalbos savybės kuriuos
būtent reikalavimus realizuoja.

Scala komponentinio modelio privalumai (remiantis
\cite{classification-framework-for-scm}):
\begin{itemize}
  \item vertikalaus sujungimo\cite[599]{classification-framework-for-scm}
    palaikymas leidžia kurti įvairaus dydžio \en{scalable} komponentus.
\end{itemize}

Scala komponentinio modelio trūkumai:
\begin{itemize}
  \item nėra komponentų, kaip paketų, valdymo mechanizmo (šitai galima
    apeiti pasinaudojant versijų kontrolės sistemų galimybėmis,
    pavyzdžiui, \verb|git submodule|);
  \item komponentų kiekis turi būti žinomas projektavimo metu, todėl
    Scala komponentinis modelis nėra tinkamas, pavyzdžiui,
    grafinės sąsajos elementų bibliotekos \en{GUI widgets toolkit}
    kūrimui. (Kadangi komponentai yra „užregistruojami“
    kompiliavimo metu, tai nėra, kaip pridėti trečiųjų šalių
    komponento realizacijos.)
\end{itemize}

\section{Pavyzdys: Scala komponentinis prieš Java objektinį}

e6 analizė. Cake pattern taikymas: turime ComponentA ir ComponentB,
juos sujungę į System gauname sistemą sudarytą iš dviejų komponentų.
Norėdami realizuoti analogišką sistemą su Java, turime du variantus:
\begin{enumerate}
  \item visą kodą sudėti į System, bet tada bus neįmanomas kodo
    perpanaudojimas, taip pat bus sudėtingesnis sistemos kūrimo
    darbų paskirstymas keliems programuotojams;
  \item \label{scala:exmp:enum:2} paveldėjimą pakeisti į delegavimą,
    tuo pačiu sukuriant Container, kuris pasirūpintų dalių
    sujungimu. Šiuo atveju vėl gauname kažką panašaus į
    komponentinį.
\end{enumerate}

Šis pavyzdys iliustruoja teiginį, kad komponentinis programavimas yra
susijęs ne su realizacine technologija (programavimo kalba), o su
jos naudojimo būdu, kuris užtikrina:
\begin{enumerate}
  \item galimybę dalis kurti atskirai, nepriklausomai viena nuo kitos;
  \item galimybę lengvai dalį pakeisti kita jos realizacija.
\end{enumerate}

\chapter{Išvados}

Šiame darbe buvo apibrėžta kas yra komponentinis modelis ir parodyta,
jog Scala autorių teiginys, jog su Scala galima programuoti
komponentiškai yra teisingas.

\chapter{Neišnagrinėti klausimai}

Komponentų vykdymo aplinka. Komponento konteineris. Galimybė vieną
komponentą pakeisti kitu vykdymo metu bei su tuo susijęs komponento
gyvavimo ciklas. (Pagal OSGi.)

Įtaisytųjų \en{embedded} sistemų komponentų ir paketinės sistemos
paketų (pavyzdžiui, Debian DEB) skirtumai.

Programuojant bet kaip su Java, tai tikimybė, kad gausis kažkas artimo
taisyklingam komponentiniam yra labai maža. Programuojant bet kaip su
Scala turėtų gautis žymiai mažesnis $\Delta$. \emph{Jeigu programuodami
su Java naudojame projektavimo šablonus, tai tikėtina, kad gausime
sistemą, kurią galime nesunkiai išskaidyti į komponentus. Norint
programuoti komponentiškai su Scala irgi reikia taikyti projektavimo
šablonus (Cake pattern, Stackable trait). Kitaip tariant mažai tikėtina,
kad programuojant bet kaip gausime kažką panašaus į komponentinį.}

Kaip pagerinti Java modifikuojamumą. \emph{Nenaudojant komponentinio,
modifikuojamumą galimą padidinti klasių hierarchiją pakeičiant
į savybių hierarchiją.}

Tiek objektiniame, tiek komponentiniame dažnai gauname, kad dalykinės
srities kodas yra „paslepiamas“ „palaikančio“ kodo (žurnalizavimas,
tranzakcijos, saugumas ir t.t.). Objektiniame šitai bandoma spręsti
naudojant Aspect-oriented programming. Kaip šitai yra bandoma
spręsti komponentiniame (pavyzdžiui, EJB CDI Portable extensions)
ir kokie tokių sprendimų privalumai lyginant su AOP?
