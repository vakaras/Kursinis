\chapter{Įvadas}

Programinės įrangos naudojimas nuo pat jos atsiradimo nuolat auga,
verslo palaikymo sistemos perima vis daugiau verslo funkcijų, todėl
jos tampa vis didesnės ir tuo pačiu vien dėl savo dydžio tampa
sudėtingos. Be to, verslo poreikiai nuolat kinta, o kartu su jais
ir programų sistemoms keliami reikalavimai. Esant tokiai situacijai
atsiranda noras turėti priemones, kurios leistų susitvarkyti
su problemomis atsirandančiomis dėl kuriamų sistemų dydžio. Kitaip
tariant, norisi turėti priemones, kurios:
\begin{itemize}
  \item leistų kurti dideles sistemas
    \gls{evolutionary-software-development-process}{evoliuciniu būdu};
  \item leistų darbus efektyviai paskirstyti didelei grupei žmonių.
\end{itemize}

Viena iš šias galimybes žadančių priemonių yra
\gls{component-oriented-software-development}{komponentinis programavimas}.
\NFIXME{Aurelijaus pastaba: „Susidaro įvaizdis, kad svarbiau galimybė,
o ne problemos, apibendrintos šiomis galimybėmis (gal geriau savybės,
o ne galimybės)“. Nebūčiau linkęs „galimybės“ keisti į „savybes“,
nes priemonės turi savybes, bet jų nežada. O čia būtent žada, nes ką
duoda, tai jau bus prie išvadų.}
Idealiu atveju komponentinis sistemų kūrimo būdas yra veikiančios
sistemos surinkimas iš trečiųjų šalių sukurtų dalių –
komponentų, kurie yra tarpusavyje nepriklausomi. (Nepriklausomi ta
prasme, kad jokio komponento veikimui nereikia jokio kito konkretaus
komponento, tačiau jam gali reikėti komponento tenkinančio tam
tikras savybes.) Taigi, dėl komponentų nepriklausomumo, kiekvieną iš
komponentų galėtų kurti atskira komanda, kas leistų sistemos kūrimu
užsiimti palyginti didelei grupei žmonių. Taip pat, komponentinėje
sistemoje vieną komponentą galima pakeisti kitu neperdarant visos
sistemos, kas leidžia vystyti sistemą
\gls{evolutionary-software-development-process}{evoliuciniu būdu}%
\cite[6]{cs-beyond-object-oriented-programming}. Be paminėtų,
komponentinis sistemų kūrimas turi dar ir tą privalumą, kad tuos
pačius komponentus galima panaudoti keliose skirtingose sistemose, kas
leidžia sumažinti kuriamų sistemų
kainą\cite[6]{cs-beyond-object-oriented-programming}.

Programavimo kalbos \gls{scala}{\plangname{Scala}} autoriaus \human{Martin'o
Odersky} teigimu komponentinių technologijų plitimui trukdo
tai, kad dabartinėse programavimo kalbose trūksta priemonių leidžiančių
apibrėžti ir sujungti komponentus\cite{odersky:scala-experiment}.
Populiariausios šiuo metu naudojamos programavimo kalbos turi galimybes
išreikštinai nurodyti komponentų teikiamas paslaugas, bet neturi
galimybės išreikštinai nurodyti, kokių paslaugų
komponentui reikia. Dėl šios priežasties paslaugų naudotojai dažnai
būna pririšami prie konkrečių paslaugų teikėjų, pavyzdžiui,
bibliotekų\cite{scalable-component-abstractions}. Taip pat, norint
su dabartinėmis sistemomis programuoti komponentiškai reikia
tam naudoti specialius karkasus, dėl ko dažnai tenka rašyti
nemažai palaikančio \en{boilerplate} kodo, arba naudoti
metaprogramavimą\NTODO{Metaprogramavimas yra blogai tuo, kad jį
yra sunku „patikrinti“. Iš statinės programavimo kalbos mes tikimės
stabilumo, o naudodami metaprogramavimą, mes realiai bandom apeiti
stabilumą užtikrinančius įrankius. Naudodami metaprogramavimą
mes pakeičiam „normalią“ elgseną, kurios galbūt tikisi kitos sistemos
dalį.}\cite{extensible-software-components}.

\gls{scala}{\plangname{Scala}} kūrėjai pasiūlė pastarąsias
dabartinių programavimo kalbų problemas spręsti
\gls{statically-typed-programming-language}{statinę}
\gls{class-based-programming-language}{klasinę}
\TODO{gls:objektinę} programavimo kalbą papildydami naujomis
savybėmis\cite{scalable-component-abstractions}:
\begin{itemize}
  \item \gls{abstract-type-member}{abstrakčiais tipais-atributais};
  \item \gls{selftype-annotation}{savo tipo anotacija};
  \item \gls{modular-mixin-composition}{moduline maišos kompozicija}.
\end{itemize}
Jų teigimu\cite[1]{scalable-component-abstractions} šių trijų savybių
pridėjimas įgalina programuoti komponentiškai.

Šio darbo tikslas yra patikrinti ar šis \gls{scala}{\plangname{Scala}}
kūrėjų teiginys, jog su \gls{scala}{\plangname{Scala}} yra įmanoma
programuoti komponentiškai, yra teisingas.

Darbo tikslo bus siekiama įgyvendinant šiuos uždavinius:
\begin{enumerate}
  \item \label{introduction:task:object-oriented-programming}
    apibrėžti, kas yra objektinis programavimas;
  \item išsiaiškinti, kas yra komponentinis programavimas, kokios
    yra jį išskiriančios (privalomosios) savybės;
  \item pagal išskirtąsias savybes patikrinti ar su
    \gls{scala}{\plangname{Scala}} galima programuoti komponentiškai;
  \item jei su \gls{scala}{\plangname{Scala}} yra įmanoma programuoti
    komponentiškai, tai išsiaiškinti kokie yra
    \gls{scala}{\plangname{Scala}} komponentinės technologijos
    privalumai lyginant su objektiniu programavimu bei su kitomis
    komponentinėmis technologijomis.
\end{enumerate}
\emph{Pastabos:}
\begin{enumerate}
  \item \ref{introduction:task:object-oriented-programming}
    uždavinio rezultatas yra svarbus norint pilnai suvokti kaip būtent
    \gls{scala}{\plangname{Scala}} autoriai pakeitė objektinį programavimo
    modelį, kad iš jo gautų komponentinį, bei siekiant suprasti kuo
    susijęs objektinis su komponentiniu.
  \item Kadangi \gls{scala}{\plangname{Scala}} yra susijusi su
    \plangname{Java} (iš \gls{scala}{\plangname{Scala}} kodo galima
    kviesti \plangname{Java} kodą ir atvirkščiai), tai šiame darbe,
    kaip pagrindinė \gls{statically-typed-programming-language}{statinių}
    \gls{class-based-programming-language}{klasinių}
    \TODO{gls:objektinių} programavimo kalbų atstovė imama
    \plangname{Java}.
\end{enumerate}

Darbas suskirstytas į tris skyrius: pirmajame skyriuje surinkti
įvairūs objektinio programavimo apibrėžimai bei apibrėžta kas
yra statinis klasinis objektiškai orientuotas programavimas.
Antrajame apibrėžta kas yra komponentas bei kas yra komponentinis modelis.
Trečiajame skyriuje pristatomos galimybės, kuriomis \plangname{Scala}
papildė statines klasines objektines programavimo kalbas, tokias
kaip \plangname{Java}. Tada remiantis komponento apibrėžimu patikrinama, ar
su \plangname{Scala} iš tiesų galima programuoti komponentiškai bei
pateikiama keletas pavyzdžių, parodančių
\gls{scala}{\plangname{Scala}} privalumus.

\chapter{Komponentinis programavimas}

\section{Komponento apibrėžimai}

TODO: Įvairių autorių pateikti komponento apibrėžimai.

\section{Komponentinio modelio apibrėžimas}

Komponentinį modelį jau mini
\cite[4]{cs-beyond-object-oriented-programming}.

TODO: Komponentinio programavimo supratimo pokytis, perėjimas nuo
bandymo apibrėžti kas yra komponentas prie komponentinio modelio
sąvokos. Komponentinio modelio apibrėžimas pagal
\cite{classification-framework-for-scm}. Paaiškinimas, kuo svarbus šis
pokytis (Clemens Szyperski nurodo, kad komponentas yra diegimo
vienetas\cite{cs-beyond-object-oriented-programming}, bet tiesiog
pasakymas, kad komponentas turi būti įdiegiamas (TODO: kritika
išsakyta Szyperski'ui dėl jo minties, kad komponentas turi būti
sukompiliuotas) duoda mažai naudos, tuo tarpu komponentinis
modelis apibrėžia kaip yra platinami ir įdiegiami komponentai).

TODO: Pagrindimas, kad komponentinis ir objektinis yra skirtingi
dalykai.

\section{Komponento savybių sąrašas}

TODO: Iš ankstesnių skyrelių surinktas komponento būtinųjų savybių
sąrašas.

\chapter{Scala}

\section{Scala ir Java skirtumai}

TODO: Ką Scala pridėjo objektiniam (Java):
\begin{itemize}
  \item Scala tipų sistema;
  \item Scala savybės \en{trait} konstrukcija;
  \item savybių jungimas į klases panaudojant modulių maišos
    kompoziciją \en{modular mixin composition};
  \item atviros rekursijos anotacija \en{selftype annotations} –
    iš principo tik sintaksinis saldainiukas dviem konstrukcijoms
    (TODO: Ar tai, kad tai yra dviejų konstrukcijų junginys nereiškia,
    jog tai jau nėra tik sintaksinis saldainiukas?):
    \begin{enumerate}
      \item \verb|def self: S = this.asInstanceOf[S]|, žr.: Observer
        Pattern realizaciją e7;
      \item \verb|T extends C| – skirtumas tas, kad šis apibrėžia
        tvarką, kokia bus išdėstyti super kvietimai, o self-type
        – ne (TODO: Patikrinti ar tikrai.);
    \end{enumerate}
    (kadangi sujungia abi konstrukcijas į vieną, tai turi privalumą, kad
    e7 Subject pakeitus į ką nors kitą lūš kompiliavimo, o ne vykdymo
    metu; taip pat antruoju atveju C negali būti abstraktus tipas, o
    naudojant anotaciją – gali)
  \item savybių naudojimo vietoj klasių privalumai, pavyzdys e1
    (savybės perdengimas vidury hierarchijos).
\end{itemize}

TODO: Scala vidinių klasių ir Java įdėtinių klasių skirtumai. Taip pat
pavyzdys su Scala tipų sistema ir Abstract factory projektavimo šablonu.

TODO: Scala naudodama fragmentų hierarchiją patobulina esminę objektinio
programavimo savybę – „dalinimasį“ \en{sharing}. Fragmentų ir klasių
hierachija išlaiko „gerąsias“ klasių paveldėjimo mechanizmo teikiamas
savybes, bet tuo pačiu smarkiai padidina lankstumą.

TODO: Scala savybės nuo Java sąsajų skiriasi tuo, kad savybės gali turėti
metodų realizacijas.

TODO: Scala savybės nuo klasių skiriasi tuo, kad savybės negali turėti
konstruktoriaus parametrų. Šis apribojimas leidžia efektyviai
išspręsti su multipaveldėjimu susijusią rombo problemą.

Šio skyrelio tikslas parodyti kuo Scala papildė Java objektinį ir
kokias papildomas galimybes tai suteikia. (Scala, kaip komponentinė
programavimo kalba dar nenagrinėjama)

\section{Scala komponentinis modelis}

TODO: Scala komponentinio modelio apibrėžimas (pagal išrinktas savybes).
Parodymas, kad Scala komponentinis modelis tenkina reikalavimus,
nurodymas kokios būtent Scala programavimo kalbos savybės kuriuos
būtent reikalavimus realizuoja.

Scala komponentinio modelio privalumai (remiantis
\cite{classification-framework-for-scm}):
\begin{itemize}
  \item vertikalaus sujungimo\cite[599]{classification-framework-for-scm}
    palaikymas leidžia kurti įvairaus dydžio \en{scalable} komponentus;
  \item TODO: paprastesnis komponentų panaudojimas (komponentu
    pasinaudoti (jį inicializuoti) yra paprasčiau nei komponentų
    ansambliu).
\end{itemize}

Scala komponentinio modelio trūkumai:
\begin{itemize}
  \item nėra komponentų, kaip paketų, valdymo mechanizmo (šitai galima
    apeiti pasinaudojant versijų kontrolės sistemų galimybėmis,
    pavyzdžiui, \verb|git submodule|);
  \item komponentų kiekis turi būti žinomas projektavimo metu, todėl
    Scala komponentinis modelis nėra tinkamas, pavyzdžiui,
    grafinės sąsajos elementų bibliotekos \en{GUI widgets toolkit}
    kūrimui. (Kadangi komponentai yra „užregistruojami“
    kompiliavimo metu, tai nėra, kaip pridėti trečiųjų šalių
    komponento realizacijos.)
\end{itemize}

\section{Pavyzdys: Scala komponentinis prieš Java objektinį}

e6 analizė. Cake pattern taikymas: turime ComponentA ir ComponentB,
juos sujungę į System gauname sistemą sudarytą iš dviejų komponentų.
Norėdami realizuoti analogišką sistemą su Java, turime du variantus:
\begin{enumerate}
  \item visą kodą sudėti į System, bet tada bus neįmanomas kodo
    perpanaudojimas, taip pat bus sudėtingesnis sistemos kūrimo
    darbų paskirstymas keliems programuotojams;
  \item \label{scala:exmp:enum:2} paveldėjimą pakeisti į delegavimą,
    tuo pačiu sukuriant Container, kuris pasirūpintų dalių
    sujungimu. Šiuo atveju vėl gauname kažką panašaus į
    komponentinį.
\end{enumerate}

Šis pavyzdys iliustruoja teiginį, kad komponentinis programavimas yra
susijęs ne su realizacine technologija (programavimo kalba), o su
jos naudojimo būdu, kuris užtikrina:
\begin{enumerate}
  \item galimybę dalis kurti atskirai, nepriklausomai viena nuo kitos;
  \item galimybę lengvai dalį pakeisti kita jos realizacija.
\end{enumerate}

\chapter{Išvados}

Šiame darbe buvo apibrėžta kas yra komponentinis modelis ir parodyta,
jog Scala autorių teiginys, jog su Scala galima programuoti
komponentiškai yra teisingas.

\chapter{Neišnagrinėti klausimai}

Komponentų vykdymo aplinka. Komponento konteineris. Galimybė vieną
komponentą pakeisti kitu vykdymo metu bei su tuo susijęs komponento
gyvavimo ciklas. (Pagal OSGi.)

Įtaisytųjų \en{embedded} sistemų komponentų ir paketinės sistemos
paketų (pavyzdžiui, Debian DEB) skirtumai.

Programuojant bet kaip su Java, tai tikimybė, kad gausis kažkas artimo
taisyklingam komponentiniam yra labai maža. Programuojant bet kaip su
Scala turėtų gautis žymiai mažesnis $\Delta$. \emph{Jeigu programuodami
su Java naudojame projektavimo šablonus, tai tikėtina, kad gausime
sistemą, kurią galime nesunkiai išskaidyti į komponentus. Norint
programuoti komponentiškai su Scala irgi reikia taikyti projektavimo
šablonus (Cake pattern, Stackable trait). Kitaip tariant mažai tikėtina,
kad programuojant bet kaip gausime kažką panašaus į komponentinį.}
FIXME: Čia sumaišyti Design Patterns su SOLID. Pataisyti.

Kaip pagerinti Java modifikuojamumą. \emph{Nenaudojant komponentinio,
modifikuojamumą galimą padidinti klasių hierarchiją pakeičiant
į savybių hierarchiją.}

Tiek objektiniame, tiek komponentiniame dažnai gauname, kad dalykinės
srities kodas yra „paslepiamas“ „palaikančio“ kodo (žurnalizavimas,
tranzakcijos, saugumas ir t.t.). Objektiniame šitai bandoma spręsti
naudojant Aspect-oriented programming. Kaip šitai yra bandoma
spręsti komponentiniame (pavyzdžiui, EJB CDI Portable extensions
bei Scala mixin) ir kokie tokių sprendimų privalumai lyginant su AOP?

Komponento dydžio klausimas. Kas yra modulis? Perskaityti „Modular
Programming Using Objects“ iš „2010 Programming in Scala“.

Scala autoriai siūlo priemones, kurios palengvina sudėtingų sistemų
kūrimą, bet nepateikia metodikų, kaip kurti komponentines sistemas.
Sugalvoti metodinių patarimų rinkinuką kaip derėtų programuoti
komponentiškai su Scala.

Realaus pasaulio modeliavimas pasinaudojant Scala komponentiniu
modeliu. Susirenkam komponentą variklis ir jį įkomponuojam į
mašiną.

Standartinė biblioteka nėra komponentas, nes išreikštinai nenurodo
reikalavimų. Iš principo, komponentą nuo ne komponento dažniausiai
skiria tai, kurioje pusėje būna sąsajos abstrakcija. Jei ji yra
sąsajos naudotojo pusėje, tai turime komponentinę architektūrą, o
jei paslaugos teikėjo – tada ne komponentinę architektūrą. Dėl šios
priežasties Linux nėra komponentinė technologija, nes yra
išreikštinai nurodomos teikiamos paslaugos, bet nėra išreikštinai
nurodomos norimos gauti paslaugos.

Jei programuodami objektiškai laikysimės SOLID, tai gausime sistemą,
kurią galima nesunkiai „sukapoti“ į atskiras dalis. Tai leistų
nesunkiai kažkurią iš dalių pakeisti kita, bet kiekviena iš dalių
greičiausiai turės prasmę tik tos sistemos kontekste – kitaip
tariant dalių negalėsime vadinti komponentais, nes jų negalime
laisvai panaudoti kitose sistemose. Taip atsitinka todėl, kad
komponentai yra labiau paketai, nei klasės objektinėse programavimo
kalbose, todėl tam, kad sistemos dalys būtų perpanaudojamos, jos
turėtų būti skaidomos remiantis paketų architektūros sudarymo
principais: \en{The Release Reuse Equivalency Principle},
\en{The Common Closure Principle}, \en{The Common Reuse Principle}
\cite[17]{design-principles-and-design-patterns}.
Scala kūrėjai nieko nesako, kaip programuoti, kad sistemos
dalys būtų perpanaudojamos, kaip komponentai. Taigi, tai reikia
išsiaiškinti.
