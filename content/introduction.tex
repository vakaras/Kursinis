\chapter{Įvadas}

Nuo pat kompiuterių atsiradimo programinės įrangos naudojimas vien
tik didėja, kuriamos vis didesnės sistemos, kurios vien dėl
savo dydžio tampa sudėtingomis. Taip pat, kuriamoms sistemoms yra
nuolat keliami vis nauji reikalavimai. Esant tokiai situacijai
atsiranda noras turėti priemones, kurios leistų susitvarkyti
su dėl kuriamų sistemų dydžio atsirandančiomis problemomis. Kitaip
tariant, norisi turėti priemones, kurios:
\begin{itemize}
  \item leistų kurti dideles sistemas
    \gls{evolutionary-software-development-process}{evoliuciniu būdu};
  \item leistų darbus efektyviai paskirstyti didelei grupei žmonių.
\end{itemize}

Viena iš šias galimybes žadančių priemonių yra
\gls{component-oriented-software-development}{komponentinis programavimas}.
Kadangi sistemą kuriant komponentiniu būdu ji yra surenkama iš
komponentų, kurie išreikštinai nepriklauso (tai yra komponento
veikimui yra reikalingas ne kažkoks konkretus kitas komponentas, o
bet koks komponentas, kuris tenkina tam tikrus reikalavimus) vienas nuo
kito, tai tuos komponentus gali kurti žmonių grupės nepriklausomai
viena nuo kitos – tai leistų sistemą kurti palyginti didelei grupei
žmonių. Taip pat, dėl tos pačios priežasties vieną komponentą galima
pakeisti kitu neperdarant visos sistemos, kas leidžia vystyti
sistemą \gls{evolutionary-software-development-process}{evoliuciniu būdu}%
\cite[6]{cs-beyond-object-oriented-programming}. Komponentinis programų
kūrimo procesas turi dar ir tą privalumą, kad tuos pačius komponentus
galima panaudoti keliose skirtingose sistemose, kas leidžia sumažinti
kuriamų sistemų kainą\cite[6]{cs-beyond-object-oriented-programming}.

Martin Odersky ir Matthias Zenger teigimu komponentinių technologijų
plitimui trukdo dabartinių programavimo kalbų
trūkumai\cite{scalable-component-abstractions, odersky:scala-experiment}.
Pagrindinės šiuo metu naudojamos programavimo kalbos, tokios, kaip
Java, turi galimybes išreikštinai nurodyti komponentų teikiamus
servisus, bet neturi galimybės išreikštinai nurodyti, kokių servisų
komponentui reikia. Dėl šios priežasties dažnai servisų naudotojai
būna pririšami prie servisų konkrečių
tiekėjų\cite{scalable-component-abstractions}. Taip pat, norint
su dabartinėmis sistemomis programuoti komponentiškai reikia
tam naudoti specialius karkasus, dėl ko dažnai tenka rašyti
nemažai palaikančio \en{boilerplate} kodo, arba naudoti
metaprogramavimą\cite{extensible-software-components}.

\gls{scala}{Scala} kūrėjai pasiūlė pastarąsias problemas spręsti
statinę klasinę objektinę programavimo kalbą papildydami naujomis
savybėmis\cite{scalable-component-abstractions}:
\begin{itemize}
  \item \gls{abstract-type-member}{abstrakčiais tipais-atributais};
  \item \gls{selftype-annotation}{savo tipo anotacija};
  \item \gls{modular-mixin-composition}{moduline maišos kompozicija}.
\end{itemize}
Jų teigimu\cite[1]{scalable-component-abstractions} šios trys
\gls{scala}{Scala} savybės įgalina su ja programuoti komponentiškai.
Šio darbo tikslas yra patikrinti ar šis teiginys yra teisingas.
To bus siekiama įgyvendinant šiuos uždavinius:
\begin{enumerate}
  \item kadangi \gls{scala}{Scala} autoriai komponentinę programavimo
    kalbą bando kurti objektinę papildydami naujomis savybėmis, tai
    norint atskirti objektinę nuo komponentinės pirmiausia reikia
    apibrėžti, kas yra objektinis programavimas;
  \item išsiaiškinti, kas yra komponentinis programavimas, kokios
    yra jį išskiriančios (privalomosios) savybės;
  \item pagal išskirtąsias savybes patikrinti ar su \gls{scala}{Scala}
    galima programuoti komponentiškai;
  \item jei su \gls{scala}{Scala} yra įmanoma programuoti
    komponentiškai, tai išsiaiškinti kokie yra to privalumai.
\end{enumerate}

Uždaviniai po skyrius išskirstyti taip: pirmajame skyriuje surinkti
įvairūs objektinio programavimo apibrėžimai bei apibrėžta kas
yra statinis klasinis objektiškai orientuotas programavimas.
Antrojo skyriaus struktūra panaši į pirmojo: jame pabandyta
apibrėžti kas yra komponentas bei kas yra komponentinis modelis.
Trečiajame skyriuje pristatomos galimybės, kuriomis Scala
papildė statines klasines objektines programavimo kalbas, tokias
kaip Java. Tada remiantis komponento apibrėžimu parodoma, kad
su Scala iš tiesų galima programuoti komponentiškai bei pateikiama
keletas pavyzdžių, parodančių \gls{scala}{Scala} privalumus.

\TODO{Nurodyti, kad apsiriboju Java pasauliu.}

\chapter{Objektinis programavimas}

\section{Objektinio programavimo apibrėžimai}

TODO:
\begin{itemize}
  \item Objektinio programavimo apibrėžimas:
    \begin{itemize}
      \item dinaminis susiejimas;
      \item inkapsuliacija;
      \item potipiai;
      \item paveldėjimas, pavedimas;
      \item atvira rekursija.
    \end{itemize}
  \item Objektinio programavimo rūšys ir kur patartina ką naudoti:
    \begin{itemize}
      \item prototipinis objektinis;
      \item dinaminis klasinis objektinis;
      \item statinis klasinis objektinis.
    \end{itemize}
\end{itemize}

\section{Statinis klasinis objektiškai orientuotas programavimas}

TODO: Apibrėžimas ir nurodymas, kad toliau darbe apsiribojama tik juo.
Kaip pagrindinis pavyzdys nagrinėjama Java programavimo kalba.

\chapter{Komponentinis programavimas}

\section{Komponento apibrėžimai}

TODO: Įvairių autorių pateikti komponento apibrėžimai.

\section{Komponentinio modelio apibrėžimas}

Komponentinį modelį jau mini
\cite[4]{cs-beyond-object-oriented-programming}.

TODO: Komponentinio programavimo supratimo pokytis, perėjimas nuo
bandymo apibrėžti kas yra komponentas prie komponentinio modelio
sąvokos. Komponentinio modelio apibrėžimas pagal
\cite{classification-framework-for-scm}. Paaiškinimas, kuo svarbus šis
pokytis (Clemens Szyperski nurodo, kad komponentas yra diegimo
vienetas\cite{cs-beyond-object-oriented-programming}, bet tiesiog
pasakymas, kad komponentas turi būti įdiegiamas (TODO: kritika
išsakyta Szyperski'ui dėl jo minties, kad komponentas turi būti
sukompiliuotas) duoda mažai naudos, tuo tarpu komponentinis
modelis apibrėžia kaip yra platinami ir įdiegiami komponentai).

TODO: Pagrindimas, kad komponentinis ir objektinis yra skirtingi
dalykai.

\section{Komponento savybių sąrašas}

TODO: Iš ankstesnių skyrelių surinktas komponento būtinųjų savybių
sąrašas.

\chapter{Scala}

\section{Scala ir Java skirtumai}

TODO: Ką Scala pridėjo objektiniam (Java):
\begin{itemize}
  \item Scala tipų sistema;
  \item Scala savybės \en{trait} konstrukcija;
  \item savybių jungimas į klases panaudojant modulių maišos
    kompoziciją \en{modular mixin composition};
  \item atviros rekursijos anotacija \en{selftype annotations} –
    iš principo tik sintaksinis saldainiukas dviem konstrukcijoms
    (TODO: Ar tai, kad tai yra dviejų konstrukcijų junginys nereiškia,
    jog tai jau nėra tik sintaksinis saldainiukas?):
    \begin{enumerate}
      \item \verb|def self: S = this.asInstanceOf[S]|, žr.: Observer
        Pattern realizaciją e7;
      \item \verb|T extends C| – skirtumas tas, kad šis apibrėžia
        tvarką, kokia bus išdėstyti super kvietimai, o self-type
        – ne (TODO: Patikrinti ar tikrai.);
    \end{enumerate}
    (kadangi sujungia abi konstrukcijas į vieną, tai turi privalumą, kad
    e7 Subject pakeitus į ką nors kitą lūš kompiliavimo, o ne vykdymo
    metu; taip pat antruoju atveju C negali būti abstraktus tipas, o
    naudojant anotaciją – gali)
  \item savybių naudojimo vietoj klasių privalumai, pavyzdys e1
    (savybės perdengimas vidury hierarchijos).
\end{itemize}

TODO: Scala vidinių klasių ir Java įdėtinių klasių skirtumai. Taip pat
pavyzdys su Scala tipų sistema ir Abstract factory projektavimo šablonu.

TODO: Scala savybės nuo Java sąsajų skiriasi tuo, kad savybės gali turėti
metodų realizacijas.

TODO: Scala savybės nuo klasių skiriasi tuo, kad savybės negali turėti
konstruktoriaus parametrų. Šis apribojimas leidžia efektyviai
išspręsti su multipaveldėjimu susijusią rombo problemą.

Šio skyrelio tikslas parodyti kuo Scala papildė Java objektinį ir
kokias papildomas galimybes tai suteikia. (Scala, kaip komponentinė
programavimo kalba dar nenagrinėjama)

\section{Scala komponentinis modelis}

TODO: Scala komponentinio modelio apibrėžimas (pagal išrinktas savybes).
Parodymas, kad Scala komponentinis modelis tenkina reikalavimus,
nurodymas kokios būtent Scala programavimo kalbos savybės kuriuos
būtent reikalavimus realizuoja.

Scala komponentinio modelio privalumai (remiantis
\cite{classification-framework-for-scm}):
\begin{itemize}
  \item vertikalaus sujungimo\cite[599]{classification-framework-for-scm}
    palaikymas leidžia kurti įvairaus dydžio \en{scalable} komponentus;
  \item TODO: paprastesnis komponentų panaudojimas (komponentu
    pasinaudoti (jį inicializuoti) yra paprasčiau nei komponentų
    ansambliu).
\end{itemize}

Scala komponentinio modelio trūkumai:
\begin{itemize}
  \item nėra komponentų, kaip paketų, valdymo mechanizmo (šitai galima
    apeiti pasinaudojant versijų kontrolės sistemų galimybėmis,
    pavyzdžiui, \verb|git submodule|);
  \item komponentų kiekis turi būti žinomas projektavimo metu, todėl
    Scala komponentinis modelis nėra tinkamas, pavyzdžiui,
    grafinės sąsajos elementų bibliotekos \en{GUI widgets toolkit}
    kūrimui. (Kadangi komponentai yra „užregistruojami“
    kompiliavimo metu, tai nėra, kaip pridėti trečiųjų šalių
    komponento realizacijos.)
\end{itemize}

\section{Pavyzdys: Scala komponentinis prieš Java objektinį}

e6 analizė. Cake pattern taikymas: turime ComponentA ir ComponentB,
juos sujungę į System gauname sistemą sudarytą iš dviejų komponentų.
Norėdami realizuoti analogišką sistemą su Java, turime du variantus:
\begin{enumerate}
  \item visą kodą sudėti į System, bet tada bus neįmanomas kodo
    perpanaudojimas, taip pat bus sudėtingesnis sistemos kūrimo
    darbų paskirstymas keliems programuotojams;
  \item \label{scala:exmp:enum:2} paveldėjimą pakeisti į delegavimą,
    tuo pačiu sukuriant Container, kuris pasirūpintų dalių
    sujungimu. Šiuo atveju vėl gauname kažką panašaus į
    komponentinį.
\end{enumerate}

Šis pavyzdys iliustruoja teiginį, kad komponentinis programavimas yra
susijęs ne su realizacine technologija (programavimo kalba), o su
jos naudojimo būdu, kuris užtikrina:
\begin{enumerate}
  \item galimybę dalis kurti atskirai, nepriklausomai viena nuo kitos;
  \item galimybę lengvai dalį pakeisti kita jos realizacija.
\end{enumerate}

\chapter{Išvados}

Šiame darbe buvo apibrėžta kas yra komponentinis modelis ir parodyta,
jog Scala autorių teiginys, jog su Scala galima programuoti
komponentiškai yra teisingas.

\chapter{Neišnagrinėti klausimai}

Komponentų vykdymo aplinka. Komponento konteineris. Galimybė vieną
komponentą pakeisti kitu vykdymo metu bei su tuo susijęs komponento
gyvavimo ciklas. (Pagal OSGi.)

Įtaisytųjų \en{embedded} sistemų komponentų ir paketinės sistemos
paketų (pavyzdžiui, Debian DEB) skirtumai.

Programuojant bet kaip su Java, tai tikimybė, kad gausis kažkas artimo
taisyklingam komponentiniam yra labai maža. Programuojant bet kaip su
Scala turėtų gautis žymiai mažesnis $\Delta$. \emph{Jeigu programuodami
su Java naudojame projektavimo šablonus, tai tikėtina, kad gausime
sistemą, kurią galime nesunkiai išskaidyti į komponentus. Norint
programuoti komponentiškai su Scala irgi reikia taikyti projektavimo
šablonus (Cake pattern, Stackable trait). Kitaip tariant mažai tikėtina,
kad programuojant bet kaip gausime kažką panašaus į komponentinį.}
FIXME: Čia sumaišyti Design Patterns su SOLID. Pataisyti.

Kaip pagerinti Java modifikuojamumą. \emph{Nenaudojant komponentinio,
modifikuojamumą galimą padidinti klasių hierarchiją pakeičiant
į savybių hierarchiją.}

Tiek objektiniame, tiek komponentiniame dažnai gauname, kad dalykinės
srities kodas yra „paslepiamas“ „palaikančio“ kodo (žurnalizavimas,
tranzakcijos, saugumas ir t.t.). Objektiniame šitai bandoma spręsti
naudojant Aspect-oriented programming. Kaip šitai yra bandoma
spręsti komponentiniame (pavyzdžiui, EJB CDI Portable extensions
bei Scala mixin) ir kokie tokių sprendimų privalumai lyginant su AOP?

Komponento dydžio klausimas. Kas yra modulis? Perskaityti „Modular
Programming Using Objects“ iš „2010 Programming in Scala“.

Scala autoriai siūlo priemones, kurios palengvina sudėtingų sistemų
kūrimą, bet nepateikia metodikų, kaip kurti komponentines sistemas.
Sugalvoti metodinių patarimų rinkinuką kaip derėtų programuoti
komponentiškai su Scala.

Realaus pasaulio modeliavimas pasinaudojant Scala komponentiniu
modeliu. Susirenkam komponentą variklis ir jį įkomponuojam į
mašiną.

Standartinė biblioteka nėra komponentas, nes išreikštinai nenurodo
reikalavimų. Iš principo, komponentą nuo ne komponento dažniausiai
skiria tai, kurioje pusėje būna sąsajos abstrakcija. Jei ji yra
sąsajos naudotojo pusėje, tai turime komponentinę architektūrą, o
jei serviso teikėjo – tada ne komponentinę architektūrą. Dėl šios
priežasties Linux nėra komponentinė technologija, nes yra
išreikštinai nurodomas teikiamas servisas, bet nėra išreikštinai
nurodomas norimas gauti servisas.
