\Chapter*{Įvadas}

% Įvade apibūdinamas darbo tikslas, temos aktualumas ir siekiami
% rezultatai. Darbo įvadas neturi būti dėstymo santrauka. Įvado
% apimtis 1–2 puslapiai.

Programinės įrangos naudojimas nuo pat jos atsiradimo nuolat auga,
verslo palaikymo sistemos perima vis daugiau verslo funkcijų, todėl
jos tampa vis didesnės ir tuo pačiu vien dėl savo dydžio tampa
sudėtingos. Be to, verslo poreikiai nuolat kinta, o kartu su jais
ir programų sistemoms keliami reikalavimai. Esant tokiai situacijai
atsiranda noras turėti priemones, kurios leistų susitvarkyti
su problemomis atsirandančiomis dėl kuriamų sistemų dydžio. Kitaip
tariant, norisi turėti priemones, kurios:
\begin{itemize}
  \item leistų kurti dideles sistemas
    \gls{evolutionary-software-development-process}{evoliuciniu būdu};
  \item leistų darbus efektyviai paskirstyti didelei grupei žmonių.
\end{itemize}

Viena iš šias galimybes žadančių priemonių yra
\gls{component-oriented-software-development}{komponentinis programavimas}.
\NFIXME{Aurelijaus pastaba: „Susidaro įvaizdis, kad svarbiau galimybė,
o ne problemos, apibendrintos šiomis galimybėmis (gal geriau savybės,
o ne galimybės)“. Nebūčiau linkęs „galimybės“ keisti į „savybes“,
nes priemonės turi savybes, bet jų nežada. O čia būtent žada, nes ką
duoda, tai jau bus prie išvadų.}
Idealiu atveju komponentinis sistemų kūrimo būdas yra veikiančios
sistemos surinkimas iš trečiųjų šalių sukurtų dalių –
komponentų, kurie yra tarpusavyje nepriklausomi. (Nepriklausomi ta
prasme, kad jokio komponento veikimui nereikia jokio kito konkretaus
komponento, tačiau jam gali reikėti komponento tenkinančio tam
tikras savybes.) Taigi, dėl komponentų nepriklausomumo, kiekvieną iš
komponentų galėtų kurti atskira komanda, kas leistų sistemos kūrimu
užsiimti palyginti didelei grupei žmonių. Taip pat, komponentinėje
sistemoje vieną komponentą galima pakeisti kitu neperdarant visos
sistemos, kas leidžia vystyti sistemą
\gls{evolutionary-software-development-process}{evoliuciniu būdu}%
\cite[6]{cs-beyond-object-oriented-programming}. Be paminėtų,
komponentinis sistemų kūrimas turi dar ir tą privalumą, kad tuos
pačius komponentus galima panaudoti keliose skirtingose sistemose, kas
leidžia sumažinti kuriamų sistemų
kainą\cite[6]{cs-beyond-object-oriented-programming}. Taigi,
apibendrinant, komponentinis programavimas žada perpanaudojamumą
\en{reusability}, modifikuojamumą \en{evolvability} ir praplečiamumą
\en{extensibility} \cites{what-to-compose}{point-counterpoint}.

Programavimo kalbos \gls{scala}{\plangname{Scala}} autoriaus \human{Martin'o
Odersky} teigimu komponentinių technologijų plitimui trukdo
tai, kad dabartinėse programavimo kalbose trūksta priemonių leidžiančių
apibrėžti ir sujungti komponentus\cite{odersky:scala-experiment}.
Populiariausios šiuo metu naudojamos programavimo kalbos turi galimybes
išreikštinai nurodyti komponentų teikiamas paslaugas, bet neturi
galimybės išreikštinai nurodyti, kokių paslaugų
komponentui reikia. Dėl šios priežasties paslaugų naudotojai dažnai
būna pririšami prie konkrečių paslaugų teikėjų, pavyzdžiui,
bibliotekų\cite{scalable-component-abstractions}. Taip pat, norint
su dabartinėmis sistemomis programuoti komponentiškai reikia
tam naudoti specialius karkasus, dėl ko dažnai tenka rašyti
nemažai palaikančio \en{boilerplate} kodo, arba naudoti
metaprogramavimą\NTODO{Metaprogramavimas yra blogai tuo, kad jį
yra sunku „patikrinti“. Iš statinės programavimo kalbos mes tikimės
stabilumo, o naudodami metaprogramavimą, mes realiai bandom apeiti
stabilumą užtikrinančius įrankius. Naudodami metaprogramavimą
mes pakeičiam „normalią“ elgseną, kurios galbūt tikisi kitos sistemos
dalį.} \cite{extensible-software-components}.

\gls{scala}{\plangname{Scala}} kūrėjai pasiūlė pastarąsias
dabartinių programavimo kalbų problemas spręsti
\gls{statically-typed-programming-language}{statinę}
\gls{class-based-programming-language}{klasinę}
\gls{object-oriented-programming-language}{objektinę} programavimo
kalbą papildydami naujomis savybėmis
\cite{scalable-component-abstractions}:
\begin{itemize}
  \item \gls{abstract-type-member}{abstrakčiais tipais – nariais};
  \item \gls{selftype-annotation}{savo tipo anotacija};
  \item \gls{modular-mixin-composition}{moduline maišos kompozicija}.
\end{itemize}
Jų teigimu \cite[1]{scalable-component-abstractions} šių trijų savybių
pridėjimas įgalina programuoti komponentiškai.

Šio darbo tikslas yra patikrinti ar šis \gls{scala}{\plangname{Scala}}
kūrėjų teiginys, jog su \gls{scala}{\plangname{Scala}} yra įmanoma
programuoti komponentiškai, yra teisingas.

Darbo tikslo bus siekiama įgyvendinant šiuos uždavinius:
\begin{enumerate}
  \item \label{introduction:task:object-oriented-programming}
    Apibrėžti, kas yra objektinis programavimas.
  \item Išsiaiškinti, kas yra komponentinis programavimas, kokios
    yra jį išskiriančios (privalomosios) savybės.
  \item Pagal išskirtąsias savybes patikrinti ar su
    \gls{scala}{\plangname{Scala}} galima programuoti komponentiškai.
  \item Jei su \gls{scala}{\plangname{Scala}} yra įmanoma programuoti
    komponentiškai, tai išsiaiškinti kokie yra
    \gls{scala}{\plangname{Scala}} komponentinės technologijos
    privalumai lyginant su kitomis komponentinėmis technologijomis.
\end{enumerate}
\emph{Pastabos:}
\begin{enumerate}
  \item \ref{introduction:task:object-oriented-programming}
    uždavinio rezultatas yra svarbus norint pilnai suvokti kaip būtent
    \gls{scala}{\plangname{Scala}} autoriai pakeitė objektinį programavimo
    modelį, kad iš jo gautų komponentinį, bei siekiant suprasti kuo
    susijęs objektinis su komponentiniu.
  \item Kadangi \gls{scala}{\plangname{Scala}} yra susijusi su
    \plangname{Java} (iš \gls{scala}{\plangname{Scala}} kodo galima
    kviesti \plangname{Java} kodą ir atvirkščiai), tai šiame darbe,
    kaip pagrindinė \gls{statically-typed-programming-language}{statinių}
    \gls{class-based-programming-language}{klasinių}
    \gls{object-oriented-programming-language}{objektinių}
    programavimo kalbų atstovė imama \plangname{Java}.
\end{enumerate}

Darbas suskirstytas į tris skyrius: pirmajame skyriuje surinkti
įvairūs objektinio programavimo apibrėžimai bei apibrėžta kas
yra statinis klasinis objektiškai orientuotas programavimas.
Antrajame apibrėžta kas yra komponentas bei kas yra komponentinis
modelis, pristatyta \cite{classification-framework-for-scm} pateikta
komponentinių modelių klasifikacija bei trumpai palygintos
komponentinės technologijos su paketų tvarkymo sistemomis.
Trečiajame skyriuje pristatomos galimybės, kuriomis \plangname{Scala}
papildė statines klasines objektines programavimo kalbas, tokias
kaip \plangname{Java}. Tada remiantis komponento apibrėžimu patikrinama, ar
su \plangname{Scala} iš tiesų galima programuoti komponentiškai bei
pateikiama jos siūlomo komponentinio modelio analizė remiantis
anksčiau pristatyta komponentinių modelių klasifikacija.
