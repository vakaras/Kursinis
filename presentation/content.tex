\begin{comment}
  \TODO{Komponentinis modelis $\neq$ komponentinė realizacija. Surasti,
  kaip atsikirsti!}

  Turi būti viena pasakojimo gija.

  \begin{enumerate}
    \item Tematika (svarbiausių tematikos sąvokų apibrėžimai,
      įvadas į tematiką) - 1 skaidrė
    \item Problemos/uždavinio formulavimas (iš to turi išplaukti
      pagrindinė darbo tema) - 1 skaidrė
    \item Darbo tikslo formulavimas (jei sutampa su problemos
      formulavimu, tai kartoti nereikia) - 1 skaidrė
    \item Darbo planas (kaip pasieksite tikslą) - čia surašote
      punktus, kuriais buvo/bus pasiektas darbo tikslas - 1 skaidrė
    \item Temos gynimui (magistrantams): svarbiausios sąvokos
      (apibrėžimai, jei ilgi, neturi būti rašomi - turi būti sakomi
      žodžiu) - 2-3 skaidrės
    \item Darbo gynimui (bakalaurams, magistrantams): darbo metu
      iškilusios problemos, esminiai priimti sprendimai, kas buvo
      padaryta jūsų pačių ("susipažinau", "sukonspektavau",
      "išsiaiškinau", "išmokau" tinka tik kursiniams darbams!) - 3-6
      skaidrės
    \item (Laukiami) rezultatai - sąrašo pavidalu, ne daugiau trijų.
      "Susipažinau", "sukonspektavau", "išsiaiškinau", "išmokau" tinka
      tik kursiniams darbams! - 1 skaidrė
    \item Išvados - sąrašo pavidalu, ne daugiau trijų (temos gynime
      nereikia) - 1 skaidrė. Nebandykite rezultatų, pastebėjimų,
      komentarų, nuomonių apiforminti kaip išvadų!
  \end{enumerate}

  Pristatymo tikslas: supažindinti komisiją su darbu.
  1.  Darbo tikslas ir uždaviniai – planas.
  2.  Kas buvo padaryta – realizacija.
  3.  Rezultatai ir išvados.

  1.  Ko siekta.
  2.  Kaip siekta.
  3.  Kas pasiekta.
\end{comment}

\begin{handout}
  Laba diena, aš esu Programų sistemų 3 kurso 2 grupės studentas
  Vytautas Astrauskas. Dabar pristatysiu savo kursinį darbą, kurio
  tema yra „Komponentinis programavimas su Scala“.
\end{handout}

\begin{handout}
  Iš pradžių aš pristatysiu ko siekiau savo darbe, tada paminėsiu,
  mano nuomone, esminius elementus iš to kaip siekiau ir galiausiai
  ką man pavyko pasiekti.
\end{handout}

\section{Ko siekta}

\begin{frame}
  %\frametitle{Tematika}
  \begin{itemize}
    \item Komponentinis programavimas – tai programų sistemų kūrimo
      būdas, surenkant jas iš atskirų dalių (komponentų).
    \item Komponentinio programavimo žadamos savybės (Clemensas
      Szyperski 2002):
      \begin{enumerate}
        \item Modifikuojamumas.
        \item Praplečiamumas.
        \item Perpanaudojamumas.
      \end{enumerate}
  \end{itemize}
  \begin{handout}
    Kuriant programų sistemas rūpi, kad jos būtų lengvai tobulinamos.
    Komponentinis programavimas, tai yra programų sistemų kūrimo
    būdas, jas surenkant iš atskirų dalių, komponentų, kurie
    paprastai yra gaunami iš trečiųjų šalių. Clemens Szyperski
    teigimu:
    \begin{itemize}
      \item komponentinės sistemos yra lengviau modifikuojamos;
      \item jas lengviau praplėsti bei;
      \item patys komponentai yra lengvai perpanaudojami.
    \end{itemize}
  \end{handout}
\end{frame}

\begin{frame}
  %\frametitle{Problema}
  Martinas Odersky:
  \begin{enumerate}
    \item Komponentinių technologijų plitimas stringa.
    \item Priežastis yra dabartinių programavimo kalbų trūkumai.
    \item Scala – kalba, su kuria galima programuoti komponentiškai.
  \end{enumerate}
  \begin{handout}
    Scala kūrėjo Martino Odersky teigimu komponentinių technologijų
    kūrimas stringa. Priežastis, jo nuomone, yra tai, kad dabartinėse
    programavimo kalbose trūksta priemonių leidžiančių apibrėžti
    ir sujungti komponentus. Tam jis kartu su kolegomis sukūrė
    programavimo kalbą Scala, su kuria, jo teigimu, galima
    programuoti komponentiškai.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Darbo tikslas}
  Patikrinti ar Scala kūrėjų teiginys, jog su Scala yra įmanoma
  programuoti komponentiškai, yra teisingas.
  \begin{handout}
    Mano darbo tikslas buvo patikrinti ar Scala kūrėjų teiginys, jog
    su Scala yra įmanoma programuoti komponentiškai yra teisingas.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Uždaviniai}
  \begin{enumerate}
    \item Apibrėžti, kas yra objektinis programavimas.
    \item Išsiaiškinti, kas yra komponentinis programavimas.
    \item Patikrinti, ar su Scala galima programuoti komponentiškai.
    \item Nustatyti Scala, kaip komponentinės technologijos, privalumus.
  \end{enumerate}
  \begin{handout}
    Skaidrėje pateikti uždaviniai, kuriais buvo siekiama tikslo
    įgyvendinimo.

    Kadangi Scala yra ir objektinė programavimo kalba, tai
    norint suvokti, ką pridėjus ji tapo komponentinė, reikia
    suprasti, kas yra objektinis programavimas.

    Tada, aišku, reikia apibrėžti kas yra komponentinis, kokios jo
    privalomosios savybės ir tuomet jomis remiantis galima patikrinti
    ar Scala yra komponentinė technologija. O jei ji tokia yra,
    tada nustatyti jos privalumus lyginant su kitomis komponentinėmis
    technologijomis.
  \end{handout}
\end{frame}

\section{Kaip siekta}

\begin{handout}
  Dabar trumpai pristatysiu komponentinį programavimą, tada Scala
  naujas kalbos konstrukcijas ir galiausiai pristatysiu, kaip
  Scala realizuoja.
\end{handout}

\begin{frame}
  \frametitle{Komponento savybės}
  \begin{enumerate}
    \item \label{enum:component:fiz} Fizinis diegimo vienetas.
    \item Juoda dėžė.
    \item Funkcionalumas pasiekiamas tik per išreikštines sąsajas.
    \item \label{enum:component:req} Poreikius nurodo tik per
      išreikštines sąsajas.
    \item Gali būti kuriamas nepriklausomai.
    \item Gali būti perpanaudojamas.
    \item Gali būti be pakeitimų įkomponuotas.
    \item Gali būti pakeičiamas kitu.
  \end{enumerate}
  Pagal Clemensą Szyperski 2002, Desmondą F. D'Souza ir Alaną Cemeroną
  Willsą 1998 bei Joną Hopkinsą 2000.
  \begin{handout}
    Iš pradžių galima bandyti apibrėžti komponentinį programavimą
    pasinaudojant komponento sąvoka. Išnagrinėjus keleto autorių
    pateikiamus komponento apibrėžimus, galima būtų išskirti skaidrėje
    matomas \arabic{enumi} komponento savybes. Iš jų, norėčiau
    akcentuoti \ref{enum:component:fiz}, tai yra, kad komponentas yra
    fizinis diegimo vienetas, ir \ref{enum:component:req} – komponentas
    poreikius nurodo tik per išreikštines sąsajas.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Komponentinis modelis}
  \begin{itemize}
    \item Problemos su komponento apibrėžimu:
      \begin{enumerate}
        \item Nėra bendrai priimto apibrėžimo.
        \item Neaišku, kaip kuriami komponentai.
        \item Neaišku, kaip iš jų surenkama sistema.
      \end{enumerate}
    \item „Komponentinis modelis apibrėžia standartus komponentų
      realizacijai, įvardinimui, tarpusavio sąveikai, pritaikymui,
      kompozicijai, evoliucijai ir įdiegimui.“ (\mbox{G. T. Heineman},
      \mbox{W. T. Councill} 2001)
  \end{itemize}
  \begin{handout}
    Komponentinio programavimo tyrimas naudojantis komponento apibrėžimu
    turi trūkumus:
    \begin{itemize}
      \item nėra visuotinio sutarimo, kas yra komponentas;
      \item komponento apibrėžimas nepasako, nei kaip yra kuriami
        komponentai, nei kaip iš tų komponentų vėliau yra surenkama
        sistema.
    \end{itemize}
    Dėl šių priežasčių tampa sudėtinga lyginti skirtingas
    komponentines technologijas. Tam Heineman ir Councill įvedė
    komponentinio modelio sąvoką:
    „Komponentinis modelis apibrėžia standartus komponentų
    realizacijai, įvardinimui, tarpusavio sąveikai, pritaikymui,
    kompozicijai, evoliucijai ir įdiegimui.“
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Scala}
  \begin{enumerate}
    \item Abstraktūs tipai – nariai.
    \item Savo tipo anotavimas.
    \item Modulinė maišos kompozicija. Fragmentai \en{trait}.
  \end{enumerate}
  \begin{handout}
    Scala autoriai statines klasines stipriai tipizuotas objektines
    programavimo kalbas tokias kaip Java, C\# ir C++ papildė trimis
    konstrukcijomis:
    \begin{enumerate}
      \item abstraktūs tipai – nariai konstrukcija leidžia turėti
        narius, kurie yra abstraktūs nariai;
      \item savo tipo anotavimas leidžia pakeisti „this“ tipą;
      \item fragmentai kartu su moduline maišos kompozicija leidžia
        turėti daugybinio paveldėjimo privalumus išvengiant
        rombo problemos.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Scala komponentinis modelis}
  \begin{tabularx}{\textwidth}[]{X | X}
    Realizacija. & Klasė, fragmentas. \\
    \hline
    Sąsajos. & Abstraktūs ir konkretūs nariai. \\
    \hline
    Meta duomenys. & Nereikalingi. \\
    \hline
    Tarpusavio sąveika. & Žinutėmis. \\
    \hline
    Pritaikymas. &
      Konstruktoriaus parametrais, parametrizuojamais tipais. \\
    \hline
    Kompozicija. & Per paveldėjimo mechanizmą, kompiliuojant. \\
    \hline
    Evoliucijos palaikymas. & Atnaujinant perkompiliuoti. \\
    \hline
    Supakavimas ir įdiegimas. & \strong{Nėra.} \\
  \end{tabularx}
  \begin{handout}
    \begin{enumerate}
      \item \emph{Realizacija.}
        Komponentas gali būti realizuojamas, kaip \plangname{Scala} klasė
        arba kaip fragmentas.
      \item \emph{Sąsajos.}
        Komponentas servisus, kurių jam reikia, nurodo kaip abstrakčius
        narius, o kuriuos jis realizuoja – kaip konkrečius.
      \item \emph{Įvardinimas.}
        Komponentams globalūs vardai yra priskiriami taip pat, kaip ir
        \plangname{Java} klasėms – pagal hierarchines vardų sritis.
      \item \emph{Meta duomenys.} Kadangi \plangname{Scala} komponentai yra
        sujungiami statiškai kompiliavimo metu, tai meta duomenys nėra
        reikalingi.
      \item \emph{Tarpusavio sąveika.}
        Kadangi komponentų egzemplioriai \en{component instances} yra
        objektai, tai jie sąveikauja keisdamiesi žinutėmis.
      \item \emph{Pritaikymas.}
        Komponentą pritaikyti konkrečiam atvejui galima jam pateikiant
        kitokias jo abstrakčių narių realizacijas (pavyzdžiui, kitą
        konkretų tipą). Taip pat komponento egzemplioriaus sukūrimo
        metu jį galima pritaikyti pasinaudojant konstruktoriaus parametrais
        bei parametrizuojamais tipais.
      \item \emph{Kompozicija.}
        Komponentai yra surišami kompiliavimo metu. Abstraktūs nariai su
        jų realizacijomis yra sujungiami pagal sutampančią signatūrą.
        Kompozicijos rezultatas yra naujas komponentas, kuris gali būti
        toliau komponuojamas.
      \item \emph{Evoliucijos palaikymas.}
        Kadangi komponentai yra surišami kompiliavimo metu, tai norint
        pakeisti vieną komponentą kitu reikia perkompiliuoti sistemą.
        Taip pat nėra galimybės turėti dvi to paties komponento versijas
        vienoje sistemoje.
    \end{enumerate}
  \end{handout}
\end{frame}

\section{Kas pasiekta}

\begin{frame}
  \frametitle{Rezultatai}
  \begin{enumerate}
    \item Išskirtos esminės komponento savybės.
    \item Parodyta, kad Scala programavimo kalba ir Debian paketų
      tvarkymo sistema yra komponentinės technologijos.
    \item Nustatyta, kad pagrindinis Scala komponentinio modelio
      privalumas yra jo paprastumas.
  \end{enumerate}
  \begin{handout}
    Taigi, esminiai darbai, kurie buvo atlikti kursinio darbo metu:
    \begin{enumerate}
      \item Buvo išskirtos esminės komponento savybės.
      \item Parodyta, kad Scala programavimo kalba ir Debian paketų
        tvarkymo sistema yra komponentinės technologijos.
      \item Nustatyta, kad pagrindinis Scala komponentinio modelio
        privalumas yra jo paprastumas.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Išvados}
  \begin{itemize}
    \item Sujungia komponentų kūrimo ir komponavimo lygius į vieną.
    \item Išsiskiria naudojimo paprastumu.
    \item Nėra apibrėžtas supakavimas ir įdiegimas → sudėtingas
      perpanaudojamumas.
    \item Akcentuoja modifikuojamumą ir praplečiamumą.
  \end{itemize}
  \begin{handout}
    Scala, kaip komponentinė technologija yra ypatinga tuo, kad
    sujungia komponentų kūrimo ir jų komponavimo lygius į vieną.
    Tuo pačiu ji pasižymi naudojimo paprastumu. Pavyzdžiui, komponentinį
    „Sveikas pasauli“ galima būtų realizuoti su 10 eilučių kodo.
    Scala, kitaip nei Debian akcentuoja modifikuojamumą ir praplečiamumą.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Klausimai?}
\end{frame}
