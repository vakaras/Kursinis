\begin{comment}
  \TODO{Komponentinis modelis $\neq$ komponentinė realizacija. Surasti,
  kaip atsikirsti!}

  Turi būti viena pasakojimo gija.

  \begin{enumerate}
    \item Tematika (svarbiausių tematikos sąvokų apibrėžimai,
      įvadas į tematiką) - 1 skaidrė
    \item Problemos/uždavinio formulavimas (iš to turi išplaukti
      pagrindinė darbo tema) - 1 skaidrė
    \item Darbo tikslo formulavimas (jei sutampa su problemos
      formulavimu, tai kartoti nereikia) - 1 skaidrė
    \item Darbo planas (kaip pasieksite tikslą) - čia surašote
      punktus, kuriais buvo/bus pasiektas darbo tikslas - 1 skaidrė
    \item Temos gynimui (magistrantams): svarbiausios sąvokos
      (apibrėžimai, jei ilgi, neturi būti rašomi - turi būti sakomi
      žodžiu) - 2-3 skaidrės
    \item Darbo gynimui (bakalaurams, magistrantams): darbo metu
      iškilusios problemos, esminiai priimti sprendimai, kas buvo
      padaryta jūsų pačių ("susipažinau", "sukonspektavau",
      "išsiaiškinau", "išmokau" tinka tik kursiniams darbams!) - 3-6
      skaidrės
    \item (Laukiami) rezultatai - sąrašo pavidalu, ne daugiau trijų.
      "Susipažinau", "sukonspektavau", "išsiaiškinau", "išmokau" tinka
      tik kursiniams darbams! - 1 skaidrė
    \item Išvados - sąrašo pavidalu, ne daugiau trijų (temos gynime
      nereikia) - 1 skaidrė. Nebandykite rezultatų, pastebėjimų,
      komentarų, nuomonių apiforminti kaip išvadų!
  \end{enumerate}

  Pristatymo tikslas: supažindinti komisiją su darbu.
  1.  Darbo tikslas ir uždaviniai – planas.
  2.  Kas buvo padaryta – realizacija.
  3.  Rezultatai ir išvados.

  1.  Ko siekta.
  2.  Kaip siekta.
  3.  Kas pasiekta.
\end{comment}

\begin{handout}
  Laba diena, aš esu Programų sistemų 3 kurso 2 grupės studentas
  Vytautas Astrauskas. Dabar pristatysiu savo kursinį darbą, kurio
  tema yra „Komponentinis programavimas su Scala“.
\end{handout}

\begin{handout}
  Iš pradžių aš pristatysiu ko siekiau savo darbe, tada paminėsiu,
  mano nuomone, esminius elementus iš to kaip siekiau ir galiausiai
  ką man pavyko pasiekti.
\end{handout}

\section{Ko siekta}

\begin{frame}
  %\frametitle{Tematika}
  \begin{itemize}
    \item Komponentinis programavimas – tai programų sistemų kūrimo
      būdas, surenkant jas iš atskirų dalių (komponentų).
    \item Komponentinio programavimo žadamos savybės (Clemensas
      Szyperski 2002):
      \begin{enumerate}
        \item Modifikuojamumas.
        \item Praplečiamumas.
        \item Perpanaudojamumas.
      \end{enumerate}
  \end{itemize}
  \begin{handout}
    Kuriant programų sistemas rūpi, kad jos būtų lengvai tobulinamos.
    Komponentinis programavimas, tai yra programų sistemų kūrimo
    būdas, jas surenkant iš atskirų dalių, komponentų, kurie
    paprastai yra gaunami iš trečiųjų šalių. Clemens Szyperski
    teigimu:
    \begin{itemize}
      \item komponentinės sistemos yra lengviau modifikuojamos;
      \item jas lengviau praplėsti bei;
      \item patys komponentai yra lengvai perpanaudojami.
    \end{itemize}
  \end{handout}
\end{frame}

\begin{frame}
  %\frametitle{Problema}
  Martinas Odersky 2005:
  \begin{enumerate}
    \item Komponentinių technologijų plitimas stringa.
    \item Priežastis yra dabartinių programavimo kalbų trūkumai.
    \item Scala – kalba, su kuria galima programuoti komponentiškai.
  \end{enumerate}
  \begin{handout}
    \begin{itemize}
      \item Scala kūrėjo Martino Odersky teigimu komponentinių
        technologijų kūrimas stringa.
      \item Priežastis, jo nuomone, yra tai, kad dabartinėse
        programavimo kalbose trūksta priemonių leidžiančių
        apibrėžti ir sujungti komponentus.
      \item Tam jis kartu su kolegomis sukūrė programavimo kalbą
        Scala, su kuria, jo teigimu, galima programuoti komponentiškai.
    \end{itemize}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Darbo tikslas}
  Patikrinti ar Scala kūrėjų teiginys, jog su Scala yra įmanoma
  programuoti komponentiškai, yra teisingas.
  \begin{handout}
    Mano darbo tikslas buvo patikrinti ar Scala kūrėjų teiginys, jog
    su Scala yra įmanoma programuoti komponentiškai yra teisingas.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Uždaviniai}
  \begin{enumerate}
    \item Apibrėžti, kas yra objektinis programavimas.
    \item Išsiaiškinti, kas yra komponentinis programavimas.
    \item Patikrinti, ar su Scala galima programuoti komponentiškai.
    \item Nustatyti Scala, kaip komponentinės technologijos, privalumus.
  \end{enumerate}
  \begin{handout}
    Skaidrėje pateikti uždaviniai, kuriais buvo siekiama tikslo
    įgyvendinimo.

    Kadangi Scala yra ir objektinė programavimo kalba, tai
    norint suvokti, ką pridėjus ji tapo komponentinė, reikia
    suprasti, kas yra objektinis programavimas.

    Tada, aišku, reikia apibrėžti kas yra komponentinis, kokios jo
    privalomosios savybės ir tuomet jomis remiantis galima patikrinti
    ar Scala yra komponentinė technologija. O jei ji tokia yra,
    tada nustatyti jos privalumus lyginant su kitomis komponentinėmis
    technologijomis.
  \end{handout}
\end{frame}

\section{Kaip siekta}

\begin{handout}
  Dabar trumpai pristatysiu komponentinį programavimą, tada Scala
  naujas kalbos konstrukcijas ir galiausiai pristatysiu, kaip
  Scala realizuoja.
\end{handout}

\begin{frame}
  \frametitle{Komponentinis modelis}
  \begin{itemize}
    \item Problemos su tyrimu, naudojant komponento apibrėžimą:
      \begin{enumerate}
        \item Nėra bendrai priimto apibrėžimo.
        \item Neaišku, kaip kuriami komponentai.
        \item Neaišku, kaip iš jų surenkama sistema.
      \end{enumerate}
    \item „Komponentinis modelis apibrėžia standartus komponentų
      realizacijai, įvardinimui, tarpusavio sąveikai, pritaikymui,
      kompozicijai, evoliucijai ir įdiegimui.“ (\mbox{G. T. Heinemanas},
      \mbox{W. T. Councillas} 2001)
      \begin{itemize}
        \item Sąsajos.
        \item Meta duomenys.
      \end{itemize}
  \end{itemize}
  \begin{handout}
    Bandant analizuoti komponentinį programavimą pasinaudojant komponento
    apibrėžimu kyla problemų:
    \begin{itemize}
      \item nėra bendrai priimto apibrėžimo (Clemensas Szyperski
        pateikia vienokį, Desmondas F. D'Souza su Alanu Cemeronu
        Willsu pateikia kitokį, ir t. t.);
      \item komponento apibrėžimas nepasako, nei kaip yra kuriami
        komponentai, nei kaip iš tų komponentų vėliau yra surenkama
        sistema.
    \end{itemize}
    Dėl šių priežasčių tampa sudėtinga lyginti skirtingas
    komponentines technologijas. Tam Heinemanas ir Councillas įvedė
    komponentinio modelio sąvoką:
    \begin{quote}
      „Komponentinis modelis apibrėžia standartus komponentų
      realizacijai, įvardinimui, tarpusavio sąveikai, pritaikymui,
      kompozicijai, evoliucijai ir įdiegimui.“
    \end{quote}
    Pačiame apibrėžime autoriai nepamini, bet savo knygoje taip pat
    išskiria sąsajų ir meta duomenų standartus. Pagal šiuos 9
    punktus aš vėliau analizuosiu Scala, o prieš tai norėčiau
    pristatyti jos „naujoves“.

    Klausimams:
    \begin{enumerate}
      \item \emph{Sąsajos} – kokiu būdu yra aprašoma kaip naudotis
        komponentu.
      \item \emph{Įvardinimas} – kokiu būdu yra priskiriami globaliai
        unikalūs vardai sąsajoms ir komponentams. Autoriai išskiria
        du pagrindinius būdus: unikalūs identifikatoriai ir
        hierarchinės vardų sritys.
      \item \emph{Meta duomenys} – informacija apie komponentus, sąsajas
        ir jų ryšius. Taip pat komponentinio modelio teikiamos paslaugos
        šiai informacijai gauti. Šie duomenys yra reikalingi tam, kad
        galima būtų dinamiškai sujungti komponentus, įskaitant ir
        nutolusius.
      \item \emph{Tarpusavio sąveika} – kokiu būdu komponentai bendrauja
        ir keičiasi informacija tarpusavyje.
      \item \emph{Pritaikymas} – kokias galimybes turi komponento
        naudotojas, norintis komponentą pritaikyti savo poreikiams.
      \item \emph{Kompozicija} – sąsajos ir taisyklės komponentų
        sujungimui į ansamblius, jų pakeitimui bei pridėjimui į jau
        egzistuojančius.
      \item \emph{Evoliucijos palaikymas} – taisyklės ir paslaugos
        komponentų ir sąsajų pakeitimui naujesnėmis versijomis.
      \item \emph{Supakavimas ir įdiegimas} – kaip turėtų būti supakuojami
        komponento realizacija bei resursai, reikalingi jo įdiegimui
        ir sukonfigūravimui.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Scala}
  \begin{enumerate}
    \item Abstraktūs tipai – nariai.
    \item Savo tipo anotavimas.
    \item Modulinė maišos kompozicija. Fragmentai \en{trait}.
  \end{enumerate}
  \begin{handout}
    Scala autoriai statines klasines stipriai tipizuotas objektines
    programavimo kalbas tokias kaip Java, C\# ir C++ papildė trimis
    konstrukcijomis:
    \begin{enumerate}
      \item abstraktūs tipai – nariai konstrukcija leidžia turėti
        narius, kurie yra abstraktūs tipai;
      \item savo tipo anotavimas leidžia pakeisti „this“ tipą;
      \item fragmentai kartu su moduline maišos kompozicija leidžia
        turėti daugybinio paveldėjimo privalumus išvengiant
        rombo problemos.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Scala komponentinis modelis}
  \begin{tabularx}{\textwidth}[]{l | X}
    Realizacija. & Klasė, fragmentas. \\
    \hline
    Sąsajos. & Abstraktūs ir konkretūs nariai. \\
    \hline
    Įvardinimas. & Hierarchinės vardų sritys. \\
    \hline
    Meta duomenys. & Nereikalingi. \\
    \hline
    Tarpusavio sąveika. & Žinutėmis. \\
    \hline
    Pritaikymas. &
      Konstruktoriaus parametrais, parametrizuojamais tipais. \\
    \hline
    Kompozicija. & Per paveldėjimo mechanizmą, kompiliuojant. \\
    \hline
    Evoliucijos palaikymas. & Atnaujinant perkompiliuoti. \\
    \hline
    Supakavimas ir įdiegimas. & \strong{Nėra.} \\
  \end{tabularx}
  \begin{handout}
    \begin{enumerate}
      \item \emph{Realizacija.}
        Komponentas gali būti realizuojamas, kaip \plangname{Scala} klasė
        arba kaip fragmentas.
      \item \emph{Sąsajos.}
        Komponentas servisus, kurių jam reikia, nurodo kaip abstrakčius
        narius, o kuriuos jis realizuoja – kaip konkrečius.
      \item \emph{Įvardinimas.}
        Komponentams globalūs vardai yra priskiriami taip pat, kaip ir
        \plangname{Java} klasėms – pagal hierarchines vardų sritis.
      \item \emph{Meta duomenys.} Kadangi \plangname{Scala} komponentai yra
        sujungiami statiškai kompiliavimo metu, tai meta duomenys nėra
        reikalingi. (Apibrėžimo autoriai nurodo, kad ši informacija
        yra reikalinga vykdymo metu norint sujungti komponentus.)
      \item \emph{Tarpusavio sąveika.}
        Kadangi komponentų egzemplioriai \en{component instances} yra
        objektai, tai jie sąveikauja keisdamiesi žinutėmis.
      \item \emph{Pritaikymas.}
        Komponento egzemplioriaus sukūrimo metu jį galima pritaikyti
        pasinaudojant konstruktoriaus parametrais bei parametrizuojamais
        tipais.
      \item \emph{Kompozicija.}
        Komponentai yra surišami kompiliavimo metu. Abstraktūs nariai su
        jų realizacijomis yra sujungiami pagal sutampančią signatūrą.
        Kompozicijos rezultatas yra naujas komponentas, kuris gali būti
        toliau komponuojamas.
      \item \emph{Evoliucijos palaikymas.}
        Kadangi komponentai yra surišami kompiliavimo metu, tai norint
        pakeisti vieną komponentą kitu reikia perkompiliuoti sistemą.
    \end{enumerate}
  \end{handout}
\end{frame}

\section{Kas pasiekta}

\begin{frame}
  \frametitle{Rezultatai}
  \begin{enumerate}
    \item Išskirtos esminės komponento savybės.
    \item Nustatyta, kad Scala kūrėjų siūlomas būdas iš tiesų gali
      būti laikomas komponentiniu programavimu.
  \end{enumerate}
  \begin{handout}
    Taigi, esminiai darbai, kurie buvo atlikti kursinio darbo metu:
    \begin{enumerate}
      \item Išskirtos esminės komponento savybės.
      \item Nustatyta, kad Scala kūrėjų siūlomas būdas iš tiesų gali
        būti laikomas komponentiniu programavimu.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Išvados}
  \begin{enumerate}
    \item Sujungia komponentų kūrimo ir komponavimo lygius į vieną.
    \item Išsiskiria naudojimo paprastumu.
    \item Nėra apibrėžtas supakavimas ir įdiegimas $\to$ prastas
      perpanaudojamumas.
    \item Akcentuoja modifikuojamumą ir praplečiamumą.
  \end{enumerate}
  \begin{handout}
    \begin{enumerate}
      \item Scala, kaip komponentinė technologija yra ypatinga tuo, kad
        sujungia komponentų kūrimo ir jų komponavimo lygius į vieną.
      \item Tuo pačiu ji pasižymi naudojimo paprastumu. Pavyzdžiui,
        komponentinį „Sveikas pasauli“ galima būtų realizuoti su
        10 eilučių kodo.
      \item Bet tai, kad nėra apibrėžtas komponentų perdavimo formatas,
        apsunkina jos kodo perpanaudojamumą.
      \item Taigi Scala, kaip ir kiti komponentinių modelių
        klasifikacijos autorių tirti modeliai akcentuoja
        modifikuojamumą ir praplečiamumą.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Klausimai?}
\end{frame}
