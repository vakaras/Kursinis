\begin{comment}
  \TODO{Komponentinis modelis $\neq$ komponentinė realizacija. Surasti,
  kaip atsikirsti!}

  Turi būti viena pasakojimo gija.

  \begin{enumerate}
    \item Tematika (svarbiausių tematikos sąvokų apibrėžimai,
      įvadas į tematiką) - 1 skaidrė
    \item Problemos/uždavinio formulavimas (iš to turi išplaukti
      pagrindinė darbo tema) - 1 skaidrė
    \item Darbo tikslo formulavimas (jei sutampa su problemos
      formulavimu, tai kartoti nereikia) - 1 skaidrė
    \item Darbo planas (kaip pasieksite tikslą) - čia surašote
      punktus, kuriais buvo/bus pasiektas darbo tikslas - 1 skaidrė
    \item Temos gynimui (magistrantams): svarbiausios sąvokos
      (apibrėžimai, jei ilgi, neturi būti rašomi - turi būti sakomi
      žodžiu) - 2-3 skaidrės
    \item Darbo gynimui (bakalaurams, magistrantams): darbo metu
      iškilusios problemos, esminiai priimti sprendimai, kas buvo
      padaryta jūsų pačių ("susipažinau", "sukonspektavau",
      "išsiaiškinau", "išmokau" tinka tik kursiniams darbams!) - 3-6
      skaidrės
    \item (Laukiami) rezultatai - sąrašo pavidalu, ne daugiau trijų.
      "Susipažinau", "sukonspektavau", "išsiaiškinau", "išmokau" tinka
      tik kursiniams darbams! - 1 skaidrė
    \item Išvados - sąrašo pavidalu, ne daugiau trijų (temos gynime
      nereikia) - 1 skaidrė. Nebandykite rezultatų, pastebėjimų,
      komentarų, nuomonių apiforminti kaip išvadų!
  \end{enumerate}

  Pristatymo tikslas: supažindinti komisiją su darbu.
  1.  Darbo tikslas ir uždaviniai – planas.
  2.  Kas buvo padaryta – realizacija.
  3.  Rezultatai ir išvados.

  1.  Ko siekta.
  2.  Kaip siekta.
  3.  Kas pasiekta.
\end{comment}

\begin{handout}
  Laba diena, aš esu Programų sistemų 3 kurso 2 grupės studentas
  Vytautas Astrauskas. Dabar pristatysiu savo kursinį darbą, kurio
  tema yra „Komponentinis programavimas su Scala“.
\end{handout}

\begin{handout}
  Iš pradžių aš pristatysiu ko siekiau savo darbe, tada paminėsiu,
  mano nuomone, esminius elementus iš to kaip siekiau ir galiausiai
  ką man pavyko pasiekti.
\end{handout}

\section{Ko siekta}

\begin{frame}
  %\frametitle{Tematika}
  \begin{itemize}
    \item Komponentinis programavimas – tai programų sistemų kūrimo
      būdas, surenkant jas iš atskirų dalių (komponentų).
    \item Komponentinio programavimo žadamos savybės (Clemensas
      Szyperski 2002):
      \begin{enumerate}
        \item Modifikuojamumas.
        \item Praplečiamumas.
        \item Perpanaudojamumas.
      \end{enumerate}
  \end{itemize}
  \begin{handout}
    Kuriant programų sistemas rūpi, kad jos būtų lengvai tobulinamos.
    Komponentinis programavimas, tai yra programų sistemų kūrimo
    būdas, jas surenkant iš atskirų dalių, komponentų, kurie
    paprastai yra gaunami iš trečiųjų šalių. Clemens Szyperski
    teigimu:
    \begin{itemize}
      \item komponentinės sistemos yra lengviau modifikuojamos;
      \item jas lengviau praplėsti bei;
      \item patys komponentai yra lengvai perpanaudojami.
    \end{itemize}
  \end{handout}
\end{frame}

\begin{frame}
  %\frametitle{Problema}
  Martinas Odersky:
  \begin{enumerate}
    \item Komponentinių technologijų plitimas stringa.
    \item Priežastis yra dabartinių programavimo kalbų trūkumai.
    \item Scala – kalba, su kuria galima programuoti komponentiškai.
  \end{enumerate}
  \begin{handout}
    Scala kūrėjo Martino Odersky teigimu komponentinių technologijų
    kūrimas stringa. Priežastis, jo nuomone, yra tai, kad dabartinėse
    programavimo kalbose trūksta priemonių leidžiančių apibrėžti
    ir sujungti komponentus. Tam jis kartu su kolegomis sukūrė
    programavimo kalbą Scala, su kuria, jo teigimu, galima
    programuoti komponentiškai.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Darbo tikslas}
  Patikrinti ar Scala kūrėjų teiginys, jog su Scala yra įmanoma
  programuoti komponentiškai, yra teisingas.
  \begin{handout}
    Mano darbo tikslas buvo patikrinti ar Scala kūrėjų teiginys, jog
    su Scala yra įmanoma programuoti komponentiškai yra teisingas.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Uždaviniai}
  \begin{enumerate}
    \item Apibrėžti, kas yra objektinis programavimas.
    \item Išsiaiškinti, kas yra komponentinis programavimas.
    \item Patikrinti, ar su Scala galima programuoti komponentiškai.
    \item Nustatyti Scala, kaip komponentinės technologijos, privalumus.
  \end{enumerate}
  \begin{handout}
    Skaidrėje pateikti uždaviniai, kuriais buvo siekiama tikslo
    įgyvendinimo.

    Kadangi Scala yra ir objektinė programavimo kalba, tai
    norint suvokti, ką pridėjus ji tapo komponentinė, reikia
    suprasti, kas yra objektinis programavimas.

    Tada, aišku, reikia apibrėžti kas yra komponentinis, kokios jo
    privalomosios savybės ir tuomet jomis remiantis galima patikrinti
    ar Scala yra komponentinė technologija. O jei ji tokia yra,
    tada nustatyti jos privalumus lyginant su kitomis komponentinėmis
    technologijomis.
  \end{handout}
\end{frame}

\section{Kaip siekta}

\begin{frame}
  \frametitle{Komponento savybės}
  \begin{enumerate}
    \item Fizinis diegimo vienetas.
    \item Juoda dėžė.
    \item Funkcionalumas pasiekiamas tik per išreikštines sąsajas.
    \item Poreikius nurodo tik per išreikštines sąsajas.
    \item Gali būti kuriamas nepriklausomai.
    \item Gali būti perpanaudojamas.
    \item Gali būti be pakeitimų įkomponuotas.
    \item Gali būti pakeičiamas kitu.
  \end{enumerate}
  \begin{handout}
    Iš pradžių galima bandyti apibrėžti komponentinį programavimą
    pasinaudojant komponento sąvoka. Išnagrinėjus keleto autorių
    pateikiamus komponento apibrėžimus, galima būtų išskirti tokias
    komponento savybes:
    \begin{enumerate}
      \item Komponentas yra fizinis diegimo vienetas.
      \item Jis yra juoda dėžė.
      \item Prie jo funkcionalumo galima prieiti tik per išreikštinai
        apibrėžtas sąsajas.
      \item Komponentas savo poreikius nurodo tik per išreikštinai
        apibrėžtas sąsajas.
      \item Komponentas gali būti kuriamas nepriklausomai.
      \item Gali būti perpanaudojamas.
      \item Gali būti be pakeitimų sujungtas su kitais komponentais
        į vieną sistemą.
      \item Gali būti sistemoje pakeičiamas kitu, jei naujasis įgyvendina
        visą senojo funkcionalumą ir nereikalauja nieko daugiau.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Komponentinis modelis}
  „Komponentinis modelis apibrėžia standartus komponentų
  realizacijai, įvardinimui, tarpusavio sąveikai, pritaikymui,
  kompozicijai, evoliucijai ir įdiegimui.“
  \begin{handout}
    Komponentinio programavimo apibrėžimas naudojant komponento
    sąvoką, turi trūkumą, kad remiantis juo sudėtinga nagrinėti
    skirtingas komponentinių sistemų kūrimo metodikas ir jas
    lyginti. Tam tikslui yra naudinga įsivesti komponentinio modelio
    sąvoką. Skaidrėje pateiktas Heineman ir Councill komponentinio
    modelio apibrėžimas:
    „Komponentinis modelis apibrėžia standartus komponentų
    realizacijai, įvardinimui, tarpusavio sąveikai, pritaikymui,
    kompozicijai, evoliucijai ir įdiegimui.“
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Debian paketų tvarkymo sistema}
  \begin{itemize}
    \item Clemensas Szyperski: operacinė sistema yra pirmoji sėkminga
      komponentinė technologija.
    \item Debian – komponentinė technologija?
    \item Netenkina komponento savybės: priklausyti nuo sąsajų.
    \item Akcentuoja perpanaudojamumą.
  \end{itemize}
  \begin{handout}
    Turint komponento bei komponentinio modelio apibrėžimus galima
    patikrinti, ar kai kurios technologijos yra komponentinės. Pradėkime
    nuo Debian paketų tvarkymo sistemos. Clemenso Szyperski teigimu
    operacinė sistema yra pirmoji sėkminga komponentinė technologija.
    Čia komponentu yra laikoma programa. Klausimas: ar Debian yra
    komponentinė technologija? Palyginus Debian paketo ir komponento
    savybes, matosi, kad Debian paketas ne visada priklauso nuo sąsajos.
    Nepaisant to, galima būtų teigti, kad Debian yra komponentinė
    technologija, kuri iš Szyperski išvardintų komponentinio savybių
    akcentuoja perpanaudojamumą.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Scala komponentinis modelis}
  \begin{itemize}
    \item Komponentas: klasė arba fragmentas.
    \item Prašoma paslauga: abstraktus narys.
    \item Teikiama paslauga: konkretus narys.
    \item Sujungiama: kompiliuojant.
    \item Netenkina komponento savybės: yra fizinis diegimo vienetas.
  \end{itemize}
  \begin{handout}
    Dabar keletas žodžių apie Scala komponentinį modelį. Scala
    programavimo kalboje komponentus galima realizuoti, kaip klases arba
    fragmentus (angliškai „trait“). Komponentai prašomas paslaugas
    nurodo per abstrakčius narius, o teikiamas per konkrečius ir tada
    kompiliavimo metu nariai yra sujungiami pagal sutampančias
    signatūras. Vėlgi, palyginus su komponento apibrėžimu, galime
    matyti, kad Scala komponentai netenkina tos savybės, jog jie nėra
    fiziniai diegimo vienetai, bet šią problemą galima nesunkiai
    apeiti kitomis priemonėmis ir todėl galima būtų teigti, kad
    Scala irgi yra komponentinė technologija.
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Scala komponentinio savybės}
  \begin{itemize}
    \item Sujungia komponentų kūrimo ir komponavimo lygius į vieną.
    \item Išsiskiria naudojimo paprastumu.
    \item Akcentuoja modifikuojamumą ir praplečiamumą.
  \end{itemize}
  \begin{handout}
    Scala, kaip komponentinė technologija yra ypatinga tuo, kad
    sujungia komponentų kūrimo ir jų komponavimo lygius į vieną.
    Tuo pačiu ji pasižymi naudojimo paprastumu. Pavyzdžiui, komponentinį
    „Sveikas pasauli“ galima būtų realizuoti su 10 eilučių kodo.
    Scala, kitaip nei Debian akcentuoja modifikuojamumą ir praplečiamumą.
  \end{handout}
\end{frame}

\section{Kas pasiekta}

\begin{frame}
  \frametitle{Rezultatai}
  \begin{enumerate}
    \item Išskirtos esminės komponento savybės.
    \item Parodyta, kad Scala programavimo kalba ir Debian paketų
      tvarkymo sistema yra komponentinės technologijos.
    \item Nustatyta, kad pagrindinis Scala komponentinio modelio
      privalumas yra jo paprastumas.
  \end{enumerate}
  \begin{handout}
    Taigi, esminiai darbai, kurie buvo atlikti kursinio darbo metu:
    \begin{enumerate}
      \item Buvo išskirtos esminės komponento savybės.
      \item Parodyta, kad Scala programavimo kalba ir Debian paketų
        tvarkymo sistema yra komponentinės technologijos.
      \item Nustatyta, kad pagrindinis Scala komponentinio modelio
        privalumas yra jo paprastumas.
    \end{enumerate}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Išvados}
  \begin{enumerate}
    \item Praplečiamumas ir modifikuojamumas: Scala.
    \item Perpanaudojamumas: Debian.
    \item Visos trys(?):
      \begin{enumerate}
        \item Visų komponento savybių realizavimas be išimčių.
        \item Platinimo ir įdiegimo mechanizmų apibrėžimas.
      \end{enumerate}
  \end{enumerate}
  \begin{handout}
    Apibendrinat: Scala „duoda“ praplečiamumą ir modifikuojamumą, o
    Debian „duoda“ perpanaudojamumą. Tikslas, aišku, yra turėti
    visas tris savybes. Taigi iš turimų pavyzdžių analizės galima
    būtų kelti hipotezę, kad visas tris savybes galėtų duoti komponentinė
    technologija, kurios:
    \begin{itemize}
      \item komponentai tenkintų visas komponento savybes be išimčių ir
      \item kuri apibrėžtų komponentų platinimo bei automatinio
        įdiegimo kartu su priklausomybėmis mechanizmus.
    \end{itemize}
  \end{handout}
\end{frame}

\begin{frame}
  \frametitle{Klausimai?}
\end{frame}
